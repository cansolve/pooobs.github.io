var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/node.ts
import fs from "fs";
import path from "path";
import { Feed } from "feed";
import { formatDate, getDefaultTitle, getFileLastModifyTime, getTextSummary, getVitePressPages, grayMatter, joinPath, normalizePath, renderDynamicMarkdown } from "@sugarat/theme-shared";
var imageRegex = /!\[.*?\]\((.*?)\s*(".*?")?\)/;
var htmlCache = /* @__PURE__ */ new Map();
function getPostsData(config, ops) {
  return __async(this, null, function* () {
    var _a, _b, _c, _d;
    const { ignoreHome = true, ignorePublish = false, renderHTML = true } = ops;
    const pagesData = getVitePressPages(config);
    const { createMarkdownRenderer } = yield import("vitepress");
    const mdRender = yield createMarkdownRenderer(
      config.srcDir,
      config.markdown,
      config.site.base,
      config.logger
    );
    let posts = [];
    const fileContentPromises = pagesData.reduce((prev, f) => {
      const { isDynamic, dynamicRoute, filepath } = f;
      const contentPromise = isDynamic && dynamicRoute ? Promise.resolve(renderDynamicMarkdown(filepath, dynamicRoute == null ? void 0 : dynamicRoute.params, dynamicRoute == null ? void 0 : dynamicRoute.content)) : fs.promises.readFile(filepath, "utf-8");
      prev[f.page] = {
        contentPromise,
        datePromise: getFileLastModifyTime(f.filepath)
      };
      return prev;
    }, {});
    for (const page of pagesData) {
      const { contentPromise, datePromise } = fileContentPromises[page.page];
      const fileContent = yield contentPromise;
      const { data: frontmatter, excerpt, content } = grayMatter(fileContent, {
        excerpt: true
      });
      if (!frontmatter.title) {
        frontmatter.title = getDefaultTitle(content);
      }
      frontmatter.title = `${frontmatter.title}`;
      const date = yield frontmatter.date || datePromise;
      frontmatter.date = formatDate(date);
      frontmatter.description = (_b = yield (_a = ops == null ? void 0 : ops.renderExpect) == null ? void 0 : _a.call(ops, content, __spreadValues({}, frontmatter))) != null ? _b : frontmatter.description || excerpt || getTextSummary(content, 100);
      frontmatter.cover = ((_d = frontmatter.cover) != null ? _d : (_c = fileContent.match(imageRegex)) == null ? void 0 : _c[1]) || "";
      const targetPage = normalizePath(
        page.rewritePath ? page.rewritePath : page.page
      );
      const url = joinPath(config.site.base, targetPage).replace(/(^|\/)index\.md$/, "$1").replace(/\.md$/, config.cleanUrls ? "" : ".html");
      posts.push({
        filepath: page.filepath,
        fileContent,
        description: frontmatter.description,
        date: frontmatter.date,
        title: frontmatter.title,
        url,
        frontmatter
      });
    }
    posts = posts.filter((p) => {
      if (p.frontmatter.layout === "home" && ignoreHome) {
        return false;
      }
      if (p.frontmatter.publish === false && !ignorePublish)
        return false;
      return true;
    });
    if (ops == null ? void 0 : ops.filter) {
      posts = posts.filter(ops.filter);
    }
    posts.sort(
      (a, b) => +new Date(b.date) - +new Date(a.date)
    );
    if (void 0 !== (ops == null ? void 0 : ops.limit) && (ops == null ? void 0 : ops.limit) > 0) {
      posts.splice(ops.limit);
    }
    for (const post of posts) {
      const { fileContent, filepath } = post;
      if (!htmlCache.has(filepath)) {
        let html;
        if (renderHTML === true) {
          html = mdRender.render(fileContent);
        } else if (typeof renderHTML === "function") {
          html = yield renderHTML(fileContent);
        }
        if (html) {
          htmlCache.set(filepath, html);
        }
      }
    }
    return posts;
  });
}
function genFeed(config, rssOptions) {
  return __async(this, null, function* () {
    var _b, _c, _d, _e;
    if (!rssOptions)
      return;
    const { baseUrl, filename } = rssOptions;
    const _a = rssOptions, { renderHTML } = _a, restOps = __objRest(_a, ["renderHTML"]);
    const feed = new Feed(__spreadValues({
      id: rssOptions.baseUrl,
      link: rssOptions.baseUrl
    }, restOps));
    const posts = yield getPostsData(config, rssOptions);
    for (const post of posts) {
      const { title, description, date, frontmatter, url } = post;
      const author = frontmatter.author || ((_b = rssOptions.author) == null ? void 0 : _b.name);
      const authorInfo = (_c = rssOptions.authors) == null ? void 0 : _c.find((v) => v.name === author);
      const link = `${baseUrl}${url}`;
      feed.addItem({
        title,
        id: link,
        link,
        description,
        content: (_d = htmlCache.get(post.filepath)) == null ? void 0 : _d.replaceAll("&ZeroWidthSpace;", ""),
        author: [
          __spreadValues({
            name: author
          }, authorInfo)
        ],
        image: (frontmatter == null ? void 0 : frontmatter.cover) ? new URL(frontmatter == null ? void 0 : frontmatter.cover, baseUrl).href : "",
        date: new Date(date)
      });
    }
    const RSSFilename = filename || "feed.rss";
    const RSSFilepath = path.join(config.outDir, RSSFilename);
    yield fs.promises.writeFile(RSSFilepath, feed.rss2());
    if ((_e = rssOptions.log) != null ? _e : true) {
      console.log("\u{1F389} RSS generated", RSSFilename);
      console.log("rss filepath:", RSSFilepath);
      console.log("rss url:", `${baseUrl}${config.site.base + RSSFilename}`);
      console.log("include", posts.length, "posts");
    }
  });
}

// src/index.ts
var svgIcon = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 448 512"><title>RSS</title><path d="M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM112 416c-26.51 0-48-21.49-48-48s21.49-48 48-48s48 21.49 48 48s-21.49 48-48 48zm157.533 0h-34.335c-6.011 0-11.051-4.636-11.442-10.634c-5.214-80.05-69.243-143.92-149.123-149.123c-5.997-.39-10.633-5.431-10.633-11.441v-34.335c0-6.535 5.468-11.777 11.994-11.425c110.546 5.974 198.997 94.536 204.964 204.964c.352 6.526-4.89 11.994-11.425 11.994zm103.027 0h-34.334c-6.161 0-11.175-4.882-11.427-11.038c-5.598-136.535-115.204-246.161-251.76-251.76C68.882 152.949 64 147.935 64 141.774V107.44c0-6.454 5.338-11.664 11.787-11.432c167.83 6.025 302.21 141.191 308.205 308.205c.232 6.449-4.978 11.787-11.432 11.787z" fill="currentColor"></path></svg>';
var okMark = "\x1B[32m\u2713\x1B[0m";
function SocialIcon(rssOptions, base = "/") {
  const icon = typeof rssOptions.icon === "string" ? rssOptions.icon : svgIcon;
  return {
    icon: {
      svg: icon
    },
    link: rssOptions.url || `${rssOptions.baseUrl}${base + (rssOptions.filename || "feed.rss")}`,
    ariaLabel: (rssOptions == null ? void 0 : rssOptions.ariaLabel) || "RSS"
  };
}
function RssPlugin(rssOptions) {
  let resolveConfig;
  const pluginOps = {
    name: "vitepress-plugin-rss",
    enforce: "pre",
    configResolved(config) {
      var _a, _b, _c;
      if (resolveConfig) {
        return;
      }
      resolveConfig = config;
      const VPConfig = config.vitepress;
      if (!VPConfig) {
        return;
      }
      const localesConfig = [];
      if ((_a = rssOptions.icon) != null ? _a : true) {
        VPConfig.site.themeConfig.socialLinks = [
          SocialIcon(rssOptions, VPConfig.site.base),
          ...VPConfig.site.themeConfig.socialLinks
        ];
        if ((rssOptions == null ? void 0 : rssOptions.locales) && ((_b = VPConfig.site) == null ? void 0 : _b.locales)) {
          Object.keys((_c = VPConfig.site) == null ? void 0 : _c.locales).forEach((locale) => {
            var _a2, _b2, _c2;
            const rssCfg = (_a2 = rssOptions == null ? void 0 : rssOptions.locales) == null ? void 0 : _a2[locale];
            if (rssCfg && ((_b2 = rssCfg == null ? void 0 : rssCfg.icon) != null ? _b2 : true)) {
              const _tcfg = (_c2 = VPConfig.site.locales[locale]) == null ? void 0 : _c2.themeConfig;
              if (!_tcfg) {
                VPConfig.site.locales[locale].themeConfig = {};
              }
              VPConfig.site.locales[locale].themeConfig.socialLinks = [
                SocialIcon(rssCfg, VPConfig.site.base),
                ...(_tcfg == null ? void 0 : _tcfg.socialLinks) || []
              ];
              if (!rssCfg.filter) {
                rssCfg.filter = (value) => {
                  return !!value.url.startsWith(`/${locale}`);
                };
              }
              localesConfig.push(rssCfg);
            }
          });
        }
      }
      const selfBuildEnd = VPConfig.buildEnd;
      VPConfig.buildEnd = (siteConfig) => __async(this, null, function* () {
        var _a2;
        yield selfBuildEnd == null ? void 0 : selfBuildEnd(siteConfig);
        console.time(`${okMark} generating RSS`);
        for (const _rssOptions of localesConfig) {
          yield genFeed(siteConfig, _rssOptions);
        }
        if (!rssOptions.filter && localesConfig.length > 0) {
          rssOptions.filter = (value, idx, arr) => {
            return !localesConfig.some((cfg) => {
              var _a3;
              return !!((_a3 = cfg == null ? void 0 : cfg.filter) == null ? void 0 : _a3.call(cfg, value, idx, arr));
            });
          };
        }
        yield genFeed(siteConfig, rssOptions);
        console.timeEnd(`${okMark} generating RSS`);
        if ((_a2 = rssOptions.log) != null ? _a2 : true) {
          console.log();
        }
      });
    }
  };
  return pluginOps;
}
export {
  RssPlugin,
  genFeed,
  svgIcon
};
