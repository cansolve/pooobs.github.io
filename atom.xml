<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cansolve.cn/"/>
  <updated>2020-06-12T09:23:28.803Z</updated>
  <id>http://cansolve.cn/</id>
  
  <author>
    <name>tongxiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS滚动条样式</title>
    <link href="http://cansolve.cn/2020/06/12/daily22/"/>
    <id>http://cansolve.cn/2020/06/12/daily22/</id>
    <published>2020-06-12T02:03:13.000Z</published>
    <updated>2020-06-12T09:23:28.803Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><h1 id="转载-https-segmentfault-com-a-1190000012800450-utm-source-tag-newest"><a href="#转载-https-segmentfault-com-a-1190000012800450-utm-source-tag-newest" class="headerlink" title="转载:https://segmentfault.com/a/1190000012800450?utm_source=tag-newest"></a>转载:<a href="https://segmentfault.com/a/1190000012800450?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012800450?utm_source=tag-newest</a></h1><h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h1><p>在CSS 中，如果我们在块级容器上设置了属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">overflow:scroll /* x y 方向都会*/</span><br><span class="line">或者</span><br><span class="line">overflow-x:scroll /*只是x方向*/</span><br><span class="line">或者</span><br><span class="line">overflow-y:scroll  /*只是y方向*/</span><br></pre></td></tr></table></figure><p>当块级内容区域超出块级元素范围的时候，就会以滚动条的形式展示，你可以滚动里面的内容，里面的内容不会超出块级区域范围。<br>有时候我们需要自定义滚动条的样式，比如一开始就它显示，比如想改变滚动条的颜色，设置轨道的样式等，那么这篇文章就是为你准备的。</p><h1 id="二-正文"><a href="#二-正文" class="headerlink" title="二 正文"></a>二 正文</h1><p>1.认识滚动条</p><p>设置scrollbar的为CSS伪元素:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-scrollbar              &#123; /* 1 */ &#125;</span><br><span class="line">::-webkit-scrollbar-button       &#123; /* 2 */ &#125;</span><br><span class="line">::-webkit-scrollbar-track        &#123; /* 3 */ &#125;</span><br><span class="line">::-webkit-scrollbar-track-piece  &#123; /* 4 */ &#125;</span><br><span class="line">::-webkit-scrollbar-thumb        &#123; /* 5 */ &#125;</span><br><span class="line">::-webkit-scrollbar-corner       &#123; /* 6 */ &#125;</span><br><span class="line">::-webkit-resizer                &#123; /* 7 */ &#125;</span><br></pre></td></tr></table></figure><p>属性介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-scrollbar    //滚动条整体部分</span><br><span class="line">::-webkit-scrollbar-button   //滚动条两端的按钮</span><br><span class="line">::-webkit-scrollbar-track   // 外层轨道</span><br><span class="line">::-webkit-scrollbar-track-piece    //内层轨道，滚动条中间部分（除去）</span><br><span class="line">::-webkit-scrollbar-thumb //滚动条里面可以拖动的那个</span><br><span class="line">::-webkit-scrollbar-corner   //边角</span><br><span class="line">::-webkit-resizer   ///定义右下角拖动块的样式</span><br></pre></td></tr></table></figure><p>2.设置样式</p><p><a href="http://www.xuanfengge.com/demo/201311/scroll/css3-scroll.html" target="_blank" rel="noopener">demo</a><br>进入页面，打开控制台工具，选中其中一个样式，就能看到该样式的CSS源码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*定义滚动条高宽及背景</span><br><span class="line"> 高宽分别对应横竖滚动条的尺寸*/</span><br><span class="line">::-webkit-scrollbar</span><br><span class="line">&#123;</span><br><span class="line">    width:16px;</span><br><span class="line">    height:16px;</span><br><span class="line">    background-color:#F5F5F5;</span><br><span class="line">&#125;</span><br><span class="line">/*定义滚动条轨道</span><br><span class="line"> 内阴影+圆角*/</span><br><span class="line">::-webkit-scrollbar-track</span><br><span class="line">&#123;</span><br><span class="line">    -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,0.3);</span><br><span class="line">    border-radius:10px;</span><br><span class="line">    background-color:#F5F5F5;</span><br><span class="line">&#125;</span><br><span class="line">/*定义滑块</span><br><span class="line"> 内阴影+圆角*/</span><br><span class="line">::-webkit-scrollbar-thumb</span><br><span class="line">&#123;</span><br><span class="line">    border-radius:10px;</span><br><span class="line">    -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3);</span><br><span class="line">    background-color:#555;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何对象都可以设置：边框、阴影、背景图片等等，创建的滚动条任然会按照操作系统本身的设置来完成其交互的行为。下面的伪类可以应用到上面的伪元素中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">:horizontal//适用于任何水平方向上的滚动条</span><br><span class="line">:vertical//适用于任何垂直方向的滚动条</span><br><span class="line">:decrement//适用于按钮和轨道碎片。表示递减的按钮或轨道碎片，例如可以使区域向上或者向右移动的区域和按钮</span><br><span class="line">:increment//适用于按钮和轨道碎片。表示递增的按钮或轨道碎片，例如可以使区域向下或者向左移动的区域和按钮</span><br><span class="line">:start//适用于按钮和轨道碎片。表示对象（按钮轨道碎片）是否放在滑块的前面</span><br><span class="line">:end //适用于按钮和轨道碎片。表示对象（按钮轨道碎片）是否放在滑块的后面</span><br><span class="line">:double-button//适用于按钮和轨道碎片。判断轨道结束的位置是否是一对按钮。也就是轨道碎片紧挨着一对在一起的按钮。</span><br><span class="line">:single-button//适用于按钮和轨道碎片。判断轨道结束的位置是否是一个按钮。也就是轨道碎片紧挨着一个单独的按钮。</span><br><span class="line">:no-button//表示轨道结束的位置没有按钮。</span><br><span class="line">:corner-present//表示滚动条的角落是否存在。</span><br><span class="line">:window-inactive//适用于所有滚动条，表示包含滚动条的区域，焦点不在该窗口的时候。</span><br></pre></td></tr></table></figure><p>用法举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-scrollbar-track-piece:start &#123;</span><br><span class="line">   /* Select the top half (or left half) or scrollbar track individually */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-thumb:window-inactive &#123;</span><br><span class="line">   /* Select the thumb when the browser window isn&apos;t in focus */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-button:horizontal:decrement:hover &#123;</span><br><span class="line">   /* Select the down or left scroll button when it&apos;s being hovered by the mouse */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.IE浏览器<br>兼容IE的参考链接：<a href="https://www.cnblogs.com/koleyang/p/5484922.html" target="_blank" rel="noopener">https://www.cnblogs.com/koley…</a></p><h1 id="三-后记"><a href="#三-后记" class="headerlink" title="三 后记"></a>三 后记</h1><p>Chrome能很好的支持自定义滚动条，其它的浏览器在不同程度上支持自定义滚动条样式。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;转载-https-segmentfault-com-a-1190000012800450-utm-source-tag-newest&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="其他" scheme="http://cansolve.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配方案 - REM</title>
    <link href="http://cansolve.cn/2020/01/08/daily21/"/>
    <id>http://cansolve.cn/2020/01/08/daily21/</id>
    <published>2020-01-08T02:03:13.000Z</published>
    <updated>2020-01-10T08:32:01.781Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><p>兼容UC竖屏转横屏，手淘那个lib-flexible.js有bug.可以简单使用这个。</p><p>复制整个文件代码，放在网页的head中。 不需要定义body的font-size值。</p><p>PX与REM的转换(区别于手淘版)</p><p>1rem = 100px</p><p>假如你有一个块是.box{width:120px;height:80px;} 转为rem则为.box{width:1.2rem; height:.8rem;}</p><p>生产使用flexible-min.js</p><p><code>!function(e,t){function n(){var n=l.getBoundingClientRect().width;t=t||540,n&gt;t&amp;&amp;(n=t);var i=100*n/e;r.innerHTML=&quot;html{font-size:&quot;+i+&quot;px;}&quot;}var i,d=document,o=window,l=d.documentElement,r=document.createElement(&quot;style&quot;);if(l.firstElementChild)l.firstElementChild.appendChild(r);else{var a=d.createElement(&quot;div&quot;);a.appendChild(r),d.write(a.innerHTML),a=null}n(),o.addEventListener(&quot;resize&quot;,function(){clearTimeout(i),i=setTimeout(n,300)},!1),o.addEventListener(&quot;pageshow&quot;,function(e){e.persisted&amp;&amp;(clearTimeout(i),i=setTimeout(n,300))},!1),&quot;complete&quot;===d.readyState?d.body.style.fontSize=&quot;16px&quot;:d.addEventListener(&quot;DOMContentLoaded&quot;,function(e){d.body.style.fontSize=&quot;16px&quot;},!1)}(750,750);</code></p><p>正常使用：</p><p>//兼容UC竖屏转横屏出现的BUG</p><p>//自定义设计稿的宽度：designWidth</p><p>//最大宽度:maxWidth</p><p>//这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750)</p><p><strong>使用方法：</strong></p><p>1.复制上面这段代码到你的页面的头部的script标签的最前面。</p><p>2.根据设计稿大小，调整里面的最后两个参数值。</p><p>3.使用1rem=100px转换你的设计稿的像素，例如设计稿上某个块是100px300px,换算成rem则为1rem*3rem。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">;(function(designWidth, maxWidth) &#123;</span><br><span class="line">    var doc = document,</span><br><span class="line">    win = window,</span><br><span class="line">    docEl = doc.documentElement,</span><br><span class="line">    remStyle = document.createElement(&quot;style&quot;),</span><br><span class="line">    tid;</span><br><span class="line">function refreshRem() &#123;</span><br><span class="line">    var width = docEl.getBoundingClientRect().width;</span><br><span class="line">    maxWidth = maxWidth || 540;</span><br><span class="line">    width&gt;maxWidth &amp;&amp; (width=maxWidth);</span><br><span class="line">    var rem = width * 100 / designWidth;</span><br><span class="line">    remStyle.innerHTML = &apos;html&#123;font-size:&apos; + rem + &apos;px;&#125;&apos;;</span><br><span class="line">&#125;</span><br><span class="line">if (docEl.firstElementChild) &#123;</span><br><span class="line">    docEl.firstElementChild.appendChild(remStyle);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    var wrap = doc.createElement(&quot;div&quot;);</span><br><span class="line">    wrap.appendChild(remStyle);</span><br><span class="line">    doc.write(wrap.innerHTML);</span><br><span class="line">    wrap = null;</span><br><span class="line">&#125;</span><br><span class="line">//要等 wiewport 设置好后才能执行 refreshRem，不然 refreshRem 会执行2次；</span><br><span class="line">    refreshRem();</span><br><span class="line">win.addEventListener(&quot;resize&quot;, function() &#123;</span><br><span class="line">    clearTimeout(tid); //防止执行两次</span><br><span class="line">    tid = setTimeout(refreshRem, 300);</span><br><span class="line">    &#125;, false);</span><br><span class="line">    win.addEventListener(&quot;pageshow&quot;, function(e) &#123;</span><br><span class="line">if (e.persisted) &#123; // 浏览器后退的时候重新计算</span><br><span class="line">    clearTimeout(tid);</span><br><span class="line">    tid = setTimeout(refreshRem, 300);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, false);</span><br><span class="line">    if (doc.readyState === &quot;complete&quot;) &#123;</span><br><span class="line">        doc.body.style.fontSize = &quot;16px&quot;;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">        doc.addEventListener(&quot;DOMContentLoaded&quot;, function(e) &#123;</span><br><span class="line">        doc.body.style.fontSize = &quot;16px&quot;;</span><br><span class="line">        &#125;, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(750, 750);</span><br></pre></td></tr></table></figure><p>还有一个只适用于横屏的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(function (doc, win) &#123;</span><br><span class="line">        var docEl = doc.documentElement,</span><br><span class="line">            resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;,</span><br><span class="line">            recalc = function () &#123;</span><br><span class="line">                var clientWidth = docEl.clientWidth;</span><br><span class="line">                var clientHeight = docEl.clientHeight;</span><br><span class="line">                var proportion = clientWidth / clientHeight;</span><br><span class="line">                if (!clientHeight || !clientWidth) return;</span><br><span class="line">                if(proportion &gt; 0.7 &amp;&amp; proportion &lt; 1)&#123;</span><br><span class="line">                    docEl.style.fontSize = 100 * (clientWidth / 1200) + &apos;px&apos;;</span><br><span class="line">                    doc.body.style.visibility = &apos;visible&apos;;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                if(proportion &gt;= 1 &amp;&amp; proportion &lt; 1.5)&#123;</span><br><span class="line">                    docEl.style.fontSize = 100 * (clientWidth / 1400) + &apos;px&apos;;</span><br><span class="line">                    doc.body.style.visibility = &apos;visible&apos;;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                if(clientWidth&gt;clientHeight)&#123;</span><br><span class="line">                    clientHeight &gt;= 800 ? docEl.style.fontSize = &apos;100px&apos; : docEl.style.fontSize = 100 * (clientHeight / 750) + &apos;px&apos;;</span><br><span class="line">                    doc.body.style.visibility = &apos;visible&apos;;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    clientWidth &gt;= 960 ? docEl.style.fontSize = &apos;100px&apos; : docEl.style.fontSize = 100 * (clientWidth / 1200) + &apos;px&apos;;</span><br><span class="line">                    doc.body.style.visibility = &apos;visible&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        if (!doc.addEventListener) return;</span><br><span class="line">        docEl;</span><br><span class="line">        win.addEventListener(resizeEvt, recalc, false);</span><br><span class="line">        doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);</span><br><span class="line">&#125;)(document, window);</span><br></pre></td></tr></table></figure><h3 id="flexible-js"><a href="#flexible-js" class="headerlink" title="flexible.js"></a><a href="http://caibaojian.com/simple-flexible.html" target="_blank" rel="noopener">flexible.js</a></h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;兼容UC竖屏转横屏，手淘那个lib-flexible.js有bug.可以简单使用这个。&lt;/p&gt;&lt;p&gt;复制整个文件代码，放在网页的head中。 不需要定
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="移动端" scheme="http://cansolve.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>聊一下this的指向问题</title>
    <link href="http://cansolve.cn/2019/05/12/daily20/"/>
    <id>http://cansolve.cn/2019/05/12/daily20/</id>
    <published>2019-05-12T02:36:19.000Z</published>
    <updated>2019-06-14T01:43:35.139Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><h2 id="一、this的指向"><a href="#一、this的指向" class="headerlink" title="一、this的指向"></a>一、this的指向</h2><p>在ES5中，强调是在ES5中，this的指向，始终坚持一个原理：<strong>this永远指向最后一个调用它的那个对象</strong>，记住这句肯定不会错。</p><p>首先我们看一个栗子1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">function a() &#123;</span><br><span class="line">    var name = &quot;Cherry&quot;;</span><br><span class="line">    console.log(this.name);          // windowsName</span><br><span class="line">    console.log(&quot;inner:&quot; + this);    // inner: Window</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line">console.log(&quot;outer:&quot; + this)         // outer: Window</span><br></pre></td></tr></table></figure><p>输出windowsName，是因为“<strong>this永远指向最后调用它的那个对象</strong>”，我们看到调用a的地方a()，前面没有调用的对象那么就是全局对象window，就是全局对象调用a()，相当于window.a()。</p><p>如果使用严格模式，全局对象就是undefined，会报错name of undefined</p><p>栗子2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">    name: &quot;Cherry&quot;,</span><br><span class="line">    fn : function () &#123;</span><br><span class="line">        console.log(this.name);      // Cherry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn();</span><br></pre></td></tr></table></figure><p>在这个栗子中，函数fn是对象a调用的，所以console是a中的name</p><p>栗子3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">    var a = &#123;</span><br><span class="line">        name: &quot;Cherry&quot;,</span><br><span class="line">        fn : function () &#123;</span><br><span class="line">            console.log(this.name);      // Cherry</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    window.a.fn();</span><br></pre></td></tr></table></figure><p>这个栗子中，记住“<strong>this永远指向最后一个调用它的那个对象</strong>”，调用fn的对象有window，a，但是最后调用fn是a对象，所以this指向对象a中的name。</p><p>栗子4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">    // name: &quot;Cherry&quot;,</span><br><span class="line">    fn : function () &#123;</span><br><span class="line">        console.log(this.name);      // undefined</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.a.fn();</span><br></pre></td></tr></table></figure><p>为啥undefined，调用fn的对象有：window，a，最后一个调用fn是a，但是a中没有对那么进行定义，也不会继续向上一个对象寻找 this.name，而是直接输出 undefined，所以this.name为undefined。</p><p>栗子5（比较坑）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">    name : null,</span><br><span class="line">    // name: &quot;Cherry&quot;,</span><br><span class="line">    fn : function () &#123;</span><br><span class="line">        console.log(this.name);      // windowsName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f = a.fn;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>这个栗子比较坑，为啥 不是null，因为虽然将a对象的fn方法赋值给变量f，但是没有调用，“<strong>this永远指向最后一个调用ta的那个对象</strong>”，由于刚刚的f没有调用，所以fn()最后仍然是被window调用的，所以this指向的也就是window。</p><p>注意：this的指向并不是在创建的时候可以确定，在ES5中，永远都是this永远指向最后调用它的那个对象。</p><p>栗子6:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    var name = &apos;Cherry&apos;;</span><br><span class="line">    innerFunction();</span><br><span class="line">    function innerFunction() &#123;</span><br><span class="line">        console.log(this.name);      // windowsName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>就是这么简单，<strong>this永远指向最后一个调用它的那个对象</strong></p><h2 id="二、改变this的指向"><a href="#二、改变this的指向" class="headerlink" title="二、改变this的指向"></a>二、改变this的指向</h2><p>改变this的指向，我总结以下的方法：</p><p>（1）使用ES6中箭头函数</p><p>（2）函数内部使用_this = this</p><p>（3）使用apply，call，bind方法</p><p>（4）new实例化一个对象</p><p>举个栗子7：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)     </span><br><span class="line">    &#125;,</span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;,100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2()     // this.func1 is not a function</span><br></pre></td></tr></table></figure><p>在这个栗子中，不使用箭头函数情况下，会报错的，因为最后调用setTimeout的对象时window，但是在window并没有func1函数。</p><p>我们改变this的指向这一节将吧这个栗子作为demo进行改造。</p><h3 id="1、ES6中的箭头函数"><a href="#1、ES6中的箭头函数" class="headerlink" title="1、ES6中的箭头函数"></a>1、ES6中的箭头函数</h3><p>众所周知，ES6的箭头函数是可以避免ES5中this的坑，箭头函数的this始终指向函数定义时候的this，而并不是执行时候。箭头函数需要记住这句话：“箭头函数没有this绑定，必须通过查找作用域来决定其值，如果箭头函数被非箭头函数包含，则this的绑定的是最近一层非箭头函数的this，否则，this为undefined”</p><p>栗子8：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)     </span><br><span class="line">    &#125;,</span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout( () =&gt; &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;,100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2()     // Cherry</span><br></pre></td></tr></table></figure><h3 id="2、在函数内部使用-this-this"><a href="#2、在函数内部使用-this-this" class="headerlink" title="2、在函数内部使用_this = this"></a>2、在函数内部使用_this = this</h3><p>在不使用ES6中，那么这种方式应该是最简单的不会出错的方式，我们先将调用这个函数的对象保存在变量_this中，然后在函数中都使用这个_this，这样_this就不会改变了。</p><p>栗子9：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;windowsName&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line"></span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)     </span><br><span class="line">    &#125;,</span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        var _this = this;</span><br><span class="line">        setTimeout( function() &#123;</span><br><span class="line">            _this.func1()</span><br><span class="line">        &#125;,100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2()       // Cherry</span><br></pre></td></tr></table></figure><p>在func2中，首先设置var _this = this，这里this是调用func2的对象a，为了防止在func2中的setTimeout被window调用而导致的在setTimeout中的this为window。我们将this赋值给一个变量_this，这样在func2中我们使用_this就是指向对象a了。</p><h3 id="3、使用apply、call、bind"><a href="#3、使用apply、call、bind" class="headerlink" title="3、使用apply、call、bind"></a>3、使用apply、call、bind</h3><p>栗子10：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    func1: function () &#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    func2: function () &#123;</span><br><span class="line">        setTimeout(  function () &#123;</span><br><span class="line">            this.func1()</span><br><span class="line">        &#125;.apply(a),100); //这里的apply换成call、bind，结果是一样的</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2()            // Cherry</span><br></pre></td></tr></table></figure><p>在栗子中，apply()方法调用一个函数，其具有一个指定的this值，以及作为一个数组（或者类似数组的对象）提供的参数，fun.apply(thisArg, [argsArray])</p><p>thisArg：在fun函数运行时指定的this值。指定this的值并不一定是函数执行时真正的this值，如果是原始值的this会指向该原始值的自动包装对象。</p><p>argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给fun函数。参数为null或者undefined，则表示不需要传入任何参数。</p><h3 id="这里蛮说一下三者的区别"><a href="#这里蛮说一下三者的区别" class="headerlink" title="这里蛮说一下三者的区别"></a>这里蛮说一下三者的区别</h3><h4 id="1、apply和call的区别"><a href="#1、apply和call的区别" class="headerlink" title="1、apply和call的区别"></a>1、apply和call的区别</h4><p>apply和call基本类似，他们的区别只是传入的参数不同。apply传入的参数是包含多个参数的数组，call传入的参数是若干个参数列表。</p><p>栗子1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a =&#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    fn : function (a,b) &#123;</span><br><span class="line">        console.log( a + b);</span><br><span class="line">        console.log( this.name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var b = a.fn;</span><br><span class="line">b.apply(a,[1,2])     // 3   Cherry</span><br></pre></td></tr></table></figure><p>栗子2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a =&#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    fn : function (a,b) &#123;</span><br><span class="line">        console.log( a + b);</span><br><span class="line">        console.log( this.name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var b = a.fn;</span><br><span class="line">b.call(a,1,2)       // 3   Cherry</span><br></pre></td></tr></table></figure><h4 id="2、bind和apply、call区别"><a href="#2、bind和apply、call区别" class="headerlink" title="2、bind和apply、call区别"></a>2、bind和apply、call区别</h4><p>bind方法会创建一个新的函数，当被调用的时候，将其this关键字设置为提供的值，我们必须手动去调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a =&#123;</span><br><span class="line">    name : &quot;Cherry&quot;,</span><br><span class="line">    fn : function (a,b) &#123;</span><br><span class="line">        console.log( a + b);</span><br><span class="line">        console.log( this.name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var b = a.fn;</span><br><span class="line">b.bind(a,1,2)()   //3   //Cherry</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;一、this的指向&quot;&gt;&lt;a href=&quot;#一、this的指向&quot; class=&quot;headerlink&quot; title=&quot;一、this的指向&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="其他" scheme="http://cansolve.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>常见jquery方法汇总</title>
    <link href="http://cansolve.cn/2019/03/22/daily19/"/>
    <id>http://cansolve.cn/2019/03/22/daily19/</id>
    <published>2019-03-22T02:36:19.000Z</published>
    <updated>2019-03-22T02:06:14.640Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><p>最近前后端分离模式写的也少了，因为公司做的游戏网站都是面向全球的，涉及到ssr，根据业务及人员需求，采用php渲染的方式，于是我这边又回到了一个切图仔的身份，完成布局，写点交互效果就好了，好了不说了，有点惨，这里总结一下常用的jq方法，其实也是为了自己方便查阅，哈哈！！</p><h2 id="jQuery-语法"><a href="#jQuery-语法" class="headerlink" title="jQuery 语法"></a>jQuery 语法</h2><blockquote><p>$(selector).action()</p></blockquote><p>文档加载就绪事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function() &#123;</span><br><span class="line">  // 代码...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 简写方式</span><br><span class="line">$(function() &#123;</span><br><span class="line">  // 代码...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>$(document).ready 与 window.onload 的区别</p><blockquote><p>$(document).ready 和 window.onload 都是在都是在页面加载完执行的函数，大多数情况下差别不大。<br>$(document).ready:是 DOM 结构绘制完毕后就执行，不必等到加载完毕。 意思就是 DOM 树加载完毕，就执行，不必等到页面中图片或其他外部文件都加载完毕。并且可以写多个.ready。<br>window.onload:是页面所有元素都加载完毕，包括图片等所有元素。只能执行一次。</p></blockquote><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>jQuery 选择器基于已经存在的 CSS 选择器</p><blockquote><p>$(‘*’)<br>​$(‘p’)<br>$(‘ul li’)<br>…</p></blockquote><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul><li><p>click() 点击事件</p></li><li><p>dbclick() 双击事件</p></li><li><p>mouseenter() 鼠标穿过元素事件</p></li><li><p>mouseleave() 鼠标离开元素事件</p></li><li><p>mousedown() 鼠标移动到元素上方按下鼠标事件</p></li><li><p>mouseup() 鼠标按住移动到元素上方松开鼠标事件</p></li><li><p>hover() 鼠标悬停事件</p></li><li><p>focus() 表单元素聚焦事件</p></li><li><p>blur() 表单元素失去焦点事件</p></li><li><p>submit() 表单提交事件</p></li><li><p>change() 表单元素值改变事件</p></li><li><p>keypress() 键盘键按住事件</p></li><li><p>keydown() 键盘键按下事件</p></li><li><p>keyup() 键盘键松开事件</p></li><li><p>load() 指定元素加载完成式执行事件 （1.8 版本后废弃）</p></li><li><p>resize() 窗口大小改变事件</p></li><li><p>scroll() 滚动监听事件</p></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><blockquote><p>$(selector).action(speed,callback)</p></blockquote><h3 id="显示隐藏"><a href="#显示隐藏" class="headerlink" title="显示隐藏"></a>显示隐藏</h3><ul><li><p>hide() 隐藏元素</p></li><li><p>show() 显示元素</p></li><li><p>toggle() 显示被隐藏的元素，隐藏已显示的元素</p></li></ul><h3 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h3><ul><li><p>fadeIn() 淡入</p></li><li><p>fadeOut() 淡出</p></li><li><p>fadeToggle() 已淡出的元素淡入，已淡入的元素淡出</p></li><li><p>fadeTo() 渐变为给定不透明度</p><blockquote><p>$(selector).fadeTo(speed,opacity,callback);</p><p>opacity 值为 0 与 1 之间</p></blockquote></li></ul><h3 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h3><ul><li><p>slideDown() 向下滑动展开元素</p></li><li><p>slideDown() 向上滑动收起元素</p></li><li><p>slideToggle() 已展开元素上滑收起，已收起元素下滑展示</p></li></ul><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><blockquote><p>$(selector).animate({params},speed,callback);</p></blockquote><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function() &#123;</span><br><span class="line">  $(&quot;div&quot;).animate(&#123;</span><br><span class="line">    left: &quot;250px&quot;,</span><br><span class="line">    opacity: &quot;0.5&quot;,</span><br><span class="line">    height: &quot;150px&quot;,</span><br><span class="line">    width: &quot;150px&quot;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="停止动画"><a href="#停止动画" class="headerlink" title="停止动画"></a>停止动画</h3><blockquote><p>$(selector).stop(stopAll, goToEnd);</p></blockquote><h2 id="jQuery-链-Chaining"><a href="#jQuery-链-Chaining" class="headerlink" title="jQuery 链(Chaining)"></a>jQuery 链(Chaining)</h2><p>jQuery支持在一条语句中运行多个 jQuery 方法（在相同的元素上，浏览器就不必多次查找相同的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#p1&quot;)</span><br><span class="line">  .css(&quot;color&quot;, &quot;red&quot;)</span><br><span class="line">  .slideUp(2000)</span><br><span class="line">  .slideDown(2000);</span><br><span class="line"></span><br><span class="line">// &quot;p1&quot; 元素首先会变为红色，然后向上滑动，再然后向下滑动</span><br></pre></td></tr></table></figure><h3 id="获取内容"><a href="#获取内容" class="headerlink" title="获取内容"></a>获取内容</h3><ul><li><p>text() 设置或返回所选元素的文本内容</p></li><li><p>html() 设置或返回所选元素的内容（包括 HTML 标记）</p></li><li><p>val() 设置或返回表单字段的值</p></li></ul><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><ul><li>attr() 设置或者返回所选的属性的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 获取属性</span><br><span class="line">$(&apos;#test&apos;).attr(&apos;href&apos;）</span><br><span class="line"></span><br><span class="line">// 设置属性</span><br><span class="line">$(&apos;#test&apos;).attr(&apos;href&apos;,&apos;http://www.baidu.com&apos;)</span><br><span class="line"></span><br><span class="line">$(&apos;#test&apos;).attr(&#123;</span><br><span class="line">    href: &apos;http://www.baidu.com&apos;,</span><br><span class="line">    title: &apos;百度&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 回掉函数</span><br><span class="line">$(&apos;#test&apos;).attr(&apos;href&apos;, function(i, origValue)&#123;</span><br><span class="line">    // i 被选元素列表中当前元素的下标</span><br><span class="line">    // origValue 原始值</span><br><span class="line">    return origValue + &apos;/jquery&apos;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="添加删除元素"><a href="#添加删除元素" class="headerlink" title="添加删除元素"></a>添加删除元素</h3><ul><li><p>append() 在被选元素的结尾插入内容</p></li><li><p>prepend() 在被选元素的开头插入内容</p></li><li><p>after() 在被选元素之后插入内容</p></li><li><p>before() 在被选元素之前插入内容</p></li><li><p>remove() 删除被选元素（及其子元素）</p></li><li><p>empty() 从被选元素中删除子元素</p></li></ul><blockquote><p>$(‘p’).remove(‘.italic’)</p></blockquote><h3 id="获取并设置-css-类"><a href="#获取并设置-css-类" class="headerlink" title="获取并设置 css 类"></a>获取并设置 css 类</h3><ul><li><p>addClass() 向被选元素添加一个或多个类</p></li><li><p>removeClass() 从被选元素删除一个或多个类</p></li><li><p>toggleClass() 对被选元素进行添加/删除类的切换操作</p></li><li><p>css() 设置或返回样式属性</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 返回样式属性</span><br><span class="line">$(&quot;p&quot;).css(&quot;background-color&quot;);</span><br><span class="line"></span><br><span class="line">// 设置样式属性</span><br><span class="line">$(&quot;p&quot;).css(&quot;background-color&quot;, &quot;yellow&quot;);</span><br><span class="line">// 或者</span><br><span class="line">$(&quot;p&quot;).css(&#123; &quot;background-color&quot;: &quot;yellow&quot;, &quot;font-size&quot;: &quot;200%&quot; &#125;);</span><br></pre></td></tr></table></figure><h3 id="尺寸方法"><a href="#尺寸方法" class="headerlink" title="尺寸方法"></a>尺寸方法</h3><ul><li><p>width() 元素宽度</p></li><li><p>height() 元素高度</p></li><li><p>innerWidth() 包含 padding 宽度</p></li><li><p>innerHeight() 包含 padding 高度</p></li><li><p>outerWidth() 包含 padding、border 宽度</p></li><li><p>outerHeight() 包含 padding、border 高度</p></li><li><p>outerWidth(true) 包含 padding、border、margin 宽度</p></li><li><p>outerHeight(true) 包含 padding、border、margin 高度</p></li></ul><h3 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h3><p>祖先元素：</p><ul><li><p>parent() 返回被选元素的直接父元素，该方法只会向上一级对 DOM 树进行遍历。</p></li><li><p>parents() 返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (</p><html>)。</html><p></p></li><li><p>parentsUntil() parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function() &#123;</span><br><span class="line">  // div &gt; ul &gt; li &gt; span</span><br><span class="line">  $(&quot;span&quot;).parentsUntil(&quot;div&quot;);</span><br><span class="line">  // 返回 ul 和 li</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后代元素：</p><ul><li><p>children() 返回被选元素的所有直接子元素。</p></li><li><p>find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function() &#123;</span><br><span class="line">  $(&quot;div&quot;).find(&quot;span&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同胞元素：</p><ul><li><p>siblings() 返回被选元素的所有同胞元素。</p></li><li><p>next() 返回被选元素的下一个同胞元素。</p></li><li><p>nextAll() 返回被选元素的所有跟随的同胞元素。</p></li><li><p>nextUntil() 返回介于两个给定参数之间的所有跟随的同胞元素。</p></li><li><p>prev() 返回被选元素的上一个同胞元素。</p></li><li><p>prevAll() 返回被选元素之前的所有的同胞元素。</p></li><li><p>prevUntil() 返回介于两个给定参数之间的所有前方的同胞元素。</p></li></ul><p>元素过滤：</p><ul><li><p>first() 返回被选元素的首个元素。</p></li><li><p>last() 返回被选元素的最后一个元素。</p></li><li><p>eq() 返回被选元素中带有指定索引号的元素。</p></li><li><p>filter() 方法允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。</p></li><li><p>not() 方法返回不匹配标准的所有元素。</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;最近前后端分离模式写的也少了，因为公司做的游戏网站都是面向全球的，涉及到ssr，根据业务及人员需求，采用php渲染的方式，于是我这边又回到了一个切图仔
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="其他" scheme="http://cansolve.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>移动端常见问题集锦</title>
    <link href="http://cansolve.cn/2019/03/15/daily18/"/>
    <id>http://cansolve.cn/2019/03/15/daily18/</id>
    <published>2019-03-15T05:36:19.000Z</published>
    <updated>2019-03-19T01:03:54.504Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><p>好像有好久没有写总结了，刚好最近在做移动端的h5比较多，于是就收集了一下坑，并记录了下来给大家参考一下，希望对大家有所帮助，如果没有的话或者哪里写错的，希望各位大佬提出意见，小弟立马查阅并修正。</p><p>移动端的坑真的是非常的多，毕竟机型太多了，这已经是我整理的第三篇关于移动端问题了，踩坑路漫漫，话不多说，开始</p><h2 id="移动端ios下-‘body’-点击无效的解决方法"><a href="#移动端ios下-‘body’-点击无效的解决方法" class="headerlink" title="移动端ios下$(‘body’)点击无效的解决方法"></a>移动端ios下$(‘body’)点击无效的解决方法</h2><p>今天遇到一个坑，嵌入到游戏中的h5页面出现按钮点击失效问题</p><p>正常是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;body&apos;).click(function(e) &#123;</span><br><span class="line">   var target = $(e.target);</span><br><span class="line">   if (!target.is(&apos;#more&apos;) &amp;&amp; !target.is(&apos;.btns *&apos;)) &#123;</span><br><span class="line">       $(&apos;.btns&apos;).removeClass(&apos;open&apos;);</span><br><span class="line">   $(&apos;#more&apos;).show();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是你会发现正常的pc和安卓显示中可以实现，但是在ios真机中显示有问题，因为IOS浏览器的window、document、body并不接受click事件，按钮和链接才接受click事件;</p><p>度娘了一下有人说给body加cursor：pointer;然并卵;</p><p>后面实践发现下面的写法会解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;body&gt;*&apos;).bind(&apos;click&apos;, function(e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;btn&apos;).bind(&apos;click&apos;,function(e)&#123; //点击按钮显示</span><br><span class="line">    $(&apos;#more&apos;).show();</span><br><span class="line">    $(&apos;body&apos;).one(&apos;click&apos;,function()&#123; //这里给body执行一次点击后删除事件</span><br><span class="line">        $(&apos;#more&apos;).hide();</span><br><span class="line">    &#125;)</span><br><span class="line">    e.stopPropagation(); //这里阻止一下冒泡，因为按钮也在body里面，不让body检测到点击按钮</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样应该挺好懂吧，可以试试</p><h2 id="解决：初步解决方案是给body或者html添加overflow：hidden样式，当然height要设置成100"><a href="#解决：初步解决方案是给body或者html添加overflow：hidden样式，当然height要设置成100" class="headerlink" title="解决：初步解决方案是给body或者html添加overflow：hidden样式，当然height要设置成100%"></a>解决：初步解决方案是给body或者html添加<code>overflow：hidden</code>样式，当然height要设置成100%</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#showProup&quot;).click(function() &#123;</span><br><span class="line">      $(&quot;#mask&quot;).show(0,function()&#123;</span><br><span class="line">           $(&quot;body&quot;).css(&apos;overflow&apos;,&apos;hidden&apos;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  $(&quot;#close&quot;).click(function() &#123;</span><br><span class="line">      $(&quot;#mask&quot;).hide(0,function()&#123;</span><br><span class="line">          $(&quot;body&quot;).css(&apos;overflow&apos;,&apos;scroll&apos;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动端问题比较明显，所以可以<code>touchmove</code>代替</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).on(&quot;touchmove&quot;,function(e) &#123;</span><br><span class="line">  e.preventDefault(); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种方法在移动端是可以解决滑动的问题，但有种情景就显得有点尴尬了，移动端屏幕本来就小，如果弹窗的内容过多也需要滑动（比如很长的活动规则），因为弹窗出现的时候已经禁止了滑动事件，此时禁止滑动之前先做一下判断—</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(document).on(&quot;touchmove&quot;,function(e) &#123;</span><br><span class="line">   if(e.target.className.indexOf(&quot;shadeBox&quot;) &gt;= 0) &#123;</span><br><span class="line">        e.preventDefault();      </span><br><span class="line">    &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上为想到的初步方案，如有更好可替换</p><p>解决：用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a,button,input,textarea&#123;</span><br><span class="line">  -webkit-tap-highlight-color: rgba(0,0,0,0;)</span><br><span class="line">  -webkit-user-modify:read-write-plaintext-only;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：移动端视频播放（安卓）总在最高层，会挡住遮罩层"><a href="#问题：移动端视频播放（安卓）总在最高层，会挡住遮罩层" class="headerlink" title="问题：移动端视频播放（安卓）总在最高层，会挡住遮罩层"></a>问题：移动端视频播放（安卓）总在最高层，会挡住遮罩层</h2><p>解决：（初步）点开遮罩的同时隐藏video标签，关闭遮罩时在显示，达到视觉上遮挡</p><h2 id="问题：移动端点击出现300ms延迟"><a href="#问题：移动端点击出现300ms延迟" class="headerlink" title="问题：移动端点击出现300ms延迟"></a>问题：移动端点击出现300ms延迟</h2><p>解决：页面引用fastclick.js来避免</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FastClick.attach(document.body);</span><br></pre></td></tr></table></figure><h2 id="问题：Android-上圆形图片使用-border-时，边框显示变形"><a href="#问题：Android-上圆形图片使用-border-时，边框显示变形" class="headerlink" title="问题：Android 上圆形图片使用 border 时，边框显示变形"></a>问题：Android 上圆形图片使用 border 时，边框显示变形</h2><p><img src="/2019/03/15/daily18/radius.png" alt="圆形图片边框变形"></p><p>解决：给 img 外嵌套一个元素，为其使用圆角</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line"> &lt;img src=&quot;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  border: 4px solid #FF7000;</span><br><span class="line">&#125;</span><br><span class="line">img&#123;</span><br><span class="line">  vertical-align: top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：Android-上圆角元素，背景颜色会溢出"><a href="#问题：Android-上圆角元素，背景颜色会溢出" class="headerlink" title="问题：Android 上圆角元素，背景颜色会溢出"></a>问题：Android 上圆角元素，背景颜色会溢出</h2><p><img src="/2019/03/15/daily18/border-radius.png" alt="背景色溢出"></p><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  background-clip: padding-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：-Android-上圆角使用-Animation-做-loading-动画时，圆角背景色溢出的bug"><a href="#问题：-Android-上圆角使用-Animation-做-loading-动画时，圆角背景色溢出的bug" class="headerlink" title="问题： Android 上圆角使用 Animation 做 loading 动画时，圆角背景色溢出的bug"></a>问题： Android 上圆角使用 Animation 做 loading 动画时，圆角背景色溢出的bug</h2><p><img src="/2019/03/15/daily18/radius-animation-1.gif" alt="圆角溢出"><img src="/2019/03/15/daily18/radius-animation-1.gif" alt="圆角溢出"></p><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  background-color: #F9CEAC;</span><br><span class="line">  border-radius: 32px 0 0 32px;</span><br><span class="line">  -webkit-mask-image: url(http://i.gtimg.cn/qqlive/images/20150527/btn_mask.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理是使用一个圆角的蒙板通过<code>-webkit-mask-image</code>遮住多余的部分。蒙板：<img src="http://i.gtimg.cn/qqlive/images/20150527/btn_mask.png" alt="圆角蒙板"></p><h2 id="问题：CSS-三角在-Android-上显示为方块"><a href="#问题：CSS-三角在-Android-上显示为方块" class="headerlink" title="问题：CSS 三角在 Android 上显示为方块"></a>问题：CSS 三角在 Android 上显示为方块</h2><p>解决：可能是对这个三角使用了圆角，去掉<code>border-radius</code>即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  border: 10px solid transparent;</span><br><span class="line">  border-left-color: #000;</span><br><span class="line">  /*border-radius: 2px;*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：-Android-上使用-svg-作为-background-image-时显示模糊"><a href="#问题：-Android-上使用-svg-作为-background-image-时显示模糊" class="headerlink" title="问题： Android 上使用 svg 作为 background-image 时显示模糊"></a>问题： Android 上使用 svg 作为 background-image 时显示模糊</h2><p>解决：设置<code>background-size</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  -webkit-background-size: 100%;</span><br><span class="line">  background-size: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：-active-样式不生效"><a href="#问题：-active-样式不生效" class="headerlink" title="问题： :active 样式不生效"></a>问题： :active 样式不生效</h2><p><img src="/2019/03/15/daily18/active.gif" alt="元素 active 样式"></p><p>解决：如果给按钮定义 :hover 样式，在 iPhone 上按钮点击一次是 hover 态，再点击一次 hover 态才会消失，这显然不是我们想要的，继而想通过定义 :active 样式来实现按钮按下时的效果，但发现定义的 active 样式在 iPhone 上点击时没有任何效果。 搜索后发现，只需添加一段 js 即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&quot;touchstart&quot;, function() &#123;&#125;,false);</span><br></pre></td></tr></table></figure><p>另一个方案，可以在 body 上添加<code>ontouchstart=&quot;&quot;</code></p><p>原因：Safari 默认禁用了元素的<code>active</code>样式，我们通过声明<code>touchstart</code>来覆盖默认事件，就可以让<code>active</code>样式重新激活。</p><h2 id="问题：-移动端多行文字超出截断需要出现省略号"><a href="#问题：-移动端多行文字超出截断需要出现省略号" class="headerlink" title="问题： 移动端多行文字超出截断需要出现省略号"></a>问题： 移动端多行文字超出截断需要出现省略号</h2><p><img src="/2019/03/15/daily18/ellipsis.png" alt="多行文本的超出隐藏省略号"></p><p>解决：单行文本截断并末尾出现省略号一般写法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">white-space: nowrap;</span><br><span class="line">overflow: hidden;</span><br><span class="line">text-overflow: ellipsis;</span><br></pre></td></tr></table></figure><p>webkit 私有属性在移动端的兼容性不错， iOS 与 Android 均有不错的支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">display: -webkit-box;</span><br><span class="line">overflow: hidden;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">-webkit-line-clamp: 2;</span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure><p>其中的<code>-webkit-line-clamp: 2</code>即用来控制文本超出两行时截断并出现省略号。 在使用中如果出现第三行文字露一点头出来的问题，设置合理的<code>line-height</code>即可解决。</p><p>多行省略号用在 a 链接中时会有一个bug，省略号出现在文字中间：</p><p><img src="http://note.rpsh.net/assets/2014/10/ellipsis_in_link.jpeg" alt="链接中多行省略号bug"></p><p>这个问题的解决方案是，不要将多行省略的属性写在 a 上（或其父标签）。而在 a 内再嵌套一个标签，对其使用多行省略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面对这些问题面对这些，问题面对这些问题面对这些问题面</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a div&#123;</span><br><span class="line">  display: -webkit-box;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  -webkit-line-clamp: 2;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：-1px-线条、边框"><a href="#问题：-1px-线条、边框" class="headerlink" title="问题： 1px 线条、边框"></a>问题： 1px 线条、边框</h2><p><img src="/2019/03/15/daily18/1px_line.png" alt="1像素边框"></p><p>解决：使用高度为 1px ，一半为实色，一半为透明的渐变背景实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  background: -webkit-linear-gradient(top, transparent, transparent 50%, #CACDD0 50%) 0 top no-repeat;</span><br><span class="line">  background-size: 100% 1px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要有四个边框都有 1px 的线框，可以使用多背景图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  background: </span><br><span class="line">  -webkit-linear-gradient(top, #CACDD0, #CACDD0 50%, transparent 50%, transparent 100%) 0 top no-repeat,</span><br><span class="line">  -webkit-linear-gradient(top, transparent, transparent 50%, #CACDD0 50%, #CACDD0 100%) 0 bottom no-repeat, </span><br><span class="line">  -webkit-linear-gradient(left, #CACDD0, #CACDD0 50%, transparent 50%, transparent 100%) left 0 no-repeat, </span><br><span class="line">  -webkit-linear-gradient(left, transparent, transparent 50%, #CACDD0 50%, #CACDD0 100%) right 0 no-repeat;</span><br><span class="line">  background-size: 100% 1px,100% 1px, 1px 100%, 1px 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：滚动条滚动时没有像-iOS-原生那么顺滑流畅，滚动条没有-iOS-回弹效果"><a href="#问题：滚动条滚动时没有像-iOS-原生那么顺滑流畅，滚动条没有-iOS-回弹效果" class="headerlink" title="问题：滚动条滚动时没有像 iOS 原生那么顺滑流畅，滚动条没有 iOS 回弹效果"></a>问题：滚动条滚动时没有像 iOS 原生那么顺滑流畅，滚动条没有 iOS 回弹效果</h2><p><img src="/2019/03/15/daily18/scroll-1.gif" alt="iOS 滚动条"></p><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  overflow: auto;</span><br><span class="line">  -webkit-overflow-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在 Android 上由于原生滚动没有回弹效果，所以这里也不会有回弹的效果。</p><h2 id="问题：当模块使用系统的横向滚动时，不想显示出系统的滚动条样式"><a href="#问题：当模块使用系统的横向滚动时，不想显示出系统的滚动条样式" class="headerlink" title="问题：当模块使用系统的横向滚动时，不想显示出系统的滚动条样式"></a>问题：当模块使用系统的横向滚动时，不想显示出系统的滚动条样式</h2><p><img src="/2019/03/15/daily18/scroll-2.gif" alt="隐藏滚动条"></p><p>解决：</p><p>Android：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-scrollbar&#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iOS 要隐藏滚动条，会稍微复杂一些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">  height: 100px;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.box&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: -webkit-calc(100% + 5px);</span><br><span class="line">  overflow-x: auto;</span><br><span class="line">  overflow-y: hidden;</span><br><span class="line">  -webkit-overflow-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：<code>.box</code>元素的横向滚动条通过其外层元素<code>.wrap</code>的<code>overflow:hide</code>来隐藏。 （5px 是 iOS 上滚动条元素的高度）</p><h2 id="问题：横向滚动的元素，滑动时有时图片显示不出来-文字显示不出来"><a href="#问题：横向滚动的元素，滑动时有时图片显示不出来-文字显示不出来" class="headerlink" title="问题：横向滚动的元素，滑动时有时图片显示不出来/文字显示不出来"></a>问题：横向滚动的元素，滑动时有时图片显示不出来/文字显示不出来</h2><p><img src="/2019/03/15/daily18/scroll-3.gif" alt="滑动时元素不显示"></p><p>解决：给每个横滑的元素块使用硬件加速</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li&#123;</span><br><span class="line">  -webkit-transform: translateZ(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：使用-animation-动画后，页面上-overflow-auto-的元素滚动条不能滑动"><a href="#问题：使用-animation-动画后，页面上-overflow-auto-的元素滚动条不能滑动" class="headerlink" title="问题：使用 animation 动画后，页面上 overflow:auto 的元素滚动条不能滑动"></a>问题：使用 animation 动画后，页面上 overflow:auto 的元素滚动条不能滑动</h2><p>解决：不使用 translate 方式的动画，换为使用 left/top 来实现元素移动的动画</p><h2 id="问题：-上下滑动页面时候，页面元素消失"><a href="#问题：-上下滑动页面时候，页面元素消失" class="headerlink" title="问题： 上下滑动页面时候，页面元素消失"></a>问题： 上下滑动页面时候，页面元素消失</h2><p>解决：检查是否使用了 fadeIn 的 animation，如有则 fill-mode 使用 backwards 模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  -webkit-animation: fadeIn 0.5s ease backwards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：页面上数字自动变成了可以点击的链接"><a href="#问题：页面上数字自动变成了可以点击的链接" class="headerlink" title="问题：页面上数字自动变成了可以点击的链接"></a>问题：页面上数字自动变成了可以点击的链接</h2><p><img src="/2019/03/15/daily18/input_tel.gif" alt="数字变为链接"></p><p>解决：在页面<code>&lt;head&gt;</code>里添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="问题：input-在-iOS-中圆角、内阴影去不掉"><a href="#问题：input-在-iOS-中圆角、内阴影去不掉" class="headerlink" title="问题：input 在 iOS 中圆角、内阴影去不掉"></a>问题：input 在 iOS 中圆角、内阴影去不掉</h2><p><img src="/2019/03/15/daily18/input.png" alt="去掉 input 的圆角与阴影"><br>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">  -webkit-appearance: none;</span><br><span class="line">  border-radius: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：焦点在-input-时，placeholder-没有隐藏"><a href="#问题：焦点在-input-时，placeholder-没有隐藏" class="headerlink" title="问题：焦点在 input 时，placeholder 没有隐藏"></a>问题：焦点在 input 时，placeholder 没有隐藏</h2><p><img src="/2019/03/15/daily18/placholder.gif" alt="focus 时隐藏 placholder"></p><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input:focus::-webkit-input-placeholder&#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：-input-输入框调出数字输入键盘"><a href="#问题：-input-输入框调出数字输入键盘" class="headerlink" title="问题： input 输入框调出数字输入键盘"></a>问题： input 输入框调出数字输入键盘</h2><p>解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;number&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;number&quot; pattern=&quot;[0-9]*&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;tel&quot; /&gt;</span><br></pre></td></tr></table></figure><p>分别对应下图中的1、2、3。</p><p><img src="/2019/03/15/daily18/keyboard_number.png" alt="圆形图片边框变形"></p><p>需要注意的是，单独使用<code>type=&quot;number&quot;</code>时候， iOS 上出现并不是九宫格的数字键盘，如果需要九宫格的数字键盘，可选择使用 2、3 的方法。 1、2、3 在 Android 上均可以唤起九宫格的数字键盘</p><h2 id="问题：搜索时，键盘的回车按钮文字设定为“搜索”"><a href="#问题：搜索时，键盘的回车按钮文字设定为“搜索”" class="headerlink" title="问题：搜索时，键盘的回车按钮文字设定为“搜索”"></a>问题：搜索时，键盘的回车按钮文字设定为“搜索”</h2><p><img src="/2019/03/15/daily18/form_search.png" alt="定义键盘回车文案为搜索"></p><p>解决：<code>input</code>使用<code>type=&quot;search&quot;</code>，放在<code>form</code>表单内。两者结合就能使输入法中的回车按钮文字变为“搜索”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;&quot;&gt;</span><br><span class="line"> &lt;input type=&quot;search&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h2 id="问题：iframe-在-iOS-上没有滚动条，直接撑出去"><a href="#问题：iframe-在-iOS-上没有滚动条，直接撑出去" class="headerlink" title="问题：iframe 在 iOS 上没有滚动条，直接撑出去"></a>问题：iframe 在 iOS 上没有滚动条，直接撑出去</h2><p><img src="/2019/03/15/daily18/iframe.png" alt="iframe 撑出界面"></p><p>解决：给 iframe 外嵌套一个 div， 为这个 div 设置固定高度与<code>overflow</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  height: 100px;</span><br><span class="line">  overflow: auto;</span><br><span class="line">  -webkit-overflow-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;好像有好久没有写总结了，刚好最近在做移动端的h5比较多，于是就收集了一下坑，并记录了下来给大家参考一下，希望对大家有所帮助，如果没有的话或者哪里写错的
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="移动端" scheme="http://cansolve.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>聊聊你可能并没有完全掌握的 (font-family)和粗细(font-weight)问题</title>
    <link href="http://cansolve.cn/2019/01/25/daily17/"/>
    <id>http://cansolve.cn/2019/01/25/daily17/</id>
    <published>2019-01-25T08:31:31.000Z</published>
    <updated>2019-02-27T06:32:10.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><p>谈到“CSS中的字体”，老生常谈的话题了，在平时工作中，完成一个项目，从设计稿到页面最终的输出效果，就字体方面来说，细心的童鞋会发现有很多方面细活要去做的，当然了，这是建立在项目本身要求非常高的情况下。今天下午从两方面来讨论：设置(font-family)和粗细(font-weight)。</p><h3 id="字体设置-font-family"><a href="#字体设置-font-family" class="headerlink" title="字体设置(font-family)"></a>字体设置(font-family)</h3><p>在写全局样式时，我们都会去设置一个默认的字体，举个例子：</p><ol><li>font-family:’PingFang SC’,’Microsoft YaHei’,’SimSun’,’Arial’, sans-serif</li></ol><p>上面的设置，会按照设置的顺序首选字体是平方字体，如没平方字体，就是显示微软雅黑，依次类推…</p><p>在设置一些中文字体的时候，不建议直接使用中文，还是回归到统一的英文，在这里分享一些常用中文转英文的字体：</p><p>华文细黑：STHeiti Light [STXihei]<br>华文黑体：STHeiti<br>华文楷体：STKaiti<br>华文宋体：STSong<br>华文仿宋：STFangsong<br>儷黑 Pro：LiHei Pro Medium<br>儷宋 Pro：LiSong Pro Light<br>標楷體：BiauKai<br>苹果丽中黑：Apple LiGothic Medium<br>苹果丽細宋：Apple LiSung Light<br>Windows的一些：<br>新細明體：PMingLiU<br>細明體：MingLiU<br>標楷體：DFKai-SB<br>黑体：SimHei<br>宋体：SimSun<br>新宋体：NSimSun<br>仿宋：FangSong<br>楷体：KaiTi<br>仿宋_GB2312：FangSong_GB2312<br>楷体_GB2312：KaiTi_GB2312<br>微軟正黑體：Microsoft JhengHei<br>微软雅黑体：Microsoft YaHei</p><p>装Office会生出来的一些：<br>隶书：LiSu<br>幼圆：YouYuan<br>华文细黑：STXihei<br>华文楷体：STKaiti<br>华文宋体：STSong<br>华文中宋：STZhongsong<br>华文仿宋：STFangsong<br>方正舒体：FZShuTi<br>方正姚体：FZYaoti<br>华文彩云：STCaiyun<br>华文琥珀：STHupo<br>华文隶书：STLiti<br>华文行楷：STXingkai<br>华文新魏：STXinwei</p><p>–可以收藏一波–</p><p>由于移动端设备过多，默认字体也会很多，首先得去了解他们的默认有哪些：</p><h4 id="ios-系统"><a href="#ios-系统" class="headerlink" title="ios 系统"></a>ios 系统</h4><p>默认中文字体是Heiti SC</p><p>默认英文字体是Helvetica</p><p>默认数字字体是HelveticaNeue</p><p>无微软雅黑字体</p><h4 id="android-系统"><a href="#android-系统" class="headerlink" title="android 系统"></a>android 系统</h4><p>默认中文字体是Droidsansfallback</p><p>默认英文和数字字体是Droid Sans</p><p>无微软雅黑字体</p><h4 id="winphone-系统"><a href="#winphone-系统" class="headerlink" title="winphone 系统"></a>winphone 系统</h4><p>默认中文字体是Dengxian(方正等线体)</p><p>默认英文和数字字体是Segoe</p><p>无微软雅黑字体</p><p>这时候你会发现无论是ios、android还是wp系统中都是没有<code>微软雅黑</code>字体的，而且你要是做一个测试你会发现，无论页面中使用哪种字体，肉眼很难看出它们的差异，对产品的体验几乎没有影响。</p><h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><p>各个手机系统有自己的默认字体，且都不支持微软雅黑。</p><p><strong>如无特殊需求，手机端无需定义中文字体，使用系统默认</strong>。</p><p>英文字体和数字字体可使用 Helvetica ，三种系统都支持。</p><p>OK，证据确凿。如果设计师需要用到一些特殊的英文字体，比如漂亮的din1451a，akzidenzgrotesk-cond等，我们需要转换下，然后用@font-face引用下即可，这个方法不多说。</p><h3 id="字体粗细-font-weight"><a href="#字体粗细-font-weight" class="headerlink" title="字体粗细(font-weight)"></a>字体粗细(font-weight)</h3><p>首先我们了解下font-weight的基本属性值，如下表格：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>默认值。定义标准的字符。</td></tr><tr><td>bold</td><td>定义粗体字符。</td></tr><tr><td>bolder</td><td>定义更粗的字符。</td></tr><tr><td>lighter</td><td>定义更细的字符。</td></tr></tbody></table><ul><li><p>100</p></li><li><p>200</p></li><li><p>300</p></li><li><p>400</p></li><li><p>500</p></li><li><p>600</p></li><li><p>700</p></li><li><p>800</p></li><li><p>900</p><p>| 定义由粗到细的字符。400 等同于 normal，而 700 等同于 bold。 |</p><p>| inherit | 规定应该从父元素继承字体的粗细。 |</p></li></ul><p><strong>切记：</strong></p><p><strong>400等同于normal，而700等同于bold。</strong><br><strong>inherit规定应该从父元素继承字体的粗细。</strong><br>不过感觉效果不明显。只能换个字体试试。不过比较常见的中文字体里，感觉黑体比较粗些吧。我们看个简单的例子，WINDOWS系统PC端效果：</p><p><img src="/2019/01/25/daily17/201804081523175175762773.png" alt="图片.png"></p><p>对应的CSS字体设置：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.p1&#123;font:30px Pingfang SC&#125;  </span><br><span class="line">.p2&#123;font:300 30px Pingfang SC&#125;  </span><br><span class="line">.p3&#123;font:bold 30pxPingfang SC&#125;   </span><br><span class="line">.p4&#123;font:900 30px Pingfang SC&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">        &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .p1&#123;font:30px Pingfang SC&#125;</span><br><span class="line">            .p2&#123;font:300 30px Pingfang SC&#125;</span><br><span class="line">            .p3&#123;font:bold 30px Pingfang SC&#125;</span><br><span class="line">            .p4&#123;font:900 30px Pingfang SC&#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p class=&quot;p1&quot;&gt;Web前端之家&lt;/p&gt;</span><br><span class="line">        &lt;p class=&quot;p2&quot;&gt;Web前端之家&lt;/p&gt;</span><br><span class="line">        &lt;p class=&quot;p3&quot;&gt;Web前端之家&lt;/p&gt;</span><br><span class="line">        &lt;p class=&quot;p4&quot;&gt;Web前端之家&lt;/p&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>可以根据值的设置，你会发现pc上基本就是那几个明显的变化，我要说的重点是在移动端。</p><p>如果你对安卓和IOS前期的版本有了解的话，发现它们对于字体加粗属性很乱，支持性不太好，无论你怎么设置都无效，说白了就是系统BUG，^_^。</p><p>现在安卓和IOS的新版改善了好多，下面截图是安卓7.11和IOS11.2效果：</p><p><img src="/2019/01/25/daily17/201804081523177299207133.png" alt="未标题-1.png" title="未标题-1.png"></p><p>从上图发现，安卓的字体效果要比IOS要粗（请忽视字体大小），这个跟系统默认的字体有直接关系，可能也有其他的原因（请大神赐教）。这里要提醒下：有时候我们设置了加粗的样式，但是实际并没有加粗的效果，为什么呢？</p><p>很有可能就是font-weight的基础属性值设置问题，400 700这些坎，上面有提到。</p><h3 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h3><p>CSS字体设置(font-family)和粗细(font-weight)在不同设备和系统下的差别，工作中经常会碰到用一个特殊字符：五角星，箭头，圆点，箭头等等，用字体直接去设置效果，最终出来的效果出来不尽人意，这里建议就是用CSS3、图和base64等。</p><p>OK，大概就这么多，有啥不对的欢迎来喷。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;谈到“CSS中的字体”，老生常谈的话题了，在平时工作中，完成一个项目，从设计稿到页面最终的输出效果，就字体方面来说，细心的童鞋会发现有很多方面细活要去
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="其他" scheme="http://cansolve.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>日常问题解决（持续更新中）</title>
    <link href="http://cansolve.cn/2019/01/02/daily16/"/>
    <id>http://cansolve.cn/2019/01/02/daily16/</id>
    <published>2019-01-02T13:06:28.000Z</published>
    <updated>2019-04-23T06:28:22.229Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><h3 id="解决使用-swiper-常见的问题"><a href="#解决使用-swiper-常见的问题" class="headerlink" title="解决使用 swiper 常见的问题"></a>解决使用 swiper 常见的问题</h3><p><strong>1、swiper近视初始化时, 其父级元素处于隐藏状态(display:none),会导致swiper初始化失败, 页面中的滚动效果有问题</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解决方法1: </span><br><span class="line"> var mySwiper = new Swiper(&apos;.demo&apos;,&#123;</span><br><span class="line">     observer: true,//修改swiper自己或子元素时，自动初始化swiper</span><br><span class="line">     observeParents: true//修改swiper的父元素时，自动初始化swiper</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line">解决方法2: </span><br><span class="line">固定宽和高</span><br><span class="line">  var mySwiper = new Swiper(&apos;.demo&apos;,&#123;</span><br><span class="line">     width:200,</span><br><span class="line">     height:200</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p></p><p><strong>2、swiper里面的图片懒加载与预加载, 可以使用自带的 lazyload 方法</strong><br><a href="https://www.swiper.com.cn/api/lazy/213.html" target="_blank" rel="noopener">主要看这里-swiper4 懒加载文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">设为true开启图片延迟加载默认值，使preloadImages无效。或者设置延迟加载选项。</span><br><span class="line"> </span><br><span class="line">图片延迟加载：需要将图片img标签的src改写成data-src，并且增加类名swiper-lazy。</span><br><span class="line">背景图延迟加载：载体增加属性data-background，并且增加类名swiper-lazy。</span><br><span class="line"> </span><br><span class="line">还可以加一个预加载，&lt;div class=&quot;swiper-lazy-preloader&quot;&gt;&lt;/div&gt;</span><br><span class="line">或者白色的&lt;div class=&quot;swiper-lazy-preloader swiper-lazy-preloader-white&quot;&gt;&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">当你设置了slidesPerView:&apos;auto&apos; 或者 slidesPerView &gt; 1，还需要开启watchSlidesVisibility。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">var mySwiper = new Swiper(&apos;.swiper-container&apos;, &#123;</span><br><span class="line">  lazy: &#123;</span><br><span class="line">    loadPrevNext: true,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>3、想在轮播图外创建分页器、上一页和下一页的按钮(因为swiper的container默认overflow:hidden, 只能在轮播图中的可视区域显示切换菜单和上一页下一页)</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var mySwiper = new Swiper(&apos;.swiper-container&apos;,&#123;</span><br><span class="line">    pagination : &apos;.swiper-pagination&apos;,</span><br><span class="line">    uniqueNavElements :false,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><h3 id="jquery-fullpage-插件增加头部和底部的方法"><a href="#jquery-fullpage-插件增加头部和底部的方法" class="headerlink" title="jquery fullpage 插件增加头部和底部的方法"></a>jquery fullpage 插件增加头部和底部的方法</h3><p>官方给出了解决方案，不要去什么修改源码啦之类的，或者自己写代码判断啦<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;fullpage&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;section fp-auto-height&quot;&gt;这里写头部&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;page1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;page2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;page3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;page4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section fp-auto-height&quot;&gt;这里写版权&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p></p><p>如上，js代码就不说了，只要你能跑起来，就没有问题。这里只需要给头部和底部增加一个fp-auto-height 的 class ，然后自己可以加点class写样式。</p><p>没有生效吗？</p><p>嘿嘿，那是因为你只引用了js，而没有引用css造成的，只要引用下面的css即可。</p><p><a href="https://github.com/alvarotrigo/fullPage.js/blob/master/dist/jquery.fullpage.css" target="_blank" rel="noopener">https://github.com/alvarotrigo/fullPage.js/blob/master/dist/jquery.fullpage.css</a></p><p>其实关键代码只是下面的而已<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.fp-auto-height.fp-section,</span><br><span class="line">.fp-auto-height .fp-slide,</span><br><span class="line">.fp-auto-height .fp-tableCell&#123;</span><br><span class="line">    height: auto !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.fp-responsive .fp-auto-height-responsive.fp-section,</span><br><span class="line">.fp-responsive .fp-auto-height-responsive .fp-slide,</span><br><span class="line">.fp-responsive .fp-auto-height-responsive .fp-tableCell &#123;</span><br><span class="line">    height: auto !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其他参数配置见<a href="http://fullpage.81hu.com/" target="_blank" rel="noopener">官网</a></p><h3 id="对于多行text-overflow-ellipsis-溢出显示省略号的解决办法（尽量兼容所有浏览器）"><a href="#对于多行text-overflow-ellipsis-溢出显示省略号的解决办法（尽量兼容所有浏览器）" class="headerlink" title="对于多行text-overflow:ellipsis 溢出显示省略号的解决办法（尽量兼容所有浏览器）"></a>对于多行text-overflow:ellipsis 溢出显示省略号的解决办法（尽量兼容所有浏览器）</h3><p><strong>1、css解决</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@mixin ellipsis($line:1)&#123;</span><br><span class="line">  word-break: break-all;</span><br><span class="line">  @if $line == 1&#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">  &#125;@else&#123;</span><br><span class="line">    text-overflow:clip;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    word-wrap: break-word;</span><br><span class="line">    white-space: normal !important;</span><br><span class="line">    -webkit-line-clamp:$line;</span><br><span class="line">    -webkit-box-orient: vertical;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>2、js解决</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//截取的函数 双字节字符长度为2 ASCLL字符长度为1</span><br><span class="line">function cutStr(str,cutLen)&#123;</span><br><span class="line">    var returnStr = &apos;&apos;,    //返回的字符串</span><br><span class="line">        reCN = /[^\x00-\xff]/,    //双字节字符</span><br><span class="line">        strCNLen = str.replace(/[^\x00-\xff]/g,&apos;**&apos;).length; </span><br><span class="line">    if(cutLen&gt;=strCNLen)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var i=0,len=0;len&lt;cutLen;i++)&#123;</span><br><span class="line">        returnStr += str.charAt(i);</span><br><span class="line">        if(reCN.test(str.charAt(i)))&#123;</span><br><span class="line">            len+=2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return returnStr;</span><br><span class="line">&#125;</span><br><span class="line">$(function ()&#123;</span><br><span class="line">    var str = $(this).text();</span><br><span class="line">    $(this).text(cutStr(str,34)+&apos;...&apos;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p><strong>3、哈哈哈哈，后台解决</strong><br>麻烦以下后端小伙伴帮忙处理以下</p><h3 id="mac中隐藏文件的现实与关闭"><a href="#mac中隐藏文件的现实与关闭" class="headerlink" title="mac中隐藏文件的现实与关闭"></a>mac中隐藏文件的现实与关闭</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder //显示mac中隐藏文件</span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder //关闭mac中隐藏文件</span><br></pre></td></tr></table></figure><h3 id="css实现字体渐变过渡效果"><a href="#css实现字体渐变过渡效果" class="headerlink" title="css实现字体渐变过渡效果"></a>css实现字体渐变过渡效果</h3><p>其实网络上方法有好几种，但是比较快捷常用的就是<code>background-clip</code>属性，看了一下caniuse，兼容性还可以接受</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 class=&quot;text&quot;&gt;聯盟有什麼用？&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>与HTML相对应的CSS代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text &#123;  </span><br><span class="line">    display: inline-block;</span><br><span class="line">    color: green;</span><br><span class="line">    font-size: 10em;</span><br><span class="line">    font-family: &apos;微软雅黑&apos;; //目前有侵权一说，大家慎用</span><br><span class="line">    background-image: -webkit-linear-gradient(bottom,red,#fd8403,yellow);</span><br><span class="line">    -webkit-background-clip: text;</span><br><span class="line">    -webkit-text-fill-color: transparent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CSS代码中关键有用的其实就是最后三行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background-image: -webkit-linear-gradient(bottom,red,#fd8403,yellow);</span><br><span class="line">-webkit-background-clip: text;</span><br><span class="line">-webkit-text-fill-color: transparent;</span><br></pre></td></tr></table></figure><p></p><p>此方法结构简单，易于控制，颜色的选取与控制也更精确，理解上也更容易理解。</p><p>效果：<br><img src="/2019/01/02/daily16/gradient.jpg" alt="圆形图片边框变形"></p><p><a href="https://blog.csdn.net/qq_36370731/article/details/78454700" target="_blank" rel="noopener">流光滚动效果</a></p><p>//更新于04-23</p><p>后续继续整理</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;解决使用-swiper-常见的问题&quot;&gt;&lt;a href=&quot;#解决使用-swiper-常见的问题&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="其他" scheme="http://cansolve.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>圣诞节🎄，刷刷面试题可能更适合我</title>
    <link href="http://cansolve.cn/2018/12/24/daily12/"/>
    <id>http://cansolve.cn/2018/12/24/daily12/</id>
    <published>2018-12-24T13:06:28.000Z</published>
    <updated>2019-01-29T02:04:59.967Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><h3 id="知道什么是事件委托吗？"><a href="#知道什么是事件委托吗？" class="headerlink" title="知道什么是事件委托吗？"></a>知道什么是事件委托吗？</h3><p><a href="https://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">个人感觉这篇文章写的超级好，我就不班门弄斧了</a></p><h3 id="window的onload事件和domcontentloaded谁先谁后？"><a href="#window的onload事件和domcontentloaded谁先谁后？" class="headerlink" title="window的onload事件和domcontentloaded谁先谁后？"></a>window的onload事件和domcontentloaded谁先谁后？</h3><p>一般情况下，DOMContentLoaded事件要在window.onload之前执行，当DOM树构建完成的时候就会执行DOMContentLoaded事件，而window.onload是在页面载入完成的时候，才执行，这其中包括图片等元素。大多数时候我们只是想在DOM树构建完成后，绑定事件到元素，我们并不需要图片元素，加上有时候加载外域图片的速度非常缓慢。</p><h3 id="你之前遇到过跨域问题吗？是怎么解决的。"><a href="#你之前遇到过跨域问题吗？是怎么解决的。" class="headerlink" title="你之前遇到过跨域问题吗？是怎么解决的。"></a>你之前遇到过跨域问题吗？是怎么解决的。</h3><p>目前我知道的可以解决的方法有下面几种：</p><p>jsonp、后端java或者php修改、nginx反向代理、postMessage。。。，应该还有，只是我很少用</p><p>但是比较常用的是下面两种</p><ol><li><p>使用JSONP，其实用的也不多，因为感觉会导致安全问题，或者效率下降（这两点仅是我的猜测）。</p><p><strong>猜测的理由：</strong></p><ul><li><p>任何来源都能访问, 会不会存在乱七八糟的js注入？</p></li><li><p>后端和前端需要都JSONP进行处理。（代码繁琐，而且是所有请求都要使用JSONP）。</p></li></ul></li><li><p>在后端添加跨域头</p><p>为<code>Access-Control-Allow-Origin</code>添加 <code>*</code></p><p>如果前端域名比较多，需要添加很多域名，为<code>Access-Control-Allow-Origin</code>添加目标域名 (<code>Origin 请求头</code>) 而不 是写死的域名或<code>*</code></p></li></ol><h3 id="typeof和instanceof的区别"><a href="#typeof和instanceof的区别" class="headerlink" title="typeof和instanceof的区别"></a>typeof和instanceof的区别</h3><p>typeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。</p><p><strong>它返回值是一个字符串，该字符串说明运算数的类型。（</strong>typeof 运算符返回一个用来表示表达式的数据类型的字符串。 ）</p><p>typeof其实就是判断参数是什么类型的实例，就一个参数</p><p>typeof 一般只能返回如下几个结果：”number”、”string”、”boolean”、”object”、”function” 和 “undefined”。</p><p>instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。 语法：object instanceof constructor 参数：object（要检测的对象.）constructor（某个构造函数） 描述：instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student () &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = Person.prototype;</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">let s = new Student(&apos;Tom&apos;);</span><br><span class="line">console.log(s instanceof Person); // 返回 true</span><br></pre></td></tr></table></figure><h3 id="下面代码输出什么？"><a href="#下面代码输出什么？" class="headerlink" title="下面代码输出什么？"></a>下面代码输出什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line">// 10个10</span><br></pre></td></tr></table></figure><p>若要输出从0到9，怎么办？</p><p><strong>答案:</strong>将var改为let，或者使用闭包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用闭包</span><br><span class="line">for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    (function (i) &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(i)</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-of-和-for-in-的区别"><a href="#for-of-和-for-in-的区别" class="headerlink" title="for of 和 for in 的区别"></a>for of 和 for in 的区别</h3><p>for in<br>一般用于遍历对象的可枚举属性。以及对象从构造函数原型中继承的属性。对于每个不同的属性，语句都会被执行。<br>不建议使用for in 遍历数组，因为输出的顺序是不固定的。<br>如果迭代的对象的变量值是null或者undefined, for in不执行循环体，建议在使用for in循环之前，先检查该对象的值是不是null或者undefined</p><p>for of</p><p>for…of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</p><p>上面是官方解释，我理解的最明显的区别，遍历下面数组</p><p>for in是ES5标准，遍历key.<br>for of是ES6标准，遍历value.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a=[1,2,3]</span><br><span class="line"></span><br><span class="line">for(let i in a)&#123;</span><br><span class="line">    console.log(i);     //0 1 2 这里的i输出的是下标</span><br><span class="line">    console.log(a[i]); //1 2 3</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">for(let i of a)&#123;</span><br><span class="line">    console.log(i); //1 2 3  这里的i输出的是对应的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用过flex布局吗？flex-grow和flex-shrink属性有什么用？"><a href="#使用过flex布局吗？flex-grow和flex-shrink属性有什么用？" class="headerlink" title="使用过flex布局吗？flex-grow和flex-shrink属性有什么用？"></a>使用过flex布局吗？flex-grow和flex-shrink属性有什么用？</h3><p><strong>flex-grow</strong></p><p>用来“瓜分”父项的“剩余空间”。<br><img src="/2018/12/24/daily12/12904618-3e41b8713610e6e8.png" alt="flex-grow"><br>容器的宽度为400px, 子项1的占用的基础空间(flex-basis)为50px，子项2占用的基础空间是70px，子项3占用基础空间是100px，剩余空间为 400-50-70-100 = 180px。 其中子项1的flex-grow: 0(未设置默认为0)， 子项2flex-grow: 2，子项3flex-grow: 1，剩余空间分成3份，子项2占2份(120px)，子项3占1份(60px)。所以 子项1真实的占用空间为: 50+0 = 50px， 子项2真实的占用空间为: 70+120 = 190px， 子项3真实的占用空间为: 100+60 = 160px。</p><p><strong>flex-shrink</strong></p><p>用来“吸收”超出的空间<br><img src="/2018/12/24/daily12/12904618-ed1819e7b3415dec.png" alt="flex-grow"><br>容器的宽度为400px, 子项1的占用的基准空间(flex-basis)为250px，子项2占用的基准空间是150px，子项3占用基准空间是100px，总基准空间为 250+150+100=500px。容器放不下，多出来的空间需要被每个子项根据自己设置的flex-shrink 进行吸收。 子项1的flex-shrink: 1(未设置默认为1)， 子项2 flex-shrink: 2，子项3 flex-shrink: 2。子项1需要吸收的的空间为 <code>(250*1)/(250*1+150*2+100*2) * 100 = 33.33px</code>，子项1真实的空间为 250-33.33 = 216.67px。同理子项2吸收的空间为<code>(150*2)/(250*1+150*2+100*2) * 100=40px</code>，子项2真实空间为 <code>150-40 = 110px</code>。子项3吸收的空间为<code>(100*2)/(250*1+150*2+100*2) * 100 = 26.67px</code>，真实的空间为<code>100-26.67=73.33px</code>。</p><h3 id="从输入URL到页面加载发生了什么？"><a href="#从输入URL到页面加载发生了什么？" class="headerlink" title="从输入URL到页面加载发生了什么？"></a>从输入URL到页面加载发生了什么？</h3><p>这里涉及很多的东西，这里只是简单的写一下大概的答案；</p><p>1、浏览器的地址栏输入URL并按下回车。</p><p>2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。</p><p>3、DNS解析URL对应的IP。</p><p>4、根据IP建立TCP连接（三次握手）。</p><p>5、HTTP发起请求。</p><p>6、服务器处理请求，浏览器接收HTTP响应。</p><p>7、渲染页面，构建DOM树。</p><p>8、关闭TCP连接（四次挥手）。<br><img src="/2018/12/24/daily12/167d5e19c54ae53e.jpg" alt="flex-grow"></p><h3 id="你知道哪些状态码？"><a href="#你知道哪些状态码？" class="headerlink" title="你知道哪些状态码？"></a>你知道哪些状态码？</h3><p>1xx：指示信息–表示请求已接收，继续处理。</p><p>2xx：成功–表示请求已被成功接收、理解、接受。</p><p>3xx：重定向–要完成请求必须进行更进一步的操作。</p><p>4xx：客户端错误–请求有语法错误或请求无法实现。</p><p>5xx：服务器端错误–服务器未能实现合法的请求。</p><p>平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500(分别表示什么请自行查找)。</p><h3 id="刚刚你说的整个过程中，有哪些优化手段可以优化提高网页响应速度？"><a href="#刚刚你说的整个过程中，有哪些优化手段可以优化提高网页响应速度？" class="headerlink" title="刚刚你说的整个过程中，有哪些优化手段可以优化提高网页响应速度？"></a>刚刚你说的整个过程中，有哪些优化手段可以优化提高网页响应速度？</h3><p><a href="https://csspod.com/frontend-performance-best-practices/" target="_blank" rel="noopener">贴个链接，比我解释的详细</a></p><p><strong>补充于2018-12-28</strong></p><h3 id="什么是圣杯布局？"><a href="#什么是圣杯布局？" class="headerlink" title="什么是圣杯布局？"></a>什么是圣杯布局？</h3><p>官方解释：<br>圣杯布局是为了讨论「三栏液态布局」的实现，最早的完美实现是由 Matthew Levine 在 2006 年写的一篇文章 《In Search of the Holy Grail》 ，它主要讲述了网页中关于最佳圣杯的实现方法。</p><p>它有以下几点要求：</p><p>上部(header)和下部(footer)各自占领屏幕所有宽度。<br>上下部之间的部分(container)是一个三栏布局。<br>三栏布局两侧宽度不变，中间部分自动填充整个区域。<br>中间部分的高度是三栏中最高的区域的高度。</p><h5 id="实现方法1：浮动"><a href="#实现方法1：浮动" class="headerlink" title="实现方法1：浮动"></a>实现方法1：浮动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;header&quot;&gt;</span><br><span class="line">    &lt;h4&gt;header&lt;/h4&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">        &lt;h4&gt;middle&lt;/h4&gt;</span><br><span class="line">        &lt;p&gt;middle-content&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">        &lt;h4&gt;left&lt;/h4&gt;</span><br><span class="line">        &lt;p&gt;left-content&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">        &lt;h4&gt;right&lt;/h4&gt;</span><br><span class="line">        &lt;p&gt;right-content&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;footer&quot;&gt;</span><br><span class="line">    &lt;h4&gt;footer&lt;/h4&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.header, .footer &#123;</span><br><span class="line">    border: 1px solid #333;</span><br><span class="line">    background: #ccc;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.footer &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">    padding:0 220px 0 200px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.left, .middle, .right &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    float: left;</span><br><span class="line">    min-height: 130px;</span><br><span class="line">&#125;</span><br><span class="line">.middle &#123;</span><br><span class="line">   width: 100%;</span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">    margin-left: -100%;</span><br><span class="line">    left: -200px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">    margin-left: -220px;</span><br><span class="line">    right: -220px;</span><br><span class="line">    width: 220px;</span><br><span class="line">    background: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析一下思路：</p><ul><li><p>在html中，先定义好header和footer的样式，使之横向撑满。</p></li><li><p>在container中的三列设为浮动和相对定位(后面会用到)，middle要放在最前面，footer清除浮动。</p></li><li><p>三列的左右两列分别定宽200px和220px，中间部分middle设置100%撑满</p></li><li><p>这样因为浮动的关系，middle会占据整个container，左右两块区域被挤下去了</p></li><li><p>接下来设置left的<code>margin-left:-100%;</code>，让left回到上一行最左侧</p></li><li><p>但这会把middle给遮住了，所以这时给外层的container设置<code>padding:0 220px 0 200px;</code>，给left空出位置</p></li><li><p>这时left并没有在最左侧，因为之前已经设置过相对定位，所以通过<code>left:-200px;</code>把left拉回最左侧</p></li><li><p>同样的，对于right区域，设置<code>margin-right:-220px;</code>把right拉回第一行</p></li><li><p>这时右侧空出了220px的空间，所以最后设置 `right:-220px;##把right区域拉到最右侧就行了。</p></li></ul><h5 id="实现方法2：flex弹性盒子"><a href="#实现方法2：flex弹性盒子" class="headerlink" title="实现方法2：flex弹性盒子"></a>实现方法2：flex弹性盒子</h5><pre><code>这个我就不贴代码了，</code></pre><ul><li>header和footer同上面一样，横向撑满。footer不用再清浮动了</li><li>container中的left、middle、right依次排布即可，不用特意将middle放置到最前面</li><li>给container设置弹性布局 display:flex;</li><li>left和right区域定宽，middle设置 flex:1; 即可</li></ul><p>后续继续整理</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;知道什么是事件委托吗？&quot;&gt;&lt;a href=&quot;#知道什么是事件委托吗？&quot; class=&quot;headerlink&quot; title=&quot;知道什么是事件委
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="js" scheme="http://cansolve.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>2019年React学习路线图</title>
    <link href="http://cansolve.cn/2018/12/20/daily10/"/>
    <id>http://cansolve.cn/2018/12/20/daily10/</id>
    <published>2018-12-20T11:05:40.000Z</published>
    <updated>2018-12-24T04:22:46.515Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><blockquote><p>作者｜javinpaul<br>译者｜无明<br>转发自 | 前端之巅公众号</p></blockquote><p>之前我们已经介绍了 <a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247490087&amp;idx=1&amp;sn=fb16b7826416244642cdab69a52848c0&amp;chksm=f951af64ce262672982f1896976f594589925a0b2730801715247ae40d7ee06c2960d6b6a338&amp;token=1582750074&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">2019 年 Vue 学习路线图</a>，而 React 作为当前应用最广泛的前端框架，在 Facebook 的支持下，近年来实现了飞越式的发展，我们将在下文中介绍 2019 年 React 学习路线图，希望给想学 React 的开发者一些借鉴。</p><p>下图是2018 年的 React 路线图，它非常全面，2018 年剩下的时间可能不够你学会所有这些，但不要担心，所有的技术在 2019 年仍然有效。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/XIibZ0YbvibkUhfSXs7kotWIegAeUWWHMDpOs46GfwR0YnIHCauC8Kt69U6gexHpKQvqZpFyhcUABEJYYCnTFwbA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""><br>图片来源：</p><p><a href="https://github.com/adam-golab/react-developer-roadmap/blob/master/roadmap.png" target="_blank" rel="noopener">https://github.com/adam-golab/react-developer-roadmap/blob/master/roadmap.png</a></p><h3 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h3><p>不管你要学习哪个 Web 开发框架或库，都必须掌握基础知识，如 HTML、CSS 和 JavaScript，这三个是 Web 开发的三大支柱。</p><p><strong>HTML</strong></p><p>HTML 是 Web 开发人员最重要的技能之一，因为它为网页提供了基本结构。</p><p><strong>CSS</strong></p><p>CSS 用于设置网页样式，让网页看起来更好看。</p><p><strong>JavaScript</strong></p><p>JavaScript 让网页具备交互性。React 是基于 JavaScript 的，因此在学习 React 之前，你应该先了解 JavaScript。</p><h3 id="2、通用的开发技能"><a href="#2、通用的开发技能" class="headerlink" title="2、通用的开发技能"></a>2、通用的开发技能</h3><p>无论你是前端开发人员还是后端开发人员，甚至是全栈工程师，都必须了解一些能够让你在编程世界中生存下来的通用开发技能。</p><p><strong>学习 GIT</strong></p><p>你必须在 2018 年完全了解 Git。尝试在 GitHub 上创建一些存储库，与其他人共享你的代码，并学习如何在你喜欢的 IDE 中克隆 Github 上的代码。</p><p><strong>了解 HTTP(S) 协议</strong></p><p>如果你想成为一名 Web 开发人员，那么了解 HTTP 绝对是有必要的。</p><p>我不是要你去阅读 HTTP(S) 规范，但你至少应该熟悉常见的 HTTP 请求方法，如 GET、POST、PUT、PATCH、DELETE、OPTIONS 以及 HTTP/HTTPS 的工作原理。</p><p><strong>学习终端</strong></p><p>虽然前端开发人员学习 Linux 或终端并不是强制性的，但我强烈建议你熟悉以下终端，了解如何配置你的 shell（bash、zsh、csh）等。</p><p><strong>算法和数据结构</strong></p><p>好吧，这又是一个通用编程技能，成为 React 开发者不一定需要了解这些，但要成为真正的程序员，这是必备技能。</p><p><strong>学习设计模式</strong></p><p>就像算法和数据结构一样，成为 React 开发者并不一定要学习设计模式，但学好设计模式会让你变得更好。了解设计模式将帮你找到能够经受住时间考验的解决方案。</p><h3 id="3、学习-React"><a href="#3、学习-React" class="headerlink" title="3、学习 React"></a>3、学习 React</h3><p>你必须学好 React 才能成为一名 React 开发者。学习 React 最好的资源是它的官方网站，但作为初学者，它对你来说可能有点难。</p><p><strong>学习构建工具</strong></p><p>如果你想成为一名专业的 React 开发者，那么你应该花一些时间熟悉一下你将作为 Web 开发者需要使用的工具，比如构建工具、单元测试工具、调试工具等。</p><p>以下是路线图中列出的构建工具：</p><p>包管理器：</p><ul><li><p>npm</p></li><li><p>yarn</p></li><li><p>pnpm</p></li><li><p>任务执行器</p></li><li><p>npm 脚本</p></li><li><p>gulp</p></li><li><p>WebPack</p></li><li><p>Rollup</p></li><li><p>Parcel</p></li></ul><p>顺便说一句，并非要学习所有这些工具，对于初学者来说，学习 npm 和 Webpack 应该足够了。在你对 Web 开发和 React 生态系统有了更多的了解后，你就可以学习其他工具。</p><p><strong>样式</strong></p><p>如果你的目标是成为 React 开发者，了解一些样式相关的知识只会有益无害。路线图中提到了很多 CSS 相关的东西，比如 CSS 预处理器、CSS 框架、CSS 架构和 JS 中的 CSS。</p><p>我建议你至少学习一下 Bootstrap，这是你经常会用到的 CSS 框架。</p><p>如果你想进一步学习 bootstrap，也可以学习 Materialise 或 Material UI。</p><p><strong>状态管理</strong></p><p>这是 React 开发者应该关注的另一个重要领域。路线图中提到了以下一些需要掌握的概念和框架：</p><ul><li><p>组件 State/ContextAPI</p></li><li><p>Redux</p></li><li><p>异步操作（副作用）</p></li><li><p>Redux Thunk</p></li><li><p>Redux Better Promise</p></li><li><p>Redux Saga</p></li><li><p>Redux Observable</p></li><li><p>Helpers</p></li><li><p>Rematch</p></li><li><p>Reselect</p></li><li><p>Data persistence</p></li><li><p>Redux Persist</p></li><li><p>Redux Phoenix</p></li><li><p>Redux Form</p></li><li><p>MobX</p></li></ul><p>如果东西太多，我建议你只关注 Redux。</p><p><strong>Type Checker</strong></p><p>由于 JavaScript 不是一种强类型语言，因此编译器不会捕获那些与类型相关的错误。</p><p>随着应用程序的增长，你可以通过类型检查捕获大量错误，尤其是如果你可以使用 Flow 或 TypeScript 等 JavaScript 扩展对整个应用程序进行类型检查。</p><p>React 也提供了一些内置的类型检查功能，可以用它们帮你尽早发现 bug。</p><p>由于 Angular 也使用了 TypeScript，我认为可以同时学习 JavaScript 和 TypeScript。</p><p><strong>Form Helper</strong></p><p>除了 Type Checker 之外，还可以学习像 Redux Form 这样的 Form Helper，它提供了在 Redux 中管理表单状态的最佳方法。除了 Redux Form 之外，还有 Formik、Formsy 和 Final。</p><p><strong>路由</strong></p><p>组件是 React 声明性编程模型的核心，而路由组件是应用程序的重要组成部分。</p><p>React Router 提供了一组导航组件，这些组件可以通过声明的方式与你的应用程序组合在一起。</p><p>除了 React Router 之外，你还可以看看 Router 5 和 Redux-First Router。</p><p><strong>API 客户端</strong></p><p>在今天的世界中，你很少会构建独立的 GUI，相反，你将有更多机会使用 REST 和 GraphQL 等 API 构建与其他应用程序发生交互的东西。</p><p>值得庆幸的是，React 开发者可以使用很多 API 客户端：</p><p>REST</p><ul><li><p>Fetch</p></li><li><p>SuperAgent</p></li><li><p>axios</p></li></ul><p>GraphQL</p><ul><li><p>Apollo</p></li><li><p>Relay</p></li><li><p>urql</p></li></ul><p>Apollo 客户端是我的最爱，它提供了一种使用 GraphQL 构建客户端应用程序的简便方法。Apollo 可以帮你快速构建使用 GraphQL 获取数据的 UI，并可以与任意 JavaScript 前端一起使用。</p><p><strong>辅助库</strong></p><p>这些库可以让你的工作变得更轻松。React 开发人员可以使用很多辅助库，如下所示：</p><ul><li><p>Lodash</p></li><li><p>Moment</p></li><li><p>classnames</p></li><li><p>Numeral</p></li><li><p>RxJS</p></li><li><p>Ramda</p></li></ul><p>这些不一定都要学，路线图中的 Lodash、Moment 和 Classnames 是用黄色标注的，所以应该先从它们开始学习。</p><p><strong>测试</strong></p><p>测试是 React 开发者的一项重要技能，但经常被忽视，如果你想在竞争中保持领先，就要学习一些用于测试的库。这些库可用于单元测试、集成测试和端到端测试。</p><p>以下是路线图中提到的库：</p><p><strong>单元测试</strong></p><ul><li><p>Jest</p></li><li><p>Enzyme</p></li><li><p>Sinon</p></li><li><p>Mocha</p></li><li><p>Chai</p></li><li><p>AVA</p></li><li><p>Tape</p></li></ul><p><strong>端到端测试</strong></p><ul><li><p>Selenium, Webdriver</p></li><li><p>Cypress</p></li><li><p>Puppeteer</p></li><li><p>Cucumber.js</p></li><li><p>Nightwatch.js</p></li></ul><p><strong>集成测试</strong></p><ul><li>Karma</li></ul><p>你可以学习你想学习的库，但建议一定要学习 Jest 和 Enzyme。</p><p><strong>国际化</strong></p><p>这是前端开发的另一个重要主题。你可能需要支持日本、中国、西班牙和其他欧洲国家的本地 GUI 版本。</p><p>路线图中建议你学习以下技术，它们都很好理解：</p><ul><li><p>React Intl</p></li><li><p>React i18next</p></li></ul><p>这两个库都提供了 React 组件和 API 来格式化日期、数字和字符串，包括复数和处理翻译。</p><p><strong>服务器端渲染</strong></p><p>你可能会想，服务器端渲染和客户端渲染之间有什么区别。在使用客户端渲染时，你的浏览器会下载一个最小的 HTML 页面，然后通过 JavaScript 并将内容填充到页面中。</p><p>在使用服务器端渲染时，React 组件是在服务器上进行渲染的，将输出的 HTML 内容传到客户端或浏览器。</p><p>路线图推荐了以下的服务器端渲染：</p><ul><li><p>Next.js</p></li><li><p>After.js</p></li><li><p>Rogue</p></li></ul><p>不过我建议学习 Next.js 应该足够了。</p><p><strong>静态站点生成器</strong></p><p>Gatsby.js 是一个现代静态站点生成器。你可以使用 Gatsby 创建个性化的登录网站体验。它将你的数据与 JavaScript 相结合，并创建格式良好的 HTML 内容。</p><p><strong>后端框架集成</strong></p><p>React on Rails 将 Rails 与 Facebook 的 React 前端框架（服务器渲染）集成在一起。它提供了服务器渲染，通常用于 SEO 爬虫索引和 UX。</p><h3 id="4、移动端"><a href="#4、移动端" class="headerlink" title="4、移动端"></a>4、移动端</h3><p>React Native 正迅速成为使用 JavaScript 开发具有原生外观的移动应用程序的标准方法。</p><p>路线图中建议你学习以下库：</p><ul><li><p>React Native</p></li><li><p>Cordova/PhoneGap</p></li><li><p>Flutter—————–本人添加</p></li></ul><p>但我认为只要学习 React Native 就足够了。<br>这里补充一句我个人想法，现在应该要关注一下Flutter的发展了—————–本人添加</p><h3 id="5、桌面端"><a href="#5、桌面端" class="headerlink" title="5、桌面端"></a>5、桌面端</h3><p>还有一些基于 React 的框架可用于构建像 React Native Windows 这样的桌面 GUI，让你可以使用 React 构建原生 UWP 和 WPF 应用程序。</p><p>路线图建议使用以下几个库：</p><ul><li><p>Proton Native</p></li><li><p>Electron</p></li><li><p>React Native Windows</p></li></ul><p>它们都是进阶的内容，如果你已经掌握了 React，可以看一下它们。</p><h3 id="6、虚拟现实"><a href="#6、虚拟现实" class="headerlink" title="6、虚拟现实"></a>6、虚拟现实</h3><p>如果你对构建基于虚拟现实的应用程序感兴趣，还可以了解以下像 React 360 这样的框架，让你可以通过 React 开发 VR 体验。如果你对这个领域感兴趣，可以进一步了解 React 360。</p><p>英文原文：</p><p><a href="https://hackernoon.com/the-2018-react-js-roadmap-4d0a43814c02" target="_blank" rel="noopener">https://hackernoon.com/the-2018-react-js-roadmap-4d0a43814c02</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;blockquote&gt;&lt;p&gt;作者｜javinpaul&lt;br&gt;译者｜无明&lt;br&gt;转发自 | 前端之巅公众号&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;之前我们已
      
    
    </summary>
    
      <category term="分享" scheme="http://cansolve.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="react" scheme="http://cansolve.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>es6中的promise解读</title>
    <link href="http://cansolve.cn/2018/11/23/daily8/"/>
    <id>http://cansolve.cn/2018/11/23/daily8/</id>
    <published>2018-11-23T11:45:40.000Z</published>
    <updated>2018-12-19T09:52:38.175Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><blockquote><p>作者：离秋<br>链接：<a href="https://juejin.im/post/5bed21156fb9a04a0c2e025d" target="_blank" rel="noopener">https://juejin.im/post/5bed21156fb9a04a0c2e025d</a></p></blockquote><blockquote><p>简单的说它是一个异步流程的控制手段。是一个代表了异步操作最终完成或者失败的对象。</p></blockquote><h3 id="promise的优点"><a href="#promise的优点" class="headerlink" title="promise的优点"></a>promise的优点</h3><ul><li><p>promise解决了回调地狱的问题</p></li><li><p>promise可以支持多个并发的请求</p></li><li><p>promise的错误传播机制可以统一的处理错误信息</p></li></ul><h3 id="回调地狱问题"><a href="#回调地狱问题" class="headerlink" title="回调地狱问题"></a>回调地狱问题</h3><blockquote><p>在传统的ajax调用过程中，下面以jquery.ajax为例。如果需求中要多次进行ajax交互，并且上一次的返回结果还要被下一次的ajax使用，代码基本上会变成：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">   type: &quot;POST&quot;,</span><br><span class="line">   url: &quot;some.php&quot;,</span><br><span class="line">   data: &quot;name=John&amp;location=Boston&quot;,</span><br><span class="line">   success: function(msg)&#123;</span><br><span class="line">       $.ajax(&#123;</span><br><span class="line">           type: &quot;POST&quot;,</span><br><span class="line">           url: &quot;some.php&quot;,</span><br><span class="line">           data: msg,</span><br><span class="line">           success: function(msg2)&#123;</span><br><span class="line">             ...//多次调用</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>现在还只是两次调用关系，如果是多次调用将会引发下面的问题</p></blockquote><ol><li><p>多次调用不利于代码的管理于维护</p></li><li><p>发生错误时不能及时准备的定位错误位置</p></li><li><p>只要又一次不成功就不能进行下面的逻辑，不方便进行错误处理。</p></li></ol><blockquote><p>promise的链式调用就很好的解决了这个问题</p></blockquote><h3 id="Promise的三种状态"><a href="#Promise的三种状态" class="headerlink" title="Promise的三种状态"></a>Promise的三种状态</h3><ul><li><p>Pending Promise对象实例创建时候的初始状态</p></li><li><p>resolve 可以理解为成功的状态</p></li><li><p>Reject 可以理解为失败的状态</p></li></ul><blockquote><p>promise 中的状态只能是从等待状态转换到成功状态或者失败状态，且状态转变之后不可逆。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/167164a42f989193?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><img src="https://user-gold-cdn.xitu.io/2018/11/15/167164a42f989193?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h3 id="一个简单的promise"><a href="#一个简单的promise" class="headerlink" title="一个简单的promise"></a>一个简单的promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let  p  =  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(2)</span><br><span class="line">//1 2</span><br></pre></td></tr></table></figure><blockquote><p>promise里面只接受一个参数，叫做执行器函数，这个函数会同步执行。也就是说上面代码中的箭头函数被同步执行，得到的结果也就是1和2</p></blockquote><h3 id="promise中的then"><a href="#promise中的then" class="headerlink" title="promise中的then"></a>promise中的then</h3><blockquote><p>每一个promise的实例上都有一个then方法，这个方法上有两个参数，一个是成功的回调，一个是失败的回调。而取决于成功或者失败的是promise的执行器函数中执行的是成功还是失败。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let  p  =  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    resolve();//调用resolve会走到then的成功回调</span><br><span class="line">    //reject();//调用resolve会走到then的失败回调</span><br><span class="line">&#125;);</span><br><span class="line">p.then(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        console.log(&apos;成功&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    , () =&gt; &#123;</span><br><span class="line">        console.log(&apos;失败&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    //1 成功</span><br></pre></td></tr></table></figure><blockquote><p>如果既不调用resolve也不调用reject，promise则一直处于等待状态，也就不会走到then方法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let  p  =  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        console.log(&apos;成功&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    , () =&gt; &#123;</span><br><span class="line">        console.log(&apos;失败&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    //1</span><br></pre></td></tr></table></figure><blockquote><p>如果你既调用resolve也调用reject，那么谁在前面执行就走谁的对应回调函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let  p  =  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    resolve()//先调用成功</span><br><span class="line">    reject()</span><br><span class="line">&#125;);</span><br><span class="line">p.then(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        console.log(&apos;成功&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    , () =&gt; &#123;</span><br><span class="line">        console.log(&apos;失败&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    //1 成功</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let  p  =  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    reject()//先调用失败</span><br><span class="line">    resolve()</span><br><span class="line">&#125;);</span><br><span class="line">p.then(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        console.log(&apos;成功&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    , () =&gt; &#123;</span><br><span class="line">        console.log(&apos;失败&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    //1 失败</span><br></pre></td></tr></table></figure><blockquote><p>如果代码出错则会直接走reject的回调</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let  p  =  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    throw  new  Error(&apos;出错了~&apos;)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        console.log(&apos;成功&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    , () =&gt; &#123;</span><br><span class="line">        console.log(&apos;失败&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    //1 失败</span><br></pre></td></tr></table></figure><blockquote><p>一个promise的实例可以then多次</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let  p  =  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&apos;成功了&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">    console.log(data)//成功了</span><br><span class="line">&#125;);</span><br><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">    console.log(data)//成功了</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="利用promise解决回调地狱"><a href="#利用promise解决回调地狱" class="headerlink" title="利用promise解决回调地狱"></a>利用promise解决回调地狱</h3><blockquote><p>能够规避异步操作中回调地狱的问题，其本质取决于promise的链式调用。 假设需求如下，a.txt文件的内容为b.txt,b.txt文件的内容是一段描述文字，现在要求用a.txt的得到最终的描述文字，代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let  fs  =  require(&apos;fs&apos;);</span><br><span class="line">//首先将异步方法封装在一个promise中，异步结果成功调用resolve方法，失败调用reject方法。</span><br><span class="line">function  read(url) &#123;</span><br><span class="line">    return  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        fs.readFile(url, &apos;utf8&apos;, function (err, data) &#123;</span><br><span class="line">            if (err) reject();</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//因为read方法返回的是一个promise，所以可以使用promise的then方法</span><br><span class="line">read(&apos;a.txt&apos;).then((data) =&gt; &#123;</span><br><span class="line">//第一次异步成功后拿到结果继续返回一个promise可以实现链式调用。</span><br><span class="line">    console.log(data);//b.txt</span><br><span class="line">return  read(data);</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;</span><br><span class="line">//最后两次的结果分别对应两次异步的返回内容</span><br><span class="line">    console.log(data)//描述文字</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>总结：如果一个promise的then方法中还返回另一个promise，那么这个promise的成功状态会走到外层promise的下一次then方法的成功，如果失败，返回外层promise下一次then的失败。</p></blockquote><h3 id="promise的链式调用"><a href="#promise的链式调用" class="headerlink" title="promise的链式调用"></a>promise的链式调用</h3><ul><li>如果then中返回的是一个普通值，就会走到下一次then的成功回调。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read().then((data) =&gt; &#123;</span><br><span class="line">return  111</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;</span><br><span class="line">console.log(data)//111</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;)</span><br></pre></td></tr></table></figure><ul><li>如果then中返回的是一个错误，就会走到下一次then的失败回调。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read().then((data) =&gt; &#123;</span><br><span class="line">throw  new  Error(&apos;出错了~&apos;)</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;</span><br><span class="line">console.log(data)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">console.log(err)//出错了~</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>如果then中什么也不返回，就会走到下一次then的成功回调，得到的值为undefined。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read().then((data) =&gt; &#123;</span><br><span class="line">cons.log(111)</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;</span><br><span class="line">console.log(data)//undefined</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>如果想统一处理错误内容，可以使用catch。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read().then((data) =&gt; &#123;</span><br><span class="line">throw  new  Error(&apos;出错了~&apos;)</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;&#125;, (err) =&gt; &#123;&#125;).catch((err)=&gt;&#123;</span><br><span class="line">    //错误处理</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>统一处理错误后，还可以使用then。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read().then((data) =&gt; &#123;</span><br><span class="line">throw  new  Error(&apos;出错了~&apos;)</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;&#125;, (err) =&gt; &#123;&#125;).catch((err)=&gt;&#123;</span><br><span class="line">    //错误处理</span><br><span class="line">&#125;).then((data) =&gt; &#123;&#125;, (err) =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><blockquote><p>all方法可以处理多个请求并发的问题。参数是一个数组。all方法调用后会返回一个新的promise。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let  fs  =  require(&apos;fs&apos;);</span><br><span class="line">function  read(url) &#123;</span><br><span class="line">    return  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        fs.readFile(url, &apos;utf8&apos;, function (err, data) &#123;</span><br><span class="line">            if (err) reject();</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Promise.all([read(&apos;1.txt&apos;), read(&apos;2.txt&apos;)]).then((data) =&gt; &#123;</span><br><span class="line">    console.log(data)//[ &apos;文本1内容&apos;, &apos;文本2内容&apos; ]</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在all方法中一个失败了就全部失败，所以都成功了才会走成功回调。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([read(&apos;1.txt&apos;), read(&apos;3.txt&apos;)]).then((data) =&gt; &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    console.log(&apos;失败了&apos;);//失败了</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><blockquote><p>多个请求中，谁的返回数据最快，结果就是谁</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.race([read(&apos;1.txt&apos;), read(&apos;2.txt&apos;)]).then((data) =&gt; &#123;</span><br><span class="line">    console.log(data)////文本2内容</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    console.log(&apos;失败了&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><blockquote><p>返回一个成功的Promise</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&apos;123&apos;).then((data) =&gt; &#123;</span><br><span class="line">    console.log(data)//123</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><blockquote><p>返回一个失败的Promise</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(&apos;123&apos;).then((data) =&gt; &#123;</span><br><span class="line">    console.log(&apos;err&apos;, data)//err 123</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;blockquote&gt;&lt;p&gt;作者：离秋&lt;br&gt;链接：&lt;a href=&quot;https://juejin.im/post/5bed21156fb9a04a0c2
      
    
    </summary>
    
      <category term="分享" scheme="http://cansolve.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="es6" scheme="http://cansolve.cn/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>重新理解一遍回流(reflow)与重绘(repaint)</title>
    <link href="http://cansolve.cn/2018/11/04/daily15/"/>
    <id>http://cansolve.cn/2018/11/04/daily15/</id>
    <published>2018-11-04T10:02:04.000Z</published>
    <updated>2019-01-04T10:37:56.420Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><p>一次页面重构过程中遇到的问题，回流和重绘，面试题中经常有，可是我之前一直不是很清楚这两步具体做了什么事情。今天刚好事情做完又看到这个问题，就去查了查资料，理解一下，写了这篇文章加深一下印象，有什么写的不好的希望大家多指正。</p><h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><p>这里得先从浏览器的渲染过程讲起，此处你也可以跳过，因为得先了解渲染过程才能知道回流和重排在哪个阶段执行。</p><p><img src="/2018/11/04/daily15/001.png" alt="webkit渲染过程"></p><p>从这个图就可以看出浏览器渲染过程；</p><ul><li><p>解析html和css，生成DOM树以及cssom；</p></li><li><p>html和css结合起来生成Render Tree；</p></li><li><p><strong>回流：</strong> 根据生成的渲染树，进行回流(Layout)，得到可见节点的几何信息（位置，大小）</p></li><li><p><strong>重排：</strong> 根据回流得到的信息结合渲染树，进行渲染展示</p><p>#</p></li></ul><h3 id="生成渲染树"><a href="#生成渲染树" class="headerlink" title="生成渲染树"></a>生成渲染树</h3><p>为了构建渲染树，浏览器主要完成了以下工作：</p><ol><li><p>从DOM树的根节点开始遍历每个<strong>可见节点</strong>。</p></li><li><p>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</p></li><li><p>根据每个可见节点以及其对应的样式，组合生成渲染树。</p></li></ol><p>这里说到了要遍历可见的节点，什么节点是不可见的。不可见的节点包括：</p><ol><li><p>一些不会渲染输出的节点，比如script、meta、link等。</p></li><li><p>一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</p></li></ol><p><strong>注意：渲染树只包含可见的节点</strong></p><h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><p>前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，<strong>当render树中的一部分或者全部因为大小边距等问题发生改变而需要重建的过程叫做回流</strong>。</p><p>为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">            &lt;title&gt;Critial Path: Hello world!&lt;/title&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">            &lt;div style=&quot;width: 50%&quot;&gt;</span><br><span class="line">                &lt;div style=&quot;width: 50%&quot;&gt;Hello world!&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;</span><br></pre></td></tr></table></figure><p>我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图）</p><p><img src="/2018/11/04/daily15/002.png" alt=""></p><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>最终，我们通过构造渲染树和回流阶段，有了DOM结构的节点，有了节点的位置样式，接下来就开始渲染到页面上，<strong>当元素的一部分属性发生变化，如外观背景色不会引起布局变化而需要重新渲染的过程叫做重绘</strong></p><p>现在知道了浏览器的渲染过程，我们就来探讨下，何时会发生回流重绘。</p><h2 id="何时发生回流重绘"><a href="#何时发生回流重绘" class="headerlink" title="何时发生回流重绘"></a>何时发生回流重绘</h2><p>我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，所以可以理解当页面布局和几何信息发生变化的时候，肯定会发生回流。比如以下情况：</p><ul><li><p>添加或删除可见的DOM元素</p></li><li><p>元素的位置、尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</p></li><li><p>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</p></li><li><p>页面一开始渲染的时候（这肯定避免不了）</p></li><li><p>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s = document.body.style;</span><br><span class="line"> s.padding = &quot;2px&quot;; // 回流+重绘</span><br><span class="line"> s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘</span><br><span class="line"> s.color = &quot;blue&quot;; // 再一次重绘</span><br><span class="line"> s.backgroundColor = &quot;#ccc&quot;; // 再一次 重绘</span><br><span class="line"> s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘</span><br><span class="line"> // 添加node，再一次 回流+重绘</span><br><span class="line"> document.body.appendChild(document.createTextNode(&apos;abc!&apos;));</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：回流一定会触发重绘，而重绘不一定会回流</strong></p><p>为什么：上面说了定义很明显—如外观背景色不会引起布局变化而需要重新渲染的过程叫做重绘，布局没有变化就不会发生回流；</p><p>触发回流的css 属性有这些:</p><p><img src="/2018/11/04/daily15/003.png" alt=""></p><p>而触发重绘的有这些:</p><p><img src="/2018/11/04/daily15/004.png" alt=""></p><p>说到这里大家都知道回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系，假设你直接操作body，比如在body最前面插入1个元素，会导致整个render tree回流，这样代价当然会比较高，但如果是指body后面插入1个元素，则不会影响前面元素的回流。</p><h2 id="浏览器的优化机制"><a href="#浏览器的优化机制" class="headerlink" title="浏览器的优化机制"></a>浏览器的优化机制</h2><p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>，比如当你访问以下属性或者使用以下方法：</p><ul><li><p>offsetTop、offsetLeft、offsetWidth、offsetHeight</p></li><li><p>scrollTop、scrollLeft、scrollWidth、scrollHeight</p></li><li><p>clientTop、clientLeft、clientWidth、clientHeight</p></li><li><p>getComputedStyle()</p></li><li><p>getBoundingClientRect</p></li><li><p>具体可以访问这个网站：<a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank" rel="noopener">https://gist.github.com/paulirish/5d52fb081b3570c81e3a</a></p></li></ul><p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列。</strong>如果要使用它们，最好将值缓存起来。</p><h2 id="最小化重绘和重排"><a href="#最小化重绘和重排" class="headerlink" title="最小化重绘和重排"></a>最小化重绘和重排</h2><p>由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。总结了以下几点：</p><p>1：用transform 代替 top，left ，margin-top， margin-left… 这些位移属性</p><p>2：用opacity 代替 visibility，但是要同时有translate3d 或 translateZ 这些可以创建的图层的属性存在才可以阻止回流</p><p>但是第二点经过我的实验，发现如果不加 transform: translateZ(0) 配合opacity的话还是会产生回流的，而只用visibility 就只会产生重绘不会回流</p><p>而 opacity 加上 transform: translateZ/3d 这个属性之后便不会发生回流和重绘了</p><p>3：不要直接使用js操作dom元素的样式，选择用一个class 代替之。</p><p>4：如果确实需要用 js 对 dom 设置多条样式那么可以将这个dom 先隐藏，然后再对其设置</p><p>5：不要在循环内获取dom 的样式例如：offsetWidth, offsetHeight, clientWidth, clientHeight… 这些。浏览器有一个回流的缓冲机制，即多个回流会保存在一个栈里面，当这个栈满了浏览器便会一次性触发所有样式的更改且刷新这个栈。但是如果你多次获取这些元素的实际样式，浏览器为了给你一个准确的答案便会不停刷新这个缓冲栈，导致页面回流增加。</p><p>所以为了避免这个问题，应该用一个变量保存在循环体外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">clientWidth在循环体内：</span><br><span class="line">function startTest1() &#123;</span><br><span class="line">      const box1 = document.querySelector(&apos;#box1&apos;);      </span><br><span class="line">      const p = document.querySelectorAll(&apos;p&apos;);</span><br><span class="line">      for (let i = 0; i &lt; p.length; i++) &#123;</span><br><span class="line">        p[i].style.width = box1.clientWidth + &apos;px&apos;;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">clientWidth在循环体外：</span><br><span class="line">function startTest2() &#123;</span><br><span class="line">      const box2 = document.querySelector(&apos;#box2&apos;);</span><br><span class="line">      const p = document.querySelectorAll(&apos;p&apos;);</span><br><span class="line">      const width = box2.clientWidth;</span><br><span class="line">      for (let i = 0; i &lt; p.length; i++) &#123;</span><br><span class="line">        p[i].style.width = width + &apos;px&apos;;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>6：不要使用table 布局，因为table 的每一个行甚至每一个单元格的样式更新都会导致整个table 重新布局</p><p>7：动画的速度按照业务按需决定</p><p>8：对于频繁变化的元素应该为其加一个 transform 属性，对于视频使用video 标签</p><p>9：必要时可以开启 GPU 加速，但是不能滥用</p><ol><li><p>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘</p></li><li><p>对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p><h4 id="css3硬件加速的坑"><a href="#css3硬件加速的坑" class="headerlink" title="css3硬件加速的坑"></a>css3硬件加速的坑</h4><ul><li><p>如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。</p></li><li><p>在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。</p></li></ul></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;一次页面重构过程中遇到的问题，回流和重绘，面试题中经常有，可是我之前一直不是很清楚这两步具体做了什么事情。今天刚好事情做完又看到这个问题，就去查了查资
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="其他" scheme="http://cansolve.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>viewport-fit解决iPhone X、XS、XS Max、XR刘海屏问题</title>
    <link href="http://cansolve.cn/2018/10/10/daily2/"/>
    <id>http://cansolve.cn/2018/10/10/daily2/</id>
    <published>2018-10-10T03:28:29.000Z</published>
    <updated>2018-12-14T07:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><h4 id="一次活动页面发现的iPhone-X、XS、XS-Max、XR刘海屏问题"><a href="#一次活动页面发现的iPhone-X、XS、XS-Max、XR刘海屏问题" class="headerlink" title="一次活动页面发现的iPhone X、XS、XS Max、XR刘海屏问题"></a>一次活动页面发现的iPhone X、XS、XS Max、XR刘海屏问题</h4><p>起因：游戏内嵌内嵌H5页面，提供的webview容器是全屏的，所以H5页面要处理以上设备的刘海问题【烦】。</p><p>尺寸了解我这里就不写了，尺寸问题我就不写了，<a href="https://blog.csdn.net/qq_33608748/article/details/82769570" target="_blank" rel="noopener">顶楼电梯</a></p><p>iPhone X 配备一个覆盖整个手机的全面屏,顶部的“刘海”突出来使得网站被限制在一个“安全区域”,在两侧边缘会出现白条儿。移除这个白条儿也不难,给 body 设置一个 background-color 就可以搞定。</p><p>但是我们内嵌的游戏页面背景色有时候不好设置背景色为纯色，另一种方法就是添加 viewport-fit=cover meta 标签,将整个网站扩展到整个屏幕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, viewport-fit=cover&quot;&gt;</span><br></pre></td></tr></table></figure><p>iPhone XS等手机还未发布之前，我们也是跟着学做已经做一些兼容来搞定iPhoneX。</p><p>这里只是横屏代码，竖屏同理；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var isIPhoneX = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 375 &amp;&amp; window.screen.width === 812;</span><br></pre></td></tr></table></figure><p>这里我们判断如果是iPhone X，把顶部增加高度30px的容器垫高，避开刘海头区域，各种方式都可以padding-left、absolute、margin-left。。。你能想到的方法都可以，这样标题正好避开刘海头。</p><p>因为自己当时还没有用iPhone X，只知道iPhone X有刘海头，不知道其他细节问题。</p><p>又到一年一度的9月份，苹果发布了3X机系列，有同事在Mac下的iPhone模拟器访问，发现这个页面iPhone XS Max下有问题。看了一下上面文章发现尺寸不一样，当初只判断了iPhone X加垫高，其他几个机型都未判断，所以就很自然的写了新机型，加上判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// iPhone X、iPhone XS</span><br><span class="line">var isIPhoneX = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 375 &amp;&amp; window.screen.width === 812;</span><br><span class="line">// iPhone XS Max</span><br><span class="line">var isIPhoneXSMax = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 414 &amp;&amp; window.screen.width === 896;</span><br><span class="line">// iPhone XR</span><br><span class="line">var isIPhoneXR = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 2 &amp;&amp; window.screen.height === 414 &amp;&amp; window.screen.width === 896;</span><br></pre></td></tr></table></figure><p>原来代码是if(isIPhoneX)垫高，现在改成if(isIPhoneX || isIPhoneXSMax || isIPhoneXR)垫高。</p><p>这里有个坑，官方提供的安全区域代码constant(safe-area-inset-top) env(safe-area-inset-top)，使用后都在刘海头下面，如图（黑灰色区域状态栏）：</p><p><img src="http://ons.me/wp-content/uploads/2018/10/4.jpg" alt=""></p><p>当初没有用安全区域代码，一方面是因为页面有悬浮容器，会悬浮到安全区域外部，兼容页面正文麻烦，另一方面就是正文内容靠下，离刘海头有一段距离，感觉太丑干脆不用。</p><p>总结：依旧不用安全区域代码，如果要做刘海头，if(isIPhoneX || isIPhoneXSMax || isIPhoneXR) 垫高44px。</p><p>备注：iPhone X、iPhone XS、iPhone XS Max刘海头高度30px，iPhone XR刘海头高度33px。本文提到的30px、33px、44px，均为initial-scale=1下，px是在通用属性下，用rem写页面的请自行转换。设计稿像素应该都需要乘以2倍或3倍。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;h4 id=&quot;一次活动页面发现的iPhone-X、XS、XS-Max、XR刘海屏问题&quot;&gt;&lt;a href=&quot;#一次活动页面发现的iPhone-X、XS、XS
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="移动端" scheme="http://cansolve.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git 使用经验分享</title>
    <link href="http://cansolve.cn/2018/10/07/daily9/"/>
    <id>http://cansolve.cn/2018/10/07/daily9/</id>
    <published>2018-10-07T01:05:40.000Z</published>
    <updated>2018-12-20T08:19:53.780Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>Git 是分布式版本控制.每一台用户终端都可以充当中央仓库的角色,镜像整个仓库。 Git 主要对提交的全部文件制作一个快照并保存这个快照的索引，所以高效。</p><h3 id="Git开发流程"><a href="#Git开发流程" class="headerlink" title="Git开发流程"></a>Git开发流程</h3><p>Git开发过程中牵涉到：工作区、暂存区、仓库（本地仓库和远程仓库）</p><h3 id="Git-本地仓库常用操作"><a href="#Git-本地仓库常用操作" class="headerlink" title="Git 本地仓库常用操作"></a>Git 本地仓库常用操作</h3><ol><li>添加与删除暂存区操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git add 将文件加入到暂存区域</span><br><span class="line">git add . 添加当前目录的所有文件到暂存区</span><br><span class="line">git add [dir] 添加指定文件或文件夹到暂存区</span><br><span class="line">git add [file1] [file2] ... 添加指定文件到暂存区</span><br><span class="line">git add ./*.java 支持正则表达式</span><br><span class="line">git rm 删除文件.</span><br><span class="line">git rm [file1] [file2] 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">git rm --cached [file] 删除暂存索引, 保留文件, 即恢复成untracked状态，并且将这次删除放入暂存区（已跟踪）</span><br></pre></td></tr></table></figure><ol start="2"><li>提交本地库操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit 将暂存区域的文件提交到版本库</span><br><span class="line">git commit --amend -m [message] 使用一次新的commit，替代上一次提交。如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">git commit -a 则将已跟踪但未暂存的文件和已跟踪且已暂存的文件一起提交</span><br></pre></td></tr></table></figure><ol start="3"><li>本地分支操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout [branch] 切换分支</span><br><span class="line">git checkout -b [branch] 创建并且切换分支</span><br><span class="line">git checkout master file_name 放弃当前对文件file_name的修改，用本地库当前分支的文件进行替换</span><br><span class="line">git checkout commit_id file_name 取文件file_name的 在commit_id是的版本。</span><br></pre></td></tr></table></figure><ol start="4"><li>分支合并操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git merge [branch] 合并指定分支到当前分支，并且提交版本库，把分支的commit log带到新分支</span><br><span class="line">git merge [branch] --squash 合并指定分支到当前分支，不移动HEAD，不提交。需要进行一次额外的 git commit 来.带来好处不会把分支的 commit 记录带到新分支来。</span><br><span class="line">git merge [master] [branch] 将[master]合并到[branch] 分支</span><br><span class="line">git reset --hard HEAD 可以用此来撤销合并，其实就是回滚合并前的状态</span><br><span class="line">git cherry-pick [commit] 选择一个commit，合并进当前分支，用在部分功能合并</span><br></pre></td></tr></table></figure><h3 id="Git-远程仓库常用操作"><a href="#Git-远程仓库常用操作" class="headerlink" title="Git 远程仓库常用操作"></a>Git 远程仓库常用操作</h3><p>1.提交到远程库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br><span class="line">git push origin 当前分支与远程分支之间存在追踪关系（git clone，或手动建立 git branch --set-upstream master origin/next），则本地分支和远程分支都可以省略。</span><br><span class="line">git push 当前分支只有一个追踪分支，那么远程别名都可以省略</span><br></pre></td></tr></table></figure><p>2.取回远程仓库的变更但并不自动合并当前的工作分支（fetch）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master 取回远程 origin 的 master 分支变更该命令经常与 git checkout 搭配使用，用来获取远程仓库的分支</span><br></pre></td></tr></table></figure><p>3.获取更新 并且合并当前分支（pull）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull (= git fetch + git merge)</span><br><span class="line"> git pull 命令相当于 git fetch + git merge, 即从远程仓库中拉取所有你本地仓库中还没有的数据, 并自动合并到当前工作分支.</span><br></pre></td></tr></table></figure><h3 id="开发中常用"><a href="#开发中常用" class="headerlink" title="开发中常用"></a>开发中常用</h3><p>一. 获取远程分支，进入分支开发功能,开发完后合并主干，最后提交主版本到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1 git remote show origin （查看远程分支情况）</span><br><span class="line">    </span><br><span class="line">2 git fetch origin new_branch (获取远程分支的变更到本地仓库)</span><br><span class="line">    </span><br><span class="line">3 git checkout new_branch （切换分支new_branch进行开发）</span><br><span class="line">    </span><br><span class="line">4 开发相关功能文件</span><br><span class="line">    </span><br><span class="line">5 git add file</span><br><span class="line">    </span><br><span class="line">6 git commit</span><br><span class="line">    </span><br><span class="line">7 git checkout master （切换到主干）</span><br><span class="line">    </span><br><span class="line">8 git merge new_branch (把new_branch合并到当前的所在分支)</span><br><span class="line">    </span><br><span class="line">9 git push origin master</span><br><span class="line">    </span><br><span class="line">10 git branch -d new_branch (删除分支)</span><br><span class="line">    </span><br><span class="line">11 git branch (查看当前分支情况，确认删除)</span><br></pre></td></tr></table></figure><p>二. 文件修改后想还原到上次提交的状态（不保留修改内容）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout  (文件未提交到暂存区用法)</span><br><span class="line">git checkout HEAD  （如提交到暂存区执行该命令后，不保存暂存区）</span><br><span class="line">git reset --hard HEAD （如提交到暂存区执行该命令后，不保存暂存区）</span><br></pre></td></tr></table></figure><p>三. 撤销上一次提交本地仓库的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 git log (查看提交版本信息) git reset 前一个SHA值（7位数）（撤销commit，会保留提交前的修改内容）</span><br><span class="line">    </span><br><span class="line">2 git reset --soft HEAD^1 退到commit前，保留stage（暂存区）和提交前修改内容</span><br><span class="line">    </span><br><span class="line">3 git reset --mixed HEAD^1 退到commit前，保留提交前修改内容（默认）</span><br><span class="line">    </span><br><span class="line">4 git reset --hard HEAD^1退到commit前且恢复到未修改时内容（内容退回到上次commit时的状态）</span><br><span class="line">    </span><br><span class="line">5 git reset SHA值  让单个文件退回到指定版本</span><br></pre></td></tr></table></figure><p>四. 回滚区别(reset与revert)</p><p>共同点：都可用回滚</p><p>不同点：<br>reset 可回滚到之前某个提交（可能是批量回滚），删除被回滚的log，另外不可回滚到已 push 过的的提交，否则回滚后当前版本低于远程版本，被禁止提交。<br>使用场景：对本地仓库中未push的提交的回滚<br>revert 撤销一个提交的同时会创建一个新的提交<br>可用于回滚被 push 过的提交。被回滚的版本git log不会被删除。<br>使用场景：你在追踪一个 bug，然后你发现它是由一个提交造成的，这时候撤销就很有用。与其说自己去修复它，然后提交一个新的快照，不如用 git revert，它帮你做了所有的事情。</p><p>五. 当前文件与本地仓库文件比较区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff 比较的是工作目录树与暂存区之间的区别</span><br><span class="line">git diff --staged 比较的是暂存区和版本库最后一个版本的区别。</span><br><span class="line">git diff HEAD 比较的是工作目录树（包括暂存的和未暂存的修改）与版本库最后一个版本的差别。</span><br></pre></td></tr></table></figure><p>六. 保持本地仓库与远程仓库分支同步的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 git remote show origin （显示本地与远程仓库所有分支情况）如远程分支删除后，本地还有，用 git branch -a 是看不出远程仓库分支已经被删除</span><br><span class="line">    </span><br><span class="line">2 git remote prune origin --dry-run （该命令显示本地无效分支）</span><br><span class="line">    </span><br><span class="line">3 git remote prune origin （同步本地与远程仓库变更（所有分支），执行后可用git branch -a查看）</span><br><span class="line">    </span><br><span class="line">4 git fetch origin [branch]</span><br></pre></td></tr></table></figure><p>七. Git 客户端工具</p><p>可视化操作工具推荐使用：<a href="[https://www.sourcetreeapp.com/](https://www.sourcetreeapp.com/">Sourcetree</a>)</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;版本控制&quot;&gt;&lt;a href=&quot;#版本控制&quot; class=&quot;headerlink&quot; title=&quot;版本控制&quot;&gt;&lt;/a&gt;版本控制&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="git" scheme="http://cansolve.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的this</title>
    <link href="http://cansolve.cn/2018/09/22/daily5/"/>
    <id>http://cansolve.cn/2018/09/22/daily5/</id>
    <published>2018-09-22T08:11:23.000Z</published>
    <updated>2018-12-20T02:54:25.567Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><p>原文链接：<a href="https://flaviocopes.com/javascript-this/" target="_blank" rel="noopener">flaviocopes.com</a></p><p>翻译：我可是兔子</p><p><code>this</code>在不同的地方被调用有不同的值。</p><p>不知道这些细节可能会导致很多头疼的问题, 所以你不妨花5分钟的时间来了解一下这些坑。</p><h2 id="this在严格模式下"><a href="#this在严格模式下" class="headerlink" title="this在严格模式下"></a><code>this</code>在严格模式下</h2><p>除了在声明的对象内被调用,<code>this</code>在<strong>严格模式下</strong>永远是<code>undefined</code>。</p><p>注意我提到的是严格模式。如果不是在严格模式下 (在js的头部，你没有明确的添加<code>&#39;use strict&#39;</code>关键字 ), 那么你就处在非严格模式的状态下,<code>this</code>在这个环境下， 除了我下面提到的特殊案例外 ，this指代的是全局对象的值。</p><p>在浏览器的上下文环境中，这个值就是<code>window</code>。</p><h2 id="在函数方法中的this"><a href="#在函数方法中的this" class="headerlink" title="在函数方法中的this"></a>在函数方法中的<code>this</code></h2><p>方法就是以函数形式附属于一个对象。</p><p>函数可以有不同的声明形式。</p><p>下面就是其中的一种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  maker: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;,</span><br><span class="line"></span><br><span class="line">  drive() &#123;</span><br><span class="line">    console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.drive()</span><br><span class="line">//Driving a Ford Fiesta car!</span><br></pre></td></tr></table></figure><p>在这个例子中，使用了常规的函数声明的形式,<code>this</code>自动绑定为car这个对象。</p><p>注意: 上面的函数声明是<code>drive: function() {</code>…这样声明的缩写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  maker: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;,</span><br><span class="line"></span><br><span class="line">  drive: function() &#123;</span><br><span class="line">    console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面的例子一样的指代:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  maker: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.drive = function() &#123;</span><br><span class="line">  console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.drive()</span><br><span class="line">//Driving a Ford Fiesta car!</span><br></pre></td></tr></table></figure><p>在同样的语境下，使用箭头函数来声明函数，<code>this</code>的指代是不一样的，它属于词法（静态）绑定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  maker: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;,</span><br><span class="line"></span><br><span class="line">  drive: () =&gt; &#123;</span><br><span class="line">    console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.drive()</span><br><span class="line">//Driving a undefined undefined car!</span><br></pre></td></tr></table></figure><h2 id="使用箭头函数"><a href="#使用箭头函数" class="headerlink" title="使用箭头函数"></a>使用箭头函数</h2><p>你不能在箭头函数中像其他正常的函数声明形式那样给函数绑定一个值来改变this的值。</p><p>导致这个的主要原因是箭头函数的工作原理。<code>this</code>在箭头函数中是<strong>词法绑定</strong>的, 也就是说它的值仅取决于它在哪个对象下被定义。</p><h2 id="明确地传递一个对象来改变this的值"><a href="#明确地传递一个对象来改变this的值" class="headerlink" title="明确地传递一个对象来改变this的值"></a>明确地传递一个对象来改变<code>this</code>的值</h2><p>JavaScript提供了一些方法来映射this所指代的对象，从而得到你想要的值。</p><p>在<strong>函数声明</strong>的阶段，使用<code>bind()</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  maker: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const drive = function() &#123;</span><br><span class="line">  console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)</span><br><span class="line">&#125;.bind(car)</span><br><span class="line"></span><br><span class="line">drive()</span><br><span class="line">//Driving a Ford Fiesta car!</span><br></pre></td></tr></table></figure><p>你可以绑定一个已定义的对象来改变<code>this</code>的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  maker: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;,</span><br><span class="line"></span><br><span class="line">  drive() &#123;</span><br><span class="line">    console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const anotherCar = &#123;</span><br><span class="line">  maker: &apos;Audi&apos;,</span><br><span class="line">  model: &apos;A4&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.drive.bind(anotherCar)()</span><br><span class="line">//Driving a Audi A4 car!</span><br></pre></td></tr></table></figure><p>使用<code>call()</code>或者<code>apply()</code>, 在<strong>函数调用</strong>阶段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  maker: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const drive = function(kmh) &#123;</span><br><span class="line">  console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car at $&#123;kmh&#125; km/h!)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drive.call(car, 100)</span><br><span class="line">//Driving a Ford Fiesta car at 100 km/h!</span><br><span class="line"></span><br><span class="line">drive.apply(car, [100])</span><br><span class="line">//Driving a Ford Fiesta car at 100 km/h!</span><br></pre></td></tr></table></figure><p>第一个传递给<code>call()</code>或者<code>apply()</code>的参数是新的<code>this</code>所指代的值。 call() 和 apply()两个函数的差异在于第二个参数，apply() 接受的是一个数组来作为它的参数，而call() 函数接受的是一串参数列表。</p><h2 id="DOM事件处理函数的特殊案例"><a href="#DOM事件处理函数的特殊案例" class="headerlink" title="DOM事件处理函数的特殊案例"></a>DOM事件处理函数的特殊案例</h2><p>在浏览器事件处理函数的时候,<code>this</code>指代的是HTML对象，像下面的这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&apos;#button&apos;).addEventListener(&apos;click&apos;, function(e) &#123;</span><br><span class="line">  console.log(this) //HTMLElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但你可以使用bind() 函数来改变this值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&apos;#button&apos;).addEventListener(</span><br><span class="line">  &apos;click&apos;,</span><br><span class="line">  function(e) &#123;</span><br><span class="line">    console.log(this) //Window if global, or your context</span><br><span class="line">  &#125;.bind(this)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;原文链接：&lt;a href=&quot;https://flaviocopes.com/javascript-this/&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="分享" scheme="http://cansolve.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="js" scheme="http://cansolve.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>移动端滚动事件overflow-y:scroll使用心得</title>
    <link href="http://cansolve.cn/2018/09/18/daily4/"/>
    <id>http://cansolve.cn/2018/09/18/daily4/</id>
    <published>2018-09-18T07:45:43.000Z</published>
    <updated>2018-12-18T08:06:30.332Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><blockquote><p>作者：夏大师</p><p><a href="https://www.cnblogs.com/xiahj/p/8036419.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiahj/p/8036419.html</a></p></blockquote><h2 id="1-webkit-overflow-scrolling-touch是什么？"><a href="#1-webkit-overflow-scrolling-touch是什么？" class="headerlink" title="1. -webkit-overflow-scrolling:touch是什么？"></a>1. -webkit-overflow-scrolling:touch是什么？</h2><p>MDN上是这样定义的：</p><blockquote><p><code>-webkit-overflow-scrolling</code>属性控制元素在移动设备上是否使用滚动回弹效果.<br><code>auto</code>: 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。<br><code>touch</code>: 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。</p></blockquote><p>在移动端上，在你用<code>overflow-y:scorll</code>属性的时候，你会发现滚动的效果很木，很慢，这时候可以使用<code>-webkit-overflow-scrolling:touch</code>这个属性，让滚动条产生<strong>滚动回弹</strong>的效果，就像ios原生的滚动条一样流畅。</p><h2 id="2-解决safari布局抖动的例子"><a href="#2-解决safari布局抖动的例子" class="headerlink" title="2. 解决safari布局抖动的例子"></a>2. 解决safari布局抖动的例子</h2><p><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103503613-582028000.png" alt=""></p><p><strong>想实现一个布局为header、main、bottom的布局，其中头部和底部通过fixed固定，中间部分通过滚动条滑动。</strong></p><p>如果目的是实现只要中间的内容超过屏幕高度时，中间内容会自动滚动的效果的话，<code>main</code>部分加上上下的<code>padding</code>，然后不需要自己添加任何滚动条属性，当超出高度时，<code>body</code>会自动产生滚动条。这样我们的目的其实是实现了的。</p><p>但是在<strong>safari</strong>上，当超出高度，页面往下滑时，浏览器底部的工具栏<strong>会随着页面一起晃动</strong>（向下滚动时会拉起底部工具栏），造成了很不好的体验。所以我们想在中间的<code>main</code>部分加一个<strong>独立的滚动条</strong>。</p><h3 id="2-1-方案一"><a href="#2-1-方案一" class="headerlink" title="2.1 方案一"></a>2.1 方案一</h3><p>在main上使用fixed定位，加上overflow-y属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.main &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 50px;</span><br><span class="line">    bottom: 50px;</span><br><span class="line">    overflow-y: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过不推荐这个fixed方案，因为页面偶尔卡住不动，下面说到了这个问题。</p><h3 id="2-2-方案二"><a href="#2-2-方案二" class="headerlink" title="2.2 方案二"></a>2.2 方案二</h3><p>中间的<strong>main不设定位</strong>，<strong>高度100%</strong>，再<strong>padding头部和尾部</strong>，</p><p>其中头部和底部的定位设为<code>absolute</code>会比设为<code>fixed</code>体验更好（况且fix布局在移动端本来就有各种各样的问题，还是尽量避开:) ）。</p><p>大致代码如下，仍是<code>overflow-y</code>和<code>-webkit-overflow-scrolling</code>，重点在于中间部分依照文本流布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html, body &#123;</span><br><span class="line"> height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">main &#123;</span><br><span class="line">    padding: 50px 0;</span><br><span class="line">    height: 100%;</span><br><span class="line">    overflow-y: scroll;</span><br><span class="line">    -webkit-overflow-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-探究-webkit-overflow-scrolling-touch偶尔卡住或不能滑动的bug"><a href="#3-探究-webkit-overflow-scrolling-touch偶尔卡住或不能滑动的bug" class="headerlink" title="3. 探究-webkit-overflow-scrolling:touch偶尔卡住或不能滑动的bug"></a>3. 探究-webkit-overflow-scrolling:touch偶尔卡住或不能滑动的bug</h2><p>-webkit-overflow-scrolling:touch这个属性真的是各种坑，我研究这个属性已经大半年了，还没有发现能够在safari上完美使用无bug的例子。</p><blockquote><p>最常见的例子就是，</p><ul><li><p>在safari上，使用了<code>-webkit-overflow-scrolling:touch</code>之后，页面偶尔会卡住不动。</p></li><li><p>在safari上，点击其他区域，再在滚动区域滑动，滚动条无法滚动的bug。</p></li><li><p>通过动态添加内容撑开容器，结果根本不能滑动的bug。</p></li></ul></blockquote><p>在网上也看到了一些人在问这个问题，不过不多，国外倒是讨论的更多一点，描述如下。</p><p><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103539816-1960538934.png" alt=""><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103539816-1960538934.png" alt=""></p><p>偶尔卡住的问题，解决方案网上众说纷纭，遇到了很多相同的说法，比如如果卡住不动的话，就加一个<code>z-index</code>，就能解决该问题的说法。</p><p>在试了很多次之后，这种说法没有一次解决过这个问题。这个说法能够传播出来，可能是使用者当时在使用的时候遇到了<code>-webkit-overflow-scrolling:touch</code>点透或者层级的问题。所以该方案不具有适用性。</p><p>所以这个东西真的让我很苦恼了很久，以致于那段时间所有的滚动条不是通过body自己滚动，就是使用iScroll这样的库，繁琐地让我几乎想要放弃移动web，拥抱hybrid，不过在stackoverflow潜水了很久之后，总结了以下几种解决方案：</p><h3 id="3-1-保证使用了该属性的元素上没有设置定位"><a href="#3-1-保证使用了该属性的元素上没有设置定位" class="headerlink" title="3.1 保证使用了该属性的元素上没有设置定位"></a>3.1 保证使用了该属性的元素上没有设置定位</h3><p>如果出现偶尔卡住不动的情况，那么在使用该属性的元素上<strong>不设置定位</strong>或者手动设置定位为<strong><code>static</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: static</span><br></pre></td></tr></table></figure><p>这样会解决<strong>部分</strong>因为定位(relative、fixed、absolute)导致的页面偶尔不能滚动的bug。</p><blockquote><p>但是滑动到顶部继续手指往下滑，或者到底部继续往上滑，还是会触发卡住的问题（其实是整个页面上下回弹），说他算bug，其实就是ios8以上的特性，如果滚动区域大一点，用户不会觉得这是bug，如果小了，用户会不知道发生了什么而卡住了。<br>视频在这，有梯子的同学可以看一看<a href="https://www.youtube.com/watch?v=MkAVYbO_joo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=MkAVYbO_joo</a>。</p></blockquote><h3 id="3-2-如果添加动态内容页面不能滚动，让子元素height-1"><a href="#3-2-如果添加动态内容页面不能滚动，让子元素height-1" class="headerlink" title="3.2 如果添加动态内容页面不能滚动，让子元素height+1"></a>3.2 如果添加动态内容页面不能滚动，让子元素height+1</h3><p>如果在<code>-webkit-overflow-scrolling:touch</code>属性的元素上，想通过<strong>动态添加内容</strong>来撑开容器，触发滚动，是有bug 的，页面是会卡住不动的。</p><p>国内没有人讨论这个问题，国外倒是很多，例如下面的描述：</p><p><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103630754-707308829.png" alt=""><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103630754-707308829.png" alt=""></p><p>收集了很多资料，用了之后，下面的方法真正的解决了我的问题，真是直呼神奇，方案如下图：</p><p>图一：</p><p><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103636379-1667026180.png" alt=""><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103636379-1667026180.png" alt=""></p><p>图二：</p><p><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103640113-1071673514.png" alt=""><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103640113-1071673514.png" alt=""></p><p>方法就是在<code>webkit-overflow-scrolling:touch</code>属性的<strong>下一层子元素</strong>上，将<strong>height加1%或1px</strong>。从而<strong>主动触发scrollbar</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main-inner &#123;</span><br><span class="line">    min-height: calc(100% + 1px)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以直接加伪元素上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main:after &#123;</span><br><span class="line">    min-height: calc(100% + 1px)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案不得不说真的好用。。</p><p>当然还有其他方案，不过要写js或者jq了，麻烦。</p><h3 id="3-3-为什么会有卡住不动的这个bug"><a href="#3-3-为什么会有卡住不动的这个bug" class="headerlink" title="3.3 为什么会有卡住不动的这个bug"></a>3.3 为什么会有卡住不动的这个bug</h3><p>这个bug产生于ios8以上（不十分肯定，但在ios5~7上需要手动使用translateZ(0)打开硬件加速）</p><p><code>Safari</code>对于<code>overflow-scrolling</code>用了原生控件来实现。对于有<code>-webkit-overflow-scrolling</code>的网页，会创建一个<code>UIScrollView</code>，提供子<code>layer</code>给渲染模块使用。</p><p>我想说作为一个苦逼的前端只能解决到这了。</p><h2 id="4-webkit-overflow-scrolling-touch的其他坑"><a href="#4-webkit-overflow-scrolling-touch的其他坑" class="headerlink" title="4. -webkit-overflow-scrolling:touch的其他坑"></a>4. -webkit-overflow-scrolling:touch的其他坑</h2><p>除此之外，这个属性还有很多bug，包括且不限于以下几种：</p><blockquote><ul><li><p>滚动中 scrollTop 属性不会变化</p></li><li><p>手势可穿过其他元素触发元素滚动</p></li><li><p>滚动时暂停其他 transition</p></li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;blockquote&gt;&lt;p&gt;作者：夏大师&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiahj/p/8036419.h
      
    
    </summary>
    
      <category term="分享" scheme="http://cansolve.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="移动端" scheme="http://cansolve.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>基于react + bootstrap 的 react-admin</title>
    <link href="http://cansolve.cn/2018/09/14/daily3/"/>
    <id>http://cansolve.cn/2018/09/14/daily3/</id>
    <published>2018-09-14T07:52:19.000Z</published>
    <updated>2018-12-18T09:16:49.973Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><p><img src="/2018/09/14/daily3/WechatIMG10.jpeg" alt="效果图 1"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此 react-admin 项目是基于 bootstrap-ace 框架之上，用 react 全家桶 + bootstrap 的进行再次开发的，项目已经开源，项目地址在 github 上。</p><p>框架效果预览 <a href="http://www.pydyun.com/other/ace/index.html" target="_blank" rel="noopener">http://www.pydyun.com/other/ace/index.html</a><br>github地址 <a href="https://github.com/cansolve/react-manage" target="_blank" rel="noopener">github</a></p><h2 id="1-后台管理主要项目结构"><a href="#1-后台管理主要项目结构" class="headerlink" title="1. 后台管理主要项目结构"></a>1. 后台管理主要项目结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">demo //项目名</span><br><span class="line">  -- dist  //预编译，自动构建之后会生成的文件，默认初始化是没有当前这个文件</span><br><span class="line">  -- asserts  //静态资源目录，css,font,image</span><br><span class="line">  -- public  //html模板文件</span><br><span class="line">  -- webpack  //webpack配置文件</span><br><span class="line">    -- webpack.base.config.js  //公用</span><br><span class="line">    -- webpack.dev.config.js  //开发环境</span><br><span class="line">    -- webpack.prod.config.js  //生产环境</span><br><span class="line">  -- src  //js编写文件</span><br><span class="line">      -- index.js  // 初始化js</span><br><span class="line">      -- module  // 基础UI模块目录</span><br><span class="line">      -- tools   // js方法工具库目录</span><br><span class="line">      -- action     // action 目录</span><br><span class="line">      -- component  // 对应的模块 目录</span><br><span class="line">      -- dispatch   // dispatch 目录</span><br><span class="line">      -- reducers   // reducers 目录</span><br><span class="line">      -- index.js   // 前端渲染</span><br><span class="line">      -- router.js  // 前端路由</span><br><span class="line">      -- store.js   // store 文件 </span><br><span class="line">  -- .babelr   //babel的校验文件</span><br><span class="line">  -- .eslintrc  //js编写校验配置文件</span><br><span class="line">  -- .gitignore  //git过滤文件</span><br><span class="line">  -- package.json  //node 安装包文件</span><br><span class="line">  -- README.md   //readme 文件</span><br></pre></td></tr></table></figure><h2 id="2-本地必须要有node和git环境"><a href="#2-本地必须要有node和git环境" class="headerlink" title="2. 本地必须要有node和git环境"></a>2. 本地必须要有<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node</a>和<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>环境</h2><ul><li>webpack 4</li><li>bootstrap + ace</li><li>react 16</li><li>react-router 4</li><li>redux 3</li><li>babel</li><li>promise</li><li>async + await</li></ul><hr><h2 id="3-项目开始"><a href="#3-项目开始" class="headerlink" title="3. 项目开始"></a>3. 项目开始</h2><p>先在对应的git先创建git仓库，比如：XX管理后台 <code>demo</code> 项目，然后 <code>git clone</code> 到本来的开发环境，进入当前项目目录，代码如入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone ssh://git@github.com:cansolve/react-manage.git</span><br><span class="line">cd demo</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd demo</span><br><span class="line">git remote add origin ssh://git@github.com:cansolve/react-manage.git</span><br></pre></td></tr></table></figure><p>这时，通过git来添加前端开发初始化的工程目录，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add base ssh://git@github.com:cansolve/react-manage.git</span><br><span class="line">git pull base master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><p>然后可以推送到开发项目上面去，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &apos;前端项目初始化&apos;</span><br><span class="line">git push origin demo</span><br></pre></td></tr></table></figure><p>到此，你的 <code>demo</code> 项目前端搭建和初始化已完毕，接下来你就可以开始 前端开发 了</p><hr><h2 id="4-本地项目开始"><a href="#4-本地项目开始" class="headerlink" title="4. 本地项目开始"></a>4. 本地项目开始</h2><p>先安装编译第三方的依赖包<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//如果开发之前本地没有对应的server服务器，也可以用node搭个server服务器，默认是8080端口:127.0.0.1:8080,如果有的话，直接跳过这一步</span><br><span class="line">npm install -g http-server</span><br><span class="line">http-server -c-1</span><br></pre></td></tr></table></figure><h3 id="4-1-开发环境"><a href="#4-1-开发环境" class="headerlink" title="4.1 开发环境"></a>4.1 开发环境</h3><p>生产环境中开发监听对应的文件修改<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure><p></p><h3 id="4-2-生产环境"><a href="#4-2-生产环境" class="headerlink" title="4.2 生产环境"></a>4.2 生产环境</h3><p>压缩生产对应的线上文件，生产 <code>html</code> <code>css</code> <code>image</code> <code>font</code> <code>js</code> 文件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="4-3-前端的升级和更新"><a href="#4-3-前端的升级和更新" class="headerlink" title="4.3 前端的升级和更新"></a>4.3 前端的升级和更新</h3><p>后续当前项目的前端库升级，bug修复，版本更新，直接可以通过命令来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull base master</span><br></pre></td></tr></table></figure><p>如有改动跟本地开发的导致冲突，请手动处理冲突文件，然后push到对应项目中去。</p><h2 id="5-项目组建介绍"><a href="#5-项目组建介绍" class="headerlink" title="5. 项目组建介绍"></a>5. 项目组建介绍</h2><h4 id="5-1-表格组建"><a href="#5-1-表格组建" class="headerlink" title="5.1 表格组建"></a>5.1 表格组建</h4><p><img src="/2018/09/14/daily3/WechatIMG9.jpeg" alt="效果图 2"><br>说明：这里表格已经写成组建形式，只需要传入对应的title及data <strong>后台获取数据</strong> 即可渲染成表格，对应的可以选择排序、勾选、包括给详情加a标签功能;</p><h4 id="5-2-分页组建"><a href="#5-2-分页组建" class="headerlink" title="5.2 分页组建"></a>5.2 分页组建</h4><p><img src="/2018/09/14/daily3/WechatIMG8.jpeg" alt="效果图 2"><br>说明：分页组建，点击传入对应页码，支持输入跳转;</p><h4 id="5-3-日历组建"><a href="#5-3-日历组建" class="headerlink" title="5.3 日历组建"></a>5.3 日历组建</h4><p><img src="/2018/09/14/daily3/WechatIMG7.jpeg" alt="效果图 2"><br>说明：日历时间选择组建，点击展示日期列表，选择传给后台为时间戳格式;</p><h4 id="5-4-下拉选择组建"><a href="#5-4-下拉选择组建" class="headerlink" title="5.4 下拉选择组建"></a>5.4 下拉选择组建</h4><p><img src="/2018/09/14/daily3/WechatIMG6.jpeg" alt="效果图 2"><br>说明：点击出现下拉框，支持搜索功能</p><h4 id="5-4-下拉选择【多选】组建"><a href="#5-4-下拉选择【多选】组建" class="headerlink" title="5.4 下拉选择【多选】组建"></a>5.4 下拉选择【多选】组建</h4><p><img src="/2018/09/14/daily3/WechatIMG5.jpeg" alt="效果图 2"><br>说明：点击出现下拉框，多选功能</p><h4 id="5-4-树组建"><a href="#5-4-树组建" class="headerlink" title="5.4 树组建"></a>5.4 树组建</h4><p><img src="/2018/09/14/daily3/WechatIMG4.jpeg" alt="效果图 2"><br>说明：传入对应的数据即可渲染成树</p><h4 id="5-4-双向选择组建"><a href="#5-4-双向选择组建" class="headerlink" title="5.4 双向选择组建"></a>5.4 双向选择组建</h4><p><img src="/2018/09/14/daily3/WechatIMG3.jpeg" alt="效果图 2"><br>说明：两边数据可以互通选择，支持一键全部选择，两边数据都支持搜索功能；</p><h5 id="具体使用api在组建里面已经写的比较详细，类似下图，再有不明白的可以联系我，一起进步；"><a href="#具体使用api在组建里面已经写的比较详细，类似下图，再有不明白的可以联系我，一起进步；" class="headerlink" title="具体使用api在组建里面已经写的比较详细，类似下图，再有不明白的可以联系我，一起进步；"></a>具体使用api在组建里面已经写的比较详细，类似下图，再有不明白的可以联系我，一起进步；</h5><p><img src="/2018/09/14/daily3/WechatIMG11.jpeg" alt="效果图 2"></p><h2 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h2><p>因为这是本人自己依据creat-react-app搭建的，跟公司项目目录还是有一定区别的，包括本人写代码的一些不好的地方还请多指正。<br>大神请绕道，放小弟一条生路，谢谢啦！！<br>本人公众号 <strong>码上关注</strong> 不定期分享一些前端知识，一起相互交流学习。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;img src=&quot;/2018/09/14/daily3/WechatIMG10.jpeg&quot; alt=&quot;效果图 1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="react" scheme="http://cansolve.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>前端自动化部署jenkins</title>
    <link href="http://cansolve.cn/2018/08/24/daily11/"/>
    <id>http://cansolve.cn/2018/08/24/daily11/</id>
    <published>2018-08-24T09:19:59.000Z</published>
    <updated>2018-12-24T10:24:03.553Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><p>一、jenkins工具的安装、卸载、启用</p><p>注意：安装jenkins必须先安装java sdk，同时安装好brew工具（<a href="http://brew.sh/index_zh-cn.html）" target="_blank" rel="noopener">http://brew.sh/index_zh-cn.html）</a></p><p>1、安装、卸载</p><p>（1）安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install jenkins</span><br></pre></td></tr></table></figure><p>（2）卸载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall jenkins</span><br></pre></td></tr></table></figure><p>2、启用</p><p>终端命令启动（仅对终端命令安装有效）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenkins</span><br></pre></td></tr></table></figure><p>开机自动启动：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sfv /usr/local/opt/jenkins<span class="comment">/*.plist ~/Library/LaunchAgents</span></span><br></pre></td></tr></table></figure><p><img src="/2018/08/24/daily11/WechatIMG19.jpeg" alt="WechatIMG19"></p><p>3、登录</p><p><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a></p><p>运行成功会在用户个人目录下新建.jenkins/文件夹<br>访问localhost:8080就能到达Jenkins首页</p><p><img src="/2018/08/24/daily11/WechatIMG18.jpeg" alt="WechatIMG18"><br>第一次需要从文件夹下获取生成的密码登录，复制粘贴</p><p><img src="/2018/08/24/daily11/WechatIMG14.jpeg" alt="WechatIMG14"></p><p>密码验证成功后进入页面，选择插件模式</p><p><img src="/2018/08/24/daily11/20180823112315256.png" alt="clipboard.png"><br>大家都是默认选第一个</p><p><img src="/2018/08/24/daily11/20180823112327328.png" alt="clipboard.png"><br><img src="/2018/08/24/daily11/20180823112343266.png" alt="clipboard.png"><br>稍等一会，插件安装好了进入用户登录界面，设定用户名、密码及邮箱。</p><p><strong>然后登陆就用你设置的用户名跟密码，记住哦！！</strong></p><p>配置项目的 jenkins job<br>1、在 jenkins 左边栏点击 “新建”， 输入 job 名称，选择 “构建一个自由风格的软件项目” 一项。点击 “OK”</p><p><img src="/2018/08/24/daily11/WechatIMG15.jpeg" alt="WechatIMG15"></p><p><img src="/2018/08/24/daily11/WechatIMG16.jpeg" alt="WechatIMG16"><br>2、进入 job ”配置“页面，点击 “General” 选项，配置名称和描述，我们用的github项目，那么勾选github并且填入项目地址</p><p><img src="/2018/08/24/daily11/WechatIMG20.jpeg" alt="WechatIMG20"><br>3、点击 “源码管理” 选项，配置项目的 git 仓库地址的需要构建的分支信息</p><p><img src="/2018/08/24/daily11/WechatIMG21.jpeg" alt="WechatIMG21"><br>4、点击 “构建触发器” 选项，配置 job 构建时机，勾选 “GitHub hook trigger for GITScm polling”，github hook 来触发 job 构建 ,这里没有暂时可以忽略<br><img src="/2018/08/24/daily11/WechatIMG22.jpeg" alt="WechatIMG22"></p><p>5、点击 “构建” 选项，再点击 “增加构建步骤”， 选择 “Execute shell”，配置构建命令。 如下，这里配置了 npm install、npm run unit、npm run build, 分别做安装依赖、测试、打包三件事。</p><p><img src="/2018/08/24/daily11/WechatIMG23.jpeg" alt="WechatIMG23"></p><p><strong>后续继续补充</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;一、jenkins工具的安装、卸载、启用&lt;/p&gt;&lt;p&gt;注意：安装jenkins必须先安装java sdk，同时安装好brew工具（&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="服务器" scheme="http://cansolve.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Eruda～一款移动端的调试神器</title>
    <link href="http://cansolve.cn/2018/06/27/daily14/"/>
    <id>http://cansolve.cn/2018/06/27/daily14/</id>
    <published>2018-06-27T11:20:08.000Z</published>
    <updated>2018-12-26T07:41:43.990Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><p>昨天介绍了一下抓包工具 <a href="https://cansolve.cn/2018/06/26/daily13/">Charles</a>的使用，今天再介绍一款移动端的调试面板；<br><strong>Eruda</strong>是什么？Eruda 是一个专为前端<strong>移动端</strong>、<strong>移动端</strong>设计的调试面板，类似<code>Chrome DevTools</code>的迷你版，其主要功能包括：捕获<code>console</code>日志、检查元素状态、显示性能指标、捕获XHR请求、显示<code>本地存储</code>和<code>Cookie</code>信息、浏览器特性检测等等。</p><p><strong>引用方式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">方式一 默认引入：</span><br><span class="line">&lt;script src=&quot;//cdn.jsdelivr.net/npm/eruda&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;eruda.init();&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">方式二 动态加载：</span><br><span class="line">__DEBUG__ &amp;&amp; loadJS(&apos;http://cdn.jsdelivr.net/eruda/1.0.5/eruda.min.js&apos;, ()=&gt;&#123;</span><br><span class="line"> eruda.init();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">方式三 指定场景加载：</span><br><span class="line">;(function () &#123;</span><br><span class="line"> var src = &apos;http://cdn.jsdelivr.net/eruda/1.0.5/eruda.min.js&apos;;</span><br><span class="line"> if (!/eruda=true/.test(window.location) &amp;&amp; localStorage.getItem(&apos;active-eruda&apos;) != &apos;true&apos;) return;</span><br><span class="line"> document.write(&apos;&lt;scr&apos; + &apos;ipt src=&quot;&apos; + src + &apos;&quot;&gt;&lt;/scr&apos; + &apos;ipt&gt;&apos;);</span><br><span class="line"> document.write(&apos;&lt;scr&apos; + &apos;ipt&gt;eruda.init();&lt;/scr&apos; + &apos;ipt&gt;&apos;);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">方式四 npm：</span><br><span class="line"> npm install eruda --save</span><br><span class="line">…… 加载的方式很多</span><br></pre></td></tr></table></figure><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li><p><strong>eruda</strong>能帮我们解决这个问题；所有的日志、错误都能帮我们捕获到，不要再去因为调试打印一堆的alert</p></li><li><p>甚至我们还能像<code>chrome</code>,直接在控制台执行js代码；</p></li></ul><p><img src="/2018/06/27/daily14/13453575-fe620ea0a6bcbbdd.png" alt="微信开发必备h5开发调试，利器Eruda"></p><h4 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h4><ul><li><p><strong>eruda</strong>它没有在PC端这么直观，但也因为在移动端展示的方式局限性，</p></li><li><p>它能把每一个父节点下的每一个子节点全部列出来；你点击某个子节点时，列出当前节点全部的属性、样式、盒子模型等；</p></li><li><p>查看标签内容及属性；查看Dom上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看Dom上绑定的各类事件。</p></li><li><p>甚至也能使用<code>Plugins</code>插件，做到跟PC端一样，形成 dom tree；</p></li></ul><p><img src="/2018/06/27/daily14/13453575-0c5fda5cb56478b9.png" alt="使用神器eruda进行移动端调试"><br><img src="/2018/06/27/daily14/13453575-94ce6ec7945edc32.png" alt="PC、Mobile调试节点对比"></p><h4 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h4><ul><li><p>现在的项目大多都是前后端分享的形式了，前端处理的业务越来越多、各种请求资源等；</p></li><li><p>干的越多承担责任也越多、锅也越多，又大又平的那种哦～</p></li><li><p>所以<strong>Network</strong>的必要性不言而喻，它能捕获请求，查看发送数据、返回头、返回内容等信息，它对于我们平时前后端联调出现的问题定位是有很大帮助的，比如：后端说你请求参数少了，前端你看了代码逻辑没有问题，但在手机上就是调不通，Network 能很直接明了的看到你请求带了什么。</p></li></ul><p><img src="/2018/06/27/daily14/13453575-15477c54341c764c.png" alt="今天的主角男一号是：Eruda！vConsole的同类。,PC、eruda数据请求对比"></p><h4 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h4><ul><li><p>它跟 Chrome Devtools 里的<code>Application</code>+<strong>Source</strong>,两者的结合体；</p></li><li><p>Resources 它能查看 Cookie、localStorage、sessionStorage等信息，并且还能执行清除操作（Application）；</p></li><li><p>它还查看当前页面加载脚本及样式文件；查看页面加载过的图片等资源（Source）；</p></li><li><p>好吧，感觉说的再多，也不如上图直接：</p><p><img src="/2018/06/27/daily14/13453575-c550eeb1b547abb3.png" alt="Resources功能分析"></p></li></ul><h4 id="Sources-Info"><a href="#Sources-Info" class="headerlink" title="Sources/Info"></a>Sources/Info</h4><ul><li><p>Sources：查看页面源码；格式化html，css，js代码及json数据。</p></li><li><p>Info：主要输出URL信息及User Agent；及其他的一些手机系统信息，同时也支持自定义输出内容哦。</p></li></ul><p><img src="/2018/06/27/daily14/13453575-56be572d3b102124.png" alt="Resources功能分析"></p><h2 id="高阶用法"><a href="#高阶用法" class="headerlink" title="高阶用法"></a>高阶用法</h2><ul><li><p>以上刚才介绍的是它的一些基本的功能，也是我自己在工作中用的较多的；</p></li><li><p>最近发现新版本功能要强大不少，之前一直用的<code>1.0.5</code>，好像是没有插件这一项的；</p></li><li><p>大概看了一下，都蛮强大，包括上面的<code>Dom tree</code>,插件这部分并没有都实际应用过，所以也就不<code>打肿脸充胖子</code>了，有兴趣的同学可以自己看看。</p></li><li><p>如果觉得已经的插件都满足不了你的需求，它还支持自定义插件自己编写。</p></li></ul><p><img src="/2018/06/27/daily14/13453575-d6b7e67e6cd247ba.png" alt="高级插件用法等你去发现～"></p><p>在贴一下原文地址<a href="https://github.com/liriliri/eruda" target="_blank" rel="noopener">eruda</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;昨天介绍了一下抓包工具 &lt;a href=&quot;https://cansolve.cn/2018/06/26/daily13/&quot;&gt;Charles&lt;/a&gt;的使
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="其他" scheme="http://cansolve.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Charles抓包工具的使用</title>
    <link href="http://cansolve.cn/2018/06/26/daily13/"/>
    <id>http://cansolve.cn/2018/06/26/daily13/</id>
    <published>2018-06-26T06:29:08.000Z</published>
    <updated>2018-12-26T06:44:07.586Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><blockquote><p>环境：mac OS X<br>抓取苹果手机（ios）app里面的https请求包，对数据进行排查。Charles支持针对Https包解析。</p></blockquote><p><strong>1.安装Charles</strong><br><strong>2.电脑安装Charles证书</strong></p><p><img src="/2018/06/26/daily13/1901430-a2e383a5c13faeed.png" alt=""></p><p>电脑安装证书</p><p><img src="/2018/06/26/daily13/1901430-645b0affc6d31940.jpeg" alt=""></p><p>双击还是信任下吧</p><p><strong>3.手机安装证书</strong></p><p><img src="/2018/06/26/daily13/1901430-ae1660183e196ded.png" alt=""></p><p>手机安装证书</p><p><strong>4.手机网页输入网址 下载证书并信任</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.charlesproxy.com/documentation/additional/legacy-ssl-proxying/</span><br></pre></td></tr></table></figure><p>或者直接在safari 浏览器打开下面的地址就可以下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.charlesproxy.com/assets/legacy-ssl/charles.crt</span><br></pre></td></tr></table></figure><p>手机证书下载网址</p><p><img src="/2018/06/26/daily13/1901430-7bc4aeef100b2746.png" alt=""></p><p>安装到手机上</p><p><code>注意</code>：在iOS 10.3之前,当你将安装一个自定义证书,iOS会默认信任,不需要进一步的设置。而iOS 10.3之后,安装新的自定义证书默认是不受信任的。如果要信任已安装的自定义证书,需要手动打开开关以信任证书。</p><p>iOS11下需要手动信任已下载好的证书，方法如下：</p><blockquote><p>设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到charles proxy custom root certificate然后信任该证书即可.</p><p><img src="/2018/06/26/daily13/1901430-c23912a0181d3ebf.jpeg" alt=""></p><p>iOS11下手动信任证书</p></blockquote><p><strong>5.开始抓包</strong><br>Charles设置Proxy<br>Proxy -&gt; SSL Proxying Settings…，如下图所示：</p><p><img src="/2018/06/26/daily13/1901430-1d6e60dbb846cb29.png" alt=""></p><p>疑问1，如果设置成特定的域名发现还是抓不了包，不知道为什么</p><p>选择Proxy | Recording Settings，弹出Recording Settings设置选项卡，勾选include</p><p><img src="/2018/06/26/daily13/1901430-2c289b1801e24d68.png" alt=""></p><ul><li>抓包</li></ul><p><img src="/2018/06/26/daily13/2622600698-572c09c3f1858_articlex.jpeg" alt="图片描述" title="图片描述"></p><p><a href="http://blog.devtang.com/2015/11/14/charles-introduction/" target="_blank" rel="noopener">这里贴一个比较详细的过程</a></p><p>补充：</p><p>如果用户不选择信任安装Charles的CA证书，Charles也无法获取请求内容。还有一种，如果客户端内置了本身的CA证书，这时如果Charles把自己的证书发送给客户端，客户端会发现与程序内的证书不一致，不予通过，此时Charles也是无法获取信息的。</p><p>Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;blockquote&gt;&lt;p&gt;环境：mac OS X&lt;br&gt;抓取苹果手机（ios）app里面的https请求包，对数据进行排查。Charles支持针对Htt
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="其他" scheme="http://cansolve.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>常见 React 面试题</title>
    <link href="http://cansolve.cn/2018/06/17/daily7/"/>
    <id>http://cansolve.cn/2018/06/17/daily7/</id>
    <published>2018-06-17T04:11:23.000Z</published>
    <updated>2018-12-24T06:27:50.161Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --><blockquote><p>作者：小胡<br><a href="https://github.com/nanhupatar/FEGuide/blob/master/框架/react.md" target="_blank" rel="noopener">https://github.com/nanhupatar/FEGuide/blob/master/框架/react.md</a></p></blockquote><h3 id="React-中-keys-的作用是什么？"><a href="#React-中-keys-的作用是什么？" class="headerlink" title="React 中 keys 的作用是什么？"></a>React 中 keys 的作用是什么？</h3><p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;return (    </span><br><span class="line">          </span><br><span class="line">        &#123;this.state.todoItems.map((&#123;item, key&#125;) =&gt; &#123;      </span><br><span class="line">            return &#123;item&#125;      </span><br><span class="line">        &#125;)&#125;    </span><br><span class="line">       </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。</p><h3 id="调用-setState-之后发生了什么？"><a href="#调用-setState-之后发生了什么？" class="headerlink" title="调用 setState 之后发生了什么？"></a>调用 setState 之后发生了什么？</h3><p>在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p><h3 id="react-生命周期函数"><a href="#react-生命周期函数" class="headerlink" title="react 生命周期函数"></a>react 生命周期函数</h3><ul><li><p>初始化阶段：</p></li><li><p>getDefaultProps:获取实例的默认属性</p></li><li><p>getInitialState:获取每个实例的初始化状态</p></li><li><p>componentWillMount：组件即将被装载、渲染到页面上</p></li><li><p>render:组件在这里生成虚拟的 DOM 节点</p></li><li><p>componentDidMount:组件真正在被装载之后</p></li><li><p>运行中状态：</p></li><li><p>componentWillReceiveProps:组件将要接收到属性的时候调用</p></li><li><p>shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）</p></li><li><p>componentWillUpdate:组件即将更新不能修改属性和状态</p></li><li><p>render:组件重新描绘</p></li><li><p>componentDidUpdate:组件已经更新</p></li><li><p>销毁阶段：</p></li><li><p>componentWillUnmount:组件即将销毁</p></li></ul><h3 id="shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）"><a href="#shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）" class="headerlink" title="shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）"></a>shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</h3><p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p><p>参考 <a href="https://segmentfault.com/a/1190000008925295" target="_blank" rel="noopener">React进阶—性能优化</a></p><h3 id="为什么虚拟-dom-会提高性能-必考"><a href="#为什么虚拟-dom-会提高性能-必考" class="headerlink" title="为什么虚拟 dom 会提高性能?(必考)"></a>为什么虚拟 dom 会提高性能?(必考)</h3><p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。</p><p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p><p>参考 <a href="https://blog.csdn.net/qq_27626333/article/details/76082755" target="_blank" rel="noopener">如何理解虚拟 DOM?</a></p><h3 id="react-diff-原理（常考，大厂必考）"><a href="#react-diff-原理（常考，大厂必考）" class="headerlink" title="react diff 原理（常考，大厂必考）"></a>react diff 原理（常考，大厂必考）</h3><ul><li><p>把树形结构按照层级分解，只比较同级元素。</p></li><li><p>给列表结构的每个单元添加唯一的 key 属性，方便比较。</p></li><li><p>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</p></li><li><p>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</p></li><li><p>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p></li></ul><p>参考：<a href="https://blog.csdn.net/qq_26708777/article/details/78107577" target="_blank" rel="noopener">React 的 diff 算法</a></p><h3 id="React-中-refs-的作用是什么？"><a href="#React-中-refs-的作用是什么？" class="headerlink" title="React 中 refs 的作用是什么？"></a>React 中 refs 的作用是什么？</h3><p>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CustomForm extends Component &#123;</span><br><span class="line">  handleSubmit = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;Input Value: &quot;, this.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&apos;text&apos;</span><br><span class="line">          ref=&#123;(input) =&gt; this.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function CustomForm (&#123;handleSubmit&#125;) &#123;</span><br><span class="line">  let inputElement</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&apos;text&apos;</span><br><span class="line">        ref=&#123;(input) =&gt; inputElement = input&#125; /&gt;</span><br><span class="line">      &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如果你创建了类似于下面的-Twitter-元素，那么它相关的类定义是啥样子的？"><a href="#如果你创建了类似于下面的-Twitter-元素，那么它相关的类定义是啥样子的？" class="headerlink" title="如果你创建了类似于下面的 Twitter 元素，那么它相关的类定义是啥样子的？"></a>如果你创建了类似于下面的 Twitter 元素，那么它相关的类定义是啥样子的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Twitter username=&apos;tylermcginnis33&apos;&gt;</span><br><span class="line">  &#123;(user) =&gt; user === null</span><br><span class="line">    ? &lt;Loading /&gt;</span><br><span class="line">    : &lt;Badge info=&#123;user&#125; /&gt;&#125;</span><br><span class="line">&lt;/Twitter&gt;</span><br><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;</span><br><span class="line">import fetchUser from &apos;twitter&apos;</span><br><span class="line">// fetchUser take in a username returns a promise</span><br><span class="line">// which will resolve with that username&apos;s data.</span><br><span class="line">class Twitter extends Component &#123;</span><br><span class="line">  // finish this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你还不熟悉回调渲染模式（Render Callback Pattern），这个代码可能看起来有点怪。这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以 props.children 进行调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;</span><br><span class="line">import fetchUser from &apos;twitter&apos;</span><br><span class="line">class Twitter extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    user: null,</span><br><span class="line">  &#125;</span><br><span class="line">  static propTypes = &#123;</span><br><span class="line">    username: PropTypes.string.isRequired,</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    fetchUser(this.props.username)</span><br><span class="line">      .then((user) =&gt; this.setState(&#123;user&#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return this.props.children(this.state.user)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式的优势在于将父组件与子组件解耦和，父组件可以直接访问子组件的内部状态而不需要再通过 Props 传递，这样父组件能够更为方便地控制子组件展示的 UI 界面。譬如产品经理让我们将原本展示的 Badge 替换为 Profile，我们可以轻易地修改下回调函数即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Twitter username=&apos;tylermcginnis33&apos;&gt;</span><br><span class="line">  &#123;(user) =&gt; user === null</span><br><span class="line">    ? &lt;Loading /&gt;</span><br><span class="line">    : &lt;Profile info=&#123;user&#125; /&gt;&#125;</span><br><span class="line">&lt;/Twitter&gt;</span><br></pre></td></tr></table></figure><h3 id="展示组件-Presentational-component-和容器组件-Container-component-之间有何不同"><a href="#展示组件-Presentational-component-和容器组件-Container-component-之间有何不同" class="headerlink" title="展示组件(Presentational component)和容器组件(Container component)之间有何不同"></a>展示组件(Presentational component)和容器组件(Container component)之间有何不同</h3><ul><li><p>展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。</p></li><li><p>容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。</p></li></ul><h3 id="类组件-Class-component-和函数式组件-Functional-component-之间有何不同"><a href="#类组件-Class-component-和函数式组件-Functional-component-之间有何不同" class="headerlink" title="类组件(Class component)和函数式组件(Functional component)之间有何不同"></a>类组件(Class component)和函数式组件(Functional component)之间有何不同</h3><ul><li><p>类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态</p></li><li><p>当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件</p></li></ul><h3 id="组件的-状态-state-和属性-props-之间有何不同"><a href="#组件的-状态-state-和属性-props-之间有何不同" class="headerlink" title="(组件的)状态(state)和属性(props)之间有何不同"></a>(组件的)状态(state)和属性(props)之间有何不同</h3><ul><li><p>State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。</p></li><li><p>Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</p></li></ul><h3 id="何为受控组件-controlled-component"><a href="#何为受控组件-controlled-component" class="headerlink" title="何为受控组件(controlled component)"></a>何为受控组件(controlled component)</h3><p>在 HTML 中，类似 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。</p><h3 id="何为高阶组件-higher-order-component"><a href="#何为高阶组件-higher-order-component" class="headerlink" title="何为高阶组件(higher order component)"></a>何为高阶组件(higher order component)</h3><p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。</p><h3 id="为什么建议传递给-setState-的参数是一个-callback-而不是一个对象"><a href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象" class="headerlink" title="为什么建议传递给 setState 的参数是一个 callback 而不是一个对象"></a>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</h3><p>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。</p><h3 id="除了在构造函数中绑定-this，还有其它方式吗"><a href="#除了在构造函数中绑定-this，还有其它方式吗" class="headerlink" title="除了在构造函数中绑定 this，还有其它方式吗"></a>除了在构造函数中绑定 this，还有其它方式吗</h3><p>你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p><h3 id="在构造函数中-调用-super-props-的目的是什么"><a href="#在构造函数中-调用-super-props-的目的是什么" class="headerlink" title="(在构造函数中)调用 super(props) 的目的是什么"></a>(在构造函数中)调用 super(props) 的目的是什么</h3><p>在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。</p><h3 id="应该在-React-组件的何处发起-Ajax-请求"><a href="#应该在-React-组件的何处发起-Ajax-请求" class="headerlink" title="应该在 React 组件的何处发起 Ajax 请求"></a>应该在 React 组件的何处发起 Ajax 请求</h3><p>在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。</p><h3 id="描述事件在-React-中的处理方式。"><a href="#描述事件在-React-中的处理方式。" class="headerlink" title="描述事件在 React 中的处理方式。"></a>描述事件在 React 中的处理方式。</h3><p>为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。</p><p>这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新 DOM 时，React 不需要担心跟踪事件监听器。</p><h3 id="createElement-和-cloneElement-有什么区别？"><a href="#createElement-和-cloneElement-有什么区别？" class="headerlink" title="createElement 和 cloneElement 有什么区别？"></a>createElement 和 cloneElement 有什么区别？</h3><p>React.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>React.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而就的子元素奖杯替换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.cloneElement(</span><br><span class="line">  element,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="React-中有三种构建组件的方式"><a href="#React-中有三种构建组件的方式" class="headerlink" title="React 中有三种构建组件的方式"></a>React 中有三种构建组件的方式</h3><p>React.createClass()、ES6 class 和无状态函数。</p><h3 id="react-组件的划分业务组件技术组件？"><a href="#react-组件的划分业务组件技术组件？" class="headerlink" title="react 组件的划分业务组件技术组件？"></a>react 组件的划分业务组件技术组件？</h3><ul><li><p>根据组件的职责通常把组件分为 UI 组件和容器组件。</p></li><li><p>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</p></li><li><p>两者通过 React-Redux 提供 connect 方法联系起来。</p></li></ul><h3 id="简述-flux-思想"><a href="#简述-flux-思想" class="headerlink" title="简述 flux 思想"></a>简述 flux 思想</h3><p>Flux 的最大特点，就是数据的”单向流动”。</p><ol><li><p>用户访问 View</p></li><li><p>View 发出用户的 Action</p></li><li><p>Dispatcher 收到 Action，要求 Store 进行相应的更新</p></li><li><p>Store 更新后，发出一个”change”事件</p></li><li><p>View 收到”change”事件后，更新页面</p></li></ol><h3 id="React-项目用过什么脚手架（本题是开放性题目）"><a href="#React-项目用过什么脚手架（本题是开放性题目）" class="headerlink" title="React 项目用过什么脚手架（本题是开放性题目）"></a>React 项目用过什么脚手架（本题是开放性题目）</h3><p>creat-react-app Yeoman 等</p><h3 id="了解-redux-么，说一下-redux-把"><a href="#了解-redux-么，说一下-redux-把" class="headerlink" title="了解 redux 么，说一下 redux 把"></a>了解 redux 么，说一下 redux 把</h3><ul><li><p>redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据，flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰</p></li><li><p>新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们</p></li></ul><h3 id="redux-有什么缺点"><a href="#redux-有什么缺点" class="headerlink" title="redux 有什么缺点"></a>redux 有什么缺点</h3><ul><li><p>一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。</p></li><li><p>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jun 12 2020 17:24:04 GMT+0800 (中国标准时间) --&gt;&lt;blockquote&gt;&lt;p&gt;作者：小胡&lt;br&gt;&lt;a href=&quot;https://github.com/nanhupatar/FEGuide/blob/ma
      
    
    </summary>
    
      <category term="分享" scheme="http://cansolve.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="react" scheme="http://cansolve.cn/tags/react/"/>
    
  </entry>
  
</feed>
