<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cansolve.cn/"/>
  <updated>2019-01-10T07:12:30.363Z</updated>
  <id>http://cansolve.cn/</id>
  
  <author>
    <name>tongxiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日常问题解决（持续更新中）</title>
    <link href="http://cansolve.cn/2019/01/02/daily16/"/>
    <id>http://cansolve.cn/2019/01/02/daily16/</id>
    <published>2019-01-02T13:06:28.000Z</published>
    <updated>2019-01-10T07:12:30.363Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><h3 id="解决使用-swiper-常见的问题"><a href="#解决使用-swiper-常见的问题" class="headerlink" title="解决使用 swiper 常见的问题"></a>解决使用 swiper 常见的问题</h3><p><strong>1、swiper近视初始化时, 其父级元素处于隐藏状态(display:none),会导致swiper初始化失败, 页面中的滚动效果有问题</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解决方法1: </span><br><span class="line"> var mySwiper = new Swiper(&apos;.demo&apos;,&#123;</span><br><span class="line">     observer: true,//修改swiper自己或子元素时，自动初始化swiper</span><br><span class="line">     observeParents: true//修改swiper的父元素时，自动初始化swiper</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line">解决方法2: </span><br><span class="line">固定宽和高</span><br><span class="line">  var mySwiper = new Swiper(&apos;.demo&apos;,&#123;</span><br><span class="line">     width:200,</span><br><span class="line">     height:200</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p></p><p><strong>2、swiper里面的图片懒加载与预加载, 可以使用自带的 lazyload 方法</strong><br><a href="https://www.swiper.com.cn/api/lazy/213.html" target="_blank" rel="noopener">主要看这里-swiper4 懒加载文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">设为true开启图片延迟加载默认值，使preloadImages无效。或者设置延迟加载选项。</span><br><span class="line"> </span><br><span class="line">图片延迟加载：需要将图片img标签的src改写成data-src，并且增加类名swiper-lazy。</span><br><span class="line">背景图延迟加载：载体增加属性data-background，并且增加类名swiper-lazy。</span><br><span class="line"> </span><br><span class="line">还可以加一个预加载，&lt;div class=&quot;swiper-lazy-preloader&quot;&gt;&lt;/div&gt;</span><br><span class="line">或者白色的&lt;div class=&quot;swiper-lazy-preloader swiper-lazy-preloader-white&quot;&gt;&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">当你设置了slidesPerView:&apos;auto&apos; 或者 slidesPerView &gt; 1，还需要开启watchSlidesVisibility。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">var mySwiper = new Swiper(&apos;.swiper-container&apos;, &#123;</span><br><span class="line">  lazy: &#123;</span><br><span class="line">    loadPrevNext: true,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>3、想在轮播图外创建分页器、上一页和下一页的按钮(因为swiper的container默认overflow:hidden, 只能在轮播图中的可视区域显示切换菜单和上一页下一页)</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var mySwiper = new Swiper(&apos;.swiper-container&apos;,&#123;</span><br><span class="line">    pagination : &apos;.swiper-pagination&apos;,</span><br><span class="line">    uniqueNavElements :false,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><h3 id="jquery-fullpage-插件增加头部和底部的方法"><a href="#jquery-fullpage-插件增加头部和底部的方法" class="headerlink" title="jquery fullpage 插件增加头部和底部的方法"></a>jquery fullpage 插件增加头部和底部的方法</h3><p>官方给出了解决方案，不要去什么修改源码啦之类的，或者自己写代码判断啦<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;fullpage&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;section fp-auto-height&quot;&gt;这里写头部&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;page1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;page2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;page3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section&quot;&gt;page4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;section fp-auto-height&quot;&gt;这里写版权&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p></p><p>如上，js代码就不说了，只要你能跑起来，就没有问题。这里只需要给头部和底部增加一个fp-auto-height 的 class ，然后自己可以加点class写样式。</p><p>没有生效吗？</p><p>嘿嘿，那是因为你只引用了js，而没有引用css造成的，只要引用下面的css即可。</p><p><a href="https://github.com/alvarotrigo/fullPage.js/blob/master/dist/jquery.fullpage.css" target="_blank" rel="noopener">https://github.com/alvarotrigo/fullPage.js/blob/master/dist/jquery.fullpage.css</a></p><p>其实关键代码只是下面的而已<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.fp-auto-height.fp-section,</span><br><span class="line">.fp-auto-height .fp-slide,</span><br><span class="line">.fp-auto-height .fp-tableCell&#123;</span><br><span class="line">    height: auto !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.fp-responsive .fp-auto-height-responsive.fp-section,</span><br><span class="line">.fp-responsive .fp-auto-height-responsive .fp-slide,</span><br><span class="line">.fp-responsive .fp-auto-height-responsive .fp-tableCell &#123;</span><br><span class="line">    height: auto !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其他参数配置见<a href="http://fullpage.81hu.com/" target="_blank" rel="noopener">官网</a></p><h3 id="对于多行text-overflow-ellipsis-溢出显示省略号的解决办法（尽量兼容所有浏览器）"><a href="#对于多行text-overflow-ellipsis-溢出显示省略号的解决办法（尽量兼容所有浏览器）" class="headerlink" title="对于多行text-overflow:ellipsis 溢出显示省略号的解决办法（尽量兼容所有浏览器）"></a>对于多行text-overflow:ellipsis 溢出显示省略号的解决办法（尽量兼容所有浏览器）</h3><p><strong>1、css解决</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@mixin ellipsis($line:1)&#123;</span><br><span class="line">  word-break: break-all;</span><br><span class="line">  @if $line == 1&#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">  &#125;@else&#123;</span><br><span class="line">    text-overflow:clip;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    word-wrap: break-word;</span><br><span class="line">    white-space: normal !important;</span><br><span class="line">    -webkit-line-clamp:$line;</span><br><span class="line">    -webkit-box-orient: vertical;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>2、js解决</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//截取的函数 双字节字符长度为2 ASCLL字符长度为1</span><br><span class="line">function cutStr(str,cutLen)&#123;</span><br><span class="line">    var returnStr = &apos;&apos;,    //返回的字符串</span><br><span class="line">        reCN = /[^\x00-\xff]/,    //双字节字符</span><br><span class="line">        strCNLen = str.replace(/[^\x00-\xff]/g,&apos;**&apos;).length; </span><br><span class="line">    if(cutLen&gt;=strCNLen)&#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var i=0,len=0;len&lt;cutLen;i++)&#123;</span><br><span class="line">        returnStr += str.charAt(i);</span><br><span class="line">        if(reCN.test(str.charAt(i)))&#123;</span><br><span class="line">            len+=2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return returnStr;</span><br><span class="line">&#125;</span><br><span class="line">$(function ()&#123;</span><br><span class="line">    var str = $(this).text();</span><br><span class="line">    $(this).text(cutStr(str,34)+&apos;...&apos;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p><strong>3、哈哈哈哈，后台解决</strong><br>麻烦以下后端小伙伴帮忙处理以下</p><p>后续继续整理</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;h3 id=&quot;解决使用-swiper-常见的问题&quot;&gt;&lt;a href=&quot;#解决使用-swiper-常见的问题&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="其他" scheme="http://cansolve.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>圣诞节🎄，刷刷面试题可能更适合我</title>
    <link href="http://cansolve.cn/2018/12/24/daily12/"/>
    <id>http://cansolve.cn/2018/12/24/daily12/</id>
    <published>2018-12-24T13:06:28.000Z</published>
    <updated>2019-01-04T02:08:46.917Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><h3 id="知道什么是事件委托吗？"><a href="#知道什么是事件委托吗？" class="headerlink" title="知道什么是事件委托吗？"></a>知道什么是事件委托吗？</h3><p><a href="https://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">个人感觉这篇文章写的超级好，我就不班门弄斧了</a></p><h3 id="window的onload事件和domcontentloaded谁先谁后？"><a href="#window的onload事件和domcontentloaded谁先谁后？" class="headerlink" title="window的onload事件和domcontentloaded谁先谁后？"></a>window的onload事件和domcontentloaded谁先谁后？</h3><p>一般情况下，DOMContentLoaded事件要在window.onload之前执行，当DOM树构建完成的时候就会执行DOMContentLoaded事件，而window.onload是在页面载入完成的时候，才执行，这其中包括图片等元素。大多数时候我们只是想在DOM树构建完成后，绑定事件到元素，我们并不需要图片元素，加上有时候加载外域图片的速度非常缓慢。</p><h3 id="你之前遇到过跨域问题吗？是怎么解决的。"><a href="#你之前遇到过跨域问题吗？是怎么解决的。" class="headerlink" title="你之前遇到过跨域问题吗？是怎么解决的。"></a>你之前遇到过跨域问题吗？是怎么解决的。</h3><p>目前我知道的可以解决的方法有下面几种：</p><p>jsonp、后端java或者php修改、nginx反向代理、postMessage。。。，应该还有，只是我很少用</p><p>但是比较常用的是下面两种</p><ol><li><p>使用JSONP，其实用的也不多，因为感觉会导致安全问题，或者效率下降（这两点仅是我的猜测）。</p><p><strong>猜测的理由：</strong></p><ul><li><p>任何来源都能访问, 会不会存在乱七八糟的js注入？</p></li><li><p>后端和前端需要都JSONP进行处理。（代码繁琐，而且是所有请求都要使用JSONP）。</p></li></ul></li><li><p>在后端添加跨域头</p><p>为<code>Access-Control-Allow-Origin</code>添加 <code>*</code></p><p>如果前端域名比较多，需要添加很多域名，为<code>Access-Control-Allow-Origin</code>添加目标域名 (<code>Origin 请求头</code>) 而不 是写死的域名或<code>*</code></p></li></ol><h3 id="typeof和instanceof的区别"><a href="#typeof和instanceof的区别" class="headerlink" title="typeof和instanceof的区别"></a>typeof和instanceof的区别</h3><p>typeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。</p><p><strong>它返回值是一个字符串，该字符串说明运算数的类型。（</strong>typeof 运算符返回一个用来表示表达式的数据类型的字符串。 ）</p><p>typeof其实就是判断参数是什么类型的实例，就一个参数</p><p>typeof 一般只能返回如下几个结果：”number”、”string”、”boolean”、”object”、”function” 和 “undefined”。</p><p>instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。 语法：object instanceof constructor 参数：object（要检测的对象.）constructor（某个构造函数） 描述：instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student () &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = Person.prototype;</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">let s = new Student(&apos;Tom&apos;);</span><br><span class="line">console.log(s instanceof Person); // 返回 true</span><br></pre></td></tr></table></figure><h3 id="下面代码输出什么？"><a href="#下面代码输出什么？" class="headerlink" title="下面代码输出什么？"></a>下面代码输出什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line">// 10个10</span><br></pre></td></tr></table></figure><p>若要输出从0到9，怎么办？</p><p><strong>答案:</strong>将var改为let，或者使用闭包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用闭包</span><br><span class="line">for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    (function (i) &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(i)</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-of-和-for-in-的区别"><a href="#for-of-和-for-in-的区别" class="headerlink" title="for of 和 for in 的区别"></a>for of 和 for in 的区别</h3><p>for in<br>一般用于遍历对象的可枚举属性。以及对象从构造函数原型中继承的属性。对于每个不同的属性，语句都会被执行。<br>不建议使用for in 遍历数组，因为输出的顺序是不固定的。<br>如果迭代的对象的变量值是null或者undefined, for in不执行循环体，建议在使用for in循环之前，先检查该对象的值是不是null或者undefined</p><p>for of</p><p>for…of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</p><p>上面是官方解释，我理解的最明显的区别，遍历下面数组</p><p>for in是ES5标准，遍历key.<br>for of是ES6标准，遍历value.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a=[1,2,3]</span><br><span class="line"></span><br><span class="line">for(let i in a)&#123;</span><br><span class="line">    console.log(i);     //0 1 2 这里的i输出的是下标</span><br><span class="line">    console.log(a[i]); //1 2 3</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">for(let i of a)&#123;</span><br><span class="line">    console.log(i); //1 2 3  这里的i输出的是对应的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用过flex布局吗？flex-grow和flex-shrink属性有什么用？"><a href="#使用过flex布局吗？flex-grow和flex-shrink属性有什么用？" class="headerlink" title="使用过flex布局吗？flex-grow和flex-shrink属性有什么用？"></a>使用过flex布局吗？flex-grow和flex-shrink属性有什么用？</h3><p><strong>flex-grow</strong></p><p>用来“瓜分”父项的“剩余空间”。<br><img src="/2018/12/24/daily12/12904618-3e41b8713610e6e8.png" alt="flex-grow"><br>容器的宽度为400px, 子项1的占用的基础空间(flex-basis)为50px，子项2占用的基础空间是70px，子项3占用基础空间是100px，剩余空间为 400-50-70-100 = 180px。 其中子项1的flex-grow: 0(未设置默认为0)， 子项2flex-grow: 2，子项3flex-grow: 1，剩余空间分成3份，子项2占2份(120px)，子项3占1份(60px)。所以 子项1真实的占用空间为: 50+0 = 50px， 子项2真实的占用空间为: 70+120 = 190px， 子项3真实的占用空间为: 100+60 = 160px。</p><p><strong>flex-shrink</strong></p><p>用来“吸收”超出的空间<br><img src="/2018/12/24/daily12/12904618-ed1819e7b3415dec.png" alt="flex-grow"><br>容器的宽度为400px, 子项1的占用的基准空间(flex-basis)为250px，子项2占用的基准空间是150px，子项3占用基准空间是100px，总基准空间为 250+150+100=500px。容器放不下，多出来的空间需要被每个子项根据自己设置的flex-shrink 进行吸收。 子项1的flex-shrink: 1(未设置默认为1)， 子项2 flex-shrink: 2，子项3 flex-shrink: 2。子项1需要吸收的的空间为 <code>(250*1)/(250*1+150*2+100*2) * 100 = 33.33px</code>，子项1真实的空间为 250-33.33 = 216.67px。同理子项2吸收的空间为<code>(150*2)/(250*1+150*2+100*2) * 100=40px</code>，子项2真实空间为 <code>150-40 = 110px</code>。子项3吸收的空间为<code>(100*2)/(250*1+150*2+100*2) * 100 = 26.67px</code>，真实的空间为<code>100-26.67=73.33px</code>。</p><h3 id="从输入URL到页面加载发生了什么？"><a href="#从输入URL到页面加载发生了什么？" class="headerlink" title="从输入URL到页面加载发生了什么？"></a>从输入URL到页面加载发生了什么？</h3><p>这里涉及很多的东西，这里只是简单的写一下大概的答案；</p><p>1、浏览器的地址栏输入URL并按下回车。</p><p>2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。</p><p>3、DNS解析URL对应的IP。</p><p>4、根据IP建立TCP连接（三次握手）。</p><p>5、HTTP发起请求。</p><p>6、服务器处理请求，浏览器接收HTTP响应。</p><p>7、渲染页面，构建DOM树。</p><p>8、关闭TCP连接（四次挥手）。<br><img src="/2018/12/24/daily12/167d5e19c54ae53e.jpg" alt="flex-grow"></p><h3 id="你知道哪些状态码？"><a href="#你知道哪些状态码？" class="headerlink" title="你知道哪些状态码？"></a>你知道哪些状态码？</h3><p>1xx：指示信息–表示请求已接收，继续处理。</p><p>2xx：成功–表示请求已被成功接收、理解、接受。</p><p>3xx：重定向–要完成请求必须进行更进一步的操作。</p><p>4xx：客户端错误–请求有语法错误或请求无法实现。</p><p>5xx：服务器端错误–服务器未能实现合法的请求。</p><p>平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500(分别表示什么请自行查找)。</p><h3 id="刚刚你说的整个过程中，有哪些优化手段可以优化提高网页响应速度？"><a href="#刚刚你说的整个过程中，有哪些优化手段可以优化提高网页响应速度？" class="headerlink" title="刚刚你说的整个过程中，有哪些优化手段可以优化提高网页响应速度？"></a>刚刚你说的整个过程中，有哪些优化手段可以优化提高网页响应速度？</h3><p><a href="https://csspod.com/frontend-performance-best-practices/" target="_blank" rel="noopener">贴个链接，比我解释的详细</a></p><p><strong>补充于2018-12-28</strong></p><h3 id="什么是圣杯布局？"><a href="#什么是圣杯布局？" class="headerlink" title="什么是圣杯布局？"></a>什么是圣杯布局？</h3><p>官方解释：<br>圣杯布局是为了讨论「三栏液态布局」的实现，最早的完美实现是由 Matthew Levine 在 2006 年写的一篇文章 《In Search of the Holy Grail》 ，它主要讲述了网页中关于最佳圣杯的实现方法。</p><p>它有以下几点要求：</p><p>上部(header)和下部(footer)各自占领屏幕所有宽度。<br>上下部之间的部分(container)是一个三栏布局。<br>三栏布局两侧宽度不变，中间部分自动填充整个区域。<br>中间部分的高度是三栏中最高的区域的高度。</p><h5 id="实现方法1：浮动"><a href="#实现方法1：浮动" class="headerlink" title="实现方法1：浮动"></a>实现方法1：浮动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;header&quot;&gt;</span><br><span class="line">    &lt;h4&gt;header&lt;/h4&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;middle&quot;&gt;</span><br><span class="line">        &lt;h4&gt;middle&lt;/h4&gt;</span><br><span class="line">        &lt;p&gt;middle-content&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">        &lt;h4&gt;left&lt;/h4&gt;</span><br><span class="line">        &lt;p&gt;left-content&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">        &lt;h4&gt;right&lt;/h4&gt;</span><br><span class="line">        &lt;p&gt;right-content&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;footer&quot;&gt;</span><br><span class="line">    &lt;h4&gt;footer&lt;/h4&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.header, .footer &#123;</span><br><span class="line">    border: 1px solid #333;</span><br><span class="line">    background: #ccc;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.footer &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">    padding:0 220px 0 200px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.left, .middle, .right &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    float: left;</span><br><span class="line">    min-height: 130px;</span><br><span class="line">&#125;</span><br><span class="line">.middle &#123;</span><br><span class="line">   width: 100%;</span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">    margin-left: -100%;</span><br><span class="line">    left: -200px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">    margin-left: -220px;</span><br><span class="line">    right: -220px;</span><br><span class="line">    width: 220px;</span><br><span class="line">    background: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析一下思路：</p><ul><li><p>在html中，先定义好header和footer的样式，使之横向撑满。</p></li><li><p>在container中的三列设为浮动和相对定位(后面会用到)，middle要放在最前面，footer清除浮动。</p></li><li><p>三列的左右两列分别定宽200px和220px，中间部分middle设置100%撑满</p></li><li><p>这样因为浮动的关系，middle会占据整个container，左右两块区域被挤下去了</p></li><li><p>接下来设置left的<code>margin-left:-100%;</code>，让left回到上一行最左侧</p></li><li><p>但这会把middle给遮住了，所以这时给外层的container设置<code>padding:0 220px 0 200px;</code>，给left空出位置</p></li><li><p>这时left并没有在最左侧，因为之前已经设置过相对定位，所以通过<code>left:-200px;</code>把left拉回最左侧</p></li><li><p>同样的，对于right区域，设置<code>margin-right:-220px;</code>把right拉回第一行</p></li><li><p>这时右侧空出了220px的空间，所以最后设置 `right:-220px;##把right区域拉到最右侧就行了。</p></li></ul><h5 id="实现方法2：flex弹性盒子"><a href="#实现方法2：flex弹性盒子" class="headerlink" title="实现方法2：flex弹性盒子"></a>实现方法2：flex弹性盒子</h5><pre><code>这个我就不贴代码了，</code></pre><ul><li>header和footer同上面一样，横向撑满。footer不用再清浮动了</li><li>container中的left、middle、right依次排布即可，不用特意将middle放置到最前面</li><li>给container设置弹性布局 display:flex;</li><li>left和right区域定宽，middle设置 flex:1; 即可</li></ul><h3 id="解决使用-swiper-常见的问题"><a href="#解决使用-swiper-常见的问题" class="headerlink" title="解决使用 swiper 常见的问题"></a>解决使用 swiper 常见的问题</h3><p><strong>1、swiper近视初始化时, 其父级元素处于隐藏状态(display:none),会导致swiper初始化失败, 页面中的滚动效果有问题</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解决方法1: </span><br><span class="line"> var mySwiper = new Swiper(&apos;.demo&apos;,&#123;</span><br><span class="line">     observer: true,//修改swiper自己或子元素时，自动初始化swiper</span><br><span class="line">     observeParents: true//修改swiper的父元素时，自动初始化swiper</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line">解决方法2: </span><br><span class="line">固定宽和高</span><br><span class="line">  var mySwiper = new Swiper(&apos;.demo&apos;,&#123;</span><br><span class="line">     width:200,</span><br><span class="line">     height:200</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p></p><p><strong>2、swiper里面的图片懒加载与预加载, 可以使用自带的 lazyload 方法</strong><br><a href="https://www.swiper.com.cn/api/lazy/213.html" target="_blank" rel="noopener">主要看这里-swiper4 懒加载文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">设为true开启图片延迟加载默认值，使preloadImages无效。或者设置延迟加载选项。</span><br><span class="line"> </span><br><span class="line">图片延迟加载：需要将图片img标签的src改写成data-src，并且增加类名swiper-lazy。</span><br><span class="line">背景图延迟加载：载体增加属性data-background，并且增加类名swiper-lazy。</span><br><span class="line"> </span><br><span class="line">还可以加一个预加载，&lt;div class=&quot;swiper-lazy-preloader&quot;&gt;&lt;/div&gt;</span><br><span class="line">或者白色的&lt;div class=&quot;swiper-lazy-preloader swiper-lazy-preloader-white&quot;&gt;&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">当你设置了slidesPerView:&apos;auto&apos; 或者 slidesPerView &gt; 1，还需要开启watchSlidesVisibility。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">var mySwiper = new Swiper(&apos;.swiper-container&apos;, &#123;</span><br><span class="line">  lazy: &#123;</span><br><span class="line">    loadPrevNext: true,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>3、想在轮播图外创建分页器、上一页和下一页的按钮(因为swiper的container默认overflow:hidden, 只能在轮播图中的可视区域显示切换菜单和上一页下一页)</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var mySwiper = new Swiper(&apos;.swiper-container&apos;,&#123;</span><br><span class="line">    pagination : &apos;.swiper-pagination&apos;,</span><br><span class="line">    uniqueNavElements :false,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>后续继续整理</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;h3 id=&quot;知道什么是事件委托吗？&quot;&gt;&lt;a href=&quot;#知道什么是事件委托吗？&quot; class=&quot;headerlink&quot; title=&quot;知道什么是事件委托吗？
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="js" scheme="http://cansolve.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>2019年React学习路线图</title>
    <link href="http://cansolve.cn/2018/12/20/daily10/"/>
    <id>http://cansolve.cn/2018/12/20/daily10/</id>
    <published>2018-12-20T11:05:40.000Z</published>
    <updated>2018-12-24T04:22:46.515Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><blockquote><p>作者｜javinpaul<br>译者｜无明<br>转发自 | 前端之巅公众号</p></blockquote><p>之前我们已经介绍了 <a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247490087&amp;idx=1&amp;sn=fb16b7826416244642cdab69a52848c0&amp;chksm=f951af64ce262672982f1896976f594589925a0b2730801715247ae40d7ee06c2960d6b6a338&amp;token=1582750074&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">2019 年 Vue 学习路线图</a>，而 React 作为当前应用最广泛的前端框架，在 Facebook 的支持下，近年来实现了飞越式的发展，我们将在下文中介绍 2019 年 React 学习路线图，希望给想学 React 的开发者一些借鉴。</p><p>下图是2018 年的 React 路线图，它非常全面，2018 年剩下的时间可能不够你学会所有这些，但不要担心，所有的技术在 2019 年仍然有效。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/XIibZ0YbvibkUhfSXs7kotWIegAeUWWHMDpOs46GfwR0YnIHCauC8Kt69U6gexHpKQvqZpFyhcUABEJYYCnTFwbA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""><br>图片来源：</p><p><a href="https://github.com/adam-golab/react-developer-roadmap/blob/master/roadmap.png" target="_blank" rel="noopener">https://github.com/adam-golab/react-developer-roadmap/blob/master/roadmap.png</a></p><h3 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h3><p>不管你要学习哪个 Web 开发框架或库，都必须掌握基础知识，如 HTML、CSS 和 JavaScript，这三个是 Web 开发的三大支柱。</p><p><strong>HTML</strong></p><p>HTML 是 Web 开发人员最重要的技能之一，因为它为网页提供了基本结构。</p><p><strong>CSS</strong></p><p>CSS 用于设置网页样式，让网页看起来更好看。</p><p><strong>JavaScript</strong></p><p>JavaScript 让网页具备交互性。React 是基于 JavaScript 的，因此在学习 React 之前，你应该先了解 JavaScript。</p><h3 id="2、通用的开发技能"><a href="#2、通用的开发技能" class="headerlink" title="2、通用的开发技能"></a>2、通用的开发技能</h3><p>无论你是前端开发人员还是后端开发人员，甚至是全栈工程师，都必须了解一些能够让你在编程世界中生存下来的通用开发技能。</p><p><strong>学习 GIT</strong></p><p>你必须在 2018 年完全了解 Git。尝试在 GitHub 上创建一些存储库，与其他人共享你的代码，并学习如何在你喜欢的 IDE 中克隆 Github 上的代码。</p><p><strong>了解 HTTP(S) 协议</strong></p><p>如果你想成为一名 Web 开发人员，那么了解 HTTP 绝对是有必要的。</p><p>我不是要你去阅读 HTTP(S) 规范，但你至少应该熟悉常见的 HTTP 请求方法，如 GET、POST、PUT、PATCH、DELETE、OPTIONS 以及 HTTP/HTTPS 的工作原理。</p><p><strong>学习终端</strong></p><p>虽然前端开发人员学习 Linux 或终端并不是强制性的，但我强烈建议你熟悉以下终端，了解如何配置你的 shell（bash、zsh、csh）等。</p><p><strong>算法和数据结构</strong></p><p>好吧，这又是一个通用编程技能，成为 React 开发者不一定需要了解这些，但要成为真正的程序员，这是必备技能。</p><p><strong>学习设计模式</strong></p><p>就像算法和数据结构一样，成为 React 开发者并不一定要学习设计模式，但学好设计模式会让你变得更好。了解设计模式将帮你找到能够经受住时间考验的解决方案。</p><h3 id="3、学习-React"><a href="#3、学习-React" class="headerlink" title="3、学习 React"></a>3、学习 React</h3><p>你必须学好 React 才能成为一名 React 开发者。学习 React 最好的资源是它的官方网站，但作为初学者，它对你来说可能有点难。</p><p><strong>学习构建工具</strong></p><p>如果你想成为一名专业的 React 开发者，那么你应该花一些时间熟悉一下你将作为 Web 开发者需要使用的工具，比如构建工具、单元测试工具、调试工具等。</p><p>以下是路线图中列出的构建工具：</p><p>包管理器：</p><ul><li><p>npm</p></li><li><p>yarn</p></li><li><p>pnpm</p></li><li><p>任务执行器</p></li><li><p>npm 脚本</p></li><li><p>gulp</p></li><li><p>WebPack</p></li><li><p>Rollup</p></li><li><p>Parcel</p></li></ul><p>顺便说一句，并非要学习所有这些工具，对于初学者来说，学习 npm 和 Webpack 应该足够了。在你对 Web 开发和 React 生态系统有了更多的了解后，你就可以学习其他工具。</p><p><strong>样式</strong></p><p>如果你的目标是成为 React 开发者，了解一些样式相关的知识只会有益无害。路线图中提到了很多 CSS 相关的东西，比如 CSS 预处理器、CSS 框架、CSS 架构和 JS 中的 CSS。</p><p>我建议你至少学习一下 Bootstrap，这是你经常会用到的 CSS 框架。</p><p>如果你想进一步学习 bootstrap，也可以学习 Materialise 或 Material UI。</p><p><strong>状态管理</strong></p><p>这是 React 开发者应该关注的另一个重要领域。路线图中提到了以下一些需要掌握的概念和框架：</p><ul><li><p>组件 State/ContextAPI</p></li><li><p>Redux</p></li><li><p>异步操作（副作用）</p></li><li><p>Redux Thunk</p></li><li><p>Redux Better Promise</p></li><li><p>Redux Saga</p></li><li><p>Redux Observable</p></li><li><p>Helpers</p></li><li><p>Rematch</p></li><li><p>Reselect</p></li><li><p>Data persistence</p></li><li><p>Redux Persist</p></li><li><p>Redux Phoenix</p></li><li><p>Redux Form</p></li><li><p>MobX</p></li></ul><p>如果东西太多，我建议你只关注 Redux。</p><p><strong>Type Checker</strong></p><p>由于 JavaScript 不是一种强类型语言，因此编译器不会捕获那些与类型相关的错误。</p><p>随着应用程序的增长，你可以通过类型检查捕获大量错误，尤其是如果你可以使用 Flow 或 TypeScript 等 JavaScript 扩展对整个应用程序进行类型检查。</p><p>React 也提供了一些内置的类型检查功能，可以用它们帮你尽早发现 bug。</p><p>由于 Angular 也使用了 TypeScript，我认为可以同时学习 JavaScript 和 TypeScript。</p><p><strong>Form Helper</strong></p><p>除了 Type Checker 之外，还可以学习像 Redux Form 这样的 Form Helper，它提供了在 Redux 中管理表单状态的最佳方法。除了 Redux Form 之外，还有 Formik、Formsy 和 Final。</p><p><strong>路由</strong></p><p>组件是 React 声明性编程模型的核心，而路由组件是应用程序的重要组成部分。</p><p>React Router 提供了一组导航组件，这些组件可以通过声明的方式与你的应用程序组合在一起。</p><p>除了 React Router 之外，你还可以看看 Router 5 和 Redux-First Router。</p><p><strong>API 客户端</strong></p><p>在今天的世界中，你很少会构建独立的 GUI，相反，你将有更多机会使用 REST 和 GraphQL 等 API 构建与其他应用程序发生交互的东西。</p><p>值得庆幸的是，React 开发者可以使用很多 API 客户端：</p><p>REST</p><ul><li><p>Fetch</p></li><li><p>SuperAgent</p></li><li><p>axios</p></li></ul><p>GraphQL</p><ul><li><p>Apollo</p></li><li><p>Relay</p></li><li><p>urql</p></li></ul><p>Apollo 客户端是我的最爱，它提供了一种使用 GraphQL 构建客户端应用程序的简便方法。Apollo 可以帮你快速构建使用 GraphQL 获取数据的 UI，并可以与任意 JavaScript 前端一起使用。</p><p><strong>辅助库</strong></p><p>这些库可以让你的工作变得更轻松。React 开发人员可以使用很多辅助库，如下所示：</p><ul><li><p>Lodash</p></li><li><p>Moment</p></li><li><p>classnames</p></li><li><p>Numeral</p></li><li><p>RxJS</p></li><li><p>Ramda</p></li></ul><p>这些不一定都要学，路线图中的 Lodash、Moment 和 Classnames 是用黄色标注的，所以应该先从它们开始学习。</p><p><strong>测试</strong></p><p>测试是 React 开发者的一项重要技能，但经常被忽视，如果你想在竞争中保持领先，就要学习一些用于测试的库。这些库可用于单元测试、集成测试和端到端测试。</p><p>以下是路线图中提到的库：</p><p><strong>单元测试</strong></p><ul><li><p>Jest</p></li><li><p>Enzyme</p></li><li><p>Sinon</p></li><li><p>Mocha</p></li><li><p>Chai</p></li><li><p>AVA</p></li><li><p>Tape</p></li></ul><p><strong>端到端测试</strong></p><ul><li><p>Selenium, Webdriver</p></li><li><p>Cypress</p></li><li><p>Puppeteer</p></li><li><p>Cucumber.js</p></li><li><p>Nightwatch.js</p></li></ul><p><strong>集成测试</strong></p><ul><li>Karma</li></ul><p>你可以学习你想学习的库，但建议一定要学习 Jest 和 Enzyme。</p><p><strong>国际化</strong></p><p>这是前端开发的另一个重要主题。你可能需要支持日本、中国、西班牙和其他欧洲国家的本地 GUI 版本。</p><p>路线图中建议你学习以下技术，它们都很好理解：</p><ul><li><p>React Intl</p></li><li><p>React i18next</p></li></ul><p>这两个库都提供了 React 组件和 API 来格式化日期、数字和字符串，包括复数和处理翻译。</p><p><strong>服务器端渲染</strong></p><p>你可能会想，服务器端渲染和客户端渲染之间有什么区别。在使用客户端渲染时，你的浏览器会下载一个最小的 HTML 页面，然后通过 JavaScript 并将内容填充到页面中。</p><p>在使用服务器端渲染时，React 组件是在服务器上进行渲染的，将输出的 HTML 内容传到客户端或浏览器。</p><p>路线图推荐了以下的服务器端渲染：</p><ul><li><p>Next.js</p></li><li><p>After.js</p></li><li><p>Rogue</p></li></ul><p>不过我建议学习 Next.js 应该足够了。</p><p><strong>静态站点生成器</strong></p><p>Gatsby.js 是一个现代静态站点生成器。你可以使用 Gatsby 创建个性化的登录网站体验。它将你的数据与 JavaScript 相结合，并创建格式良好的 HTML 内容。</p><p><strong>后端框架集成</strong></p><p>React on Rails 将 Rails 与 Facebook 的 React 前端框架（服务器渲染）集成在一起。它提供了服务器渲染，通常用于 SEO 爬虫索引和 UX。</p><h3 id="4、移动端"><a href="#4、移动端" class="headerlink" title="4、移动端"></a>4、移动端</h3><p>React Native 正迅速成为使用 JavaScript 开发具有原生外观的移动应用程序的标准方法。</p><p>路线图中建议你学习以下库：</p><ul><li><p>React Native</p></li><li><p>Cordova/PhoneGap</p></li><li><p>Flutter—————–本人添加</p></li></ul><p>但我认为只要学习 React Native 就足够了。<br>这里补充一句我个人想法，现在应该要关注一下Flutter的发展了—————–本人添加</p><h3 id="5、桌面端"><a href="#5、桌面端" class="headerlink" title="5、桌面端"></a>5、桌面端</h3><p>还有一些基于 React 的框架可用于构建像 React Native Windows 这样的桌面 GUI，让你可以使用 React 构建原生 UWP 和 WPF 应用程序。</p><p>路线图建议使用以下几个库：</p><ul><li><p>Proton Native</p></li><li><p>Electron</p></li><li><p>React Native Windows</p></li></ul><p>它们都是进阶的内容，如果你已经掌握了 React，可以看一下它们。</p><h3 id="6、虚拟现实"><a href="#6、虚拟现实" class="headerlink" title="6、虚拟现实"></a>6、虚拟现实</h3><p>如果你对构建基于虚拟现实的应用程序感兴趣，还可以了解以下像 React 360 这样的框架，让你可以通过 React 开发 VR 体验。如果你对这个领域感兴趣，可以进一步了解 React 360。</p><p>英文原文：</p><p><a href="https://hackernoon.com/the-2018-react-js-roadmap-4d0a43814c02" target="_blank" rel="noopener">https://hackernoon.com/the-2018-react-js-roadmap-4d0a43814c02</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;作者｜javinpaul&lt;br&gt;译者｜无明&lt;br&gt;转发自 | 前端之巅公众号&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;之前我们已经介绍
      
    
    </summary>
    
      <category term="分享" scheme="http://cansolve.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="react" scheme="http://cansolve.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>es6中的promise解读</title>
    <link href="http://cansolve.cn/2018/11/23/daily8/"/>
    <id>http://cansolve.cn/2018/11/23/daily8/</id>
    <published>2018-11-23T11:45:40.000Z</published>
    <updated>2018-12-19T09:52:38.175Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><blockquote><p>作者：离秋<br>链接：<a href="https://juejin.im/post/5bed21156fb9a04a0c2e025d" target="_blank" rel="noopener">https://juejin.im/post/5bed21156fb9a04a0c2e025d</a></p></blockquote><blockquote><p>简单的说它是一个异步流程的控制手段。是一个代表了异步操作最终完成或者失败的对象。</p></blockquote><h3 id="promise的优点"><a href="#promise的优点" class="headerlink" title="promise的优点"></a>promise的优点</h3><ul><li><p>promise解决了回调地狱的问题</p></li><li><p>promise可以支持多个并发的请求</p></li><li><p>promise的错误传播机制可以统一的处理错误信息</p></li></ul><h3 id="回调地狱问题"><a href="#回调地狱问题" class="headerlink" title="回调地狱问题"></a>回调地狱问题</h3><blockquote><p>在传统的ajax调用过程中，下面以jquery.ajax为例。如果需求中要多次进行ajax交互，并且上一次的返回结果还要被下一次的ajax使用，代码基本上会变成：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">   type: &quot;POST&quot;,</span><br><span class="line">   url: &quot;some.php&quot;,</span><br><span class="line">   data: &quot;name=John&amp;location=Boston&quot;,</span><br><span class="line">   success: function(msg)&#123;</span><br><span class="line">       $.ajax(&#123;</span><br><span class="line">           type: &quot;POST&quot;,</span><br><span class="line">           url: &quot;some.php&quot;,</span><br><span class="line">           data: msg,</span><br><span class="line">           success: function(msg2)&#123;</span><br><span class="line">             ...//多次调用</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>现在还只是两次调用关系，如果是多次调用将会引发下面的问题</p></blockquote><ol><li><p>多次调用不利于代码的管理于维护</p></li><li><p>发生错误时不能及时准备的定位错误位置</p></li><li><p>只要又一次不成功就不能进行下面的逻辑，不方便进行错误处理。</p></li></ol><blockquote><p>promise的链式调用就很好的解决了这个问题</p></blockquote><h3 id="Promise的三种状态"><a href="#Promise的三种状态" class="headerlink" title="Promise的三种状态"></a>Promise的三种状态</h3><ul><li><p>Pending Promise对象实例创建时候的初始状态</p></li><li><p>resolve 可以理解为成功的状态</p></li><li><p>Reject 可以理解为失败的状态</p></li></ul><blockquote><p>promise 中的状态只能是从等待状态转换到成功状态或者失败状态，且状态转变之后不可逆。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/167164a42f989193?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><img src="https://user-gold-cdn.xitu.io/2018/11/15/167164a42f989193?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h3 id="一个简单的promise"><a href="#一个简单的promise" class="headerlink" title="一个简单的promise"></a>一个简单的promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let  p  =  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(2)</span><br><span class="line">//1 2</span><br></pre></td></tr></table></figure><blockquote><p>promise里面只接受一个参数，叫做执行器函数，这个函数会同步执行。也就是说上面代码中的箭头函数被同步执行，得到的结果也就是1和2</p></blockquote><h3 id="promise中的then"><a href="#promise中的then" class="headerlink" title="promise中的then"></a>promise中的then</h3><blockquote><p>每一个promise的实例上都有一个then方法，这个方法上有两个参数，一个是成功的回调，一个是失败的回调。而取决于成功或者失败的是promise的执行器函数中执行的是成功还是失败。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let  p  =  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    resolve();//调用resolve会走到then的成功回调</span><br><span class="line">    //reject();//调用resolve会走到then的失败回调</span><br><span class="line">&#125;);</span><br><span class="line">p.then(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        console.log(&apos;成功&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    , () =&gt; &#123;</span><br><span class="line">        console.log(&apos;失败&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    //1 成功</span><br></pre></td></tr></table></figure><blockquote><p>如果既不调用resolve也不调用reject，promise则一直处于等待状态，也就不会走到then方法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let  p  =  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        console.log(&apos;成功&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    , () =&gt; &#123;</span><br><span class="line">        console.log(&apos;失败&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    //1</span><br></pre></td></tr></table></figure><blockquote><p>如果你既调用resolve也调用reject，那么谁在前面执行就走谁的对应回调函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let  p  =  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    resolve()//先调用成功</span><br><span class="line">    reject()</span><br><span class="line">&#125;);</span><br><span class="line">p.then(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        console.log(&apos;成功&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    , () =&gt; &#123;</span><br><span class="line">        console.log(&apos;失败&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    //1 成功</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let  p  =  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    reject()//先调用失败</span><br><span class="line">    resolve()</span><br><span class="line">&#125;);</span><br><span class="line">p.then(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        console.log(&apos;成功&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    , () =&gt; &#123;</span><br><span class="line">        console.log(&apos;失败&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    //1 失败</span><br></pre></td></tr></table></figure><blockquote><p>如果代码出错则会直接走reject的回调</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let  p  =  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    throw  new  Error(&apos;出错了~&apos;)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        console.log(&apos;成功&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    , () =&gt; &#123;</span><br><span class="line">        console.log(&apos;失败&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    //1 失败</span><br></pre></td></tr></table></figure><blockquote><p>一个promise的实例可以then多次</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let  p  =  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&apos;成功了&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">    console.log(data)//成功了</span><br><span class="line">&#125;);</span><br><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">    console.log(data)//成功了</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="利用promise解决回调地狱"><a href="#利用promise解决回调地狱" class="headerlink" title="利用promise解决回调地狱"></a>利用promise解决回调地狱</h3><blockquote><p>能够规避异步操作中回调地狱的问题，其本质取决于promise的链式调用。 假设需求如下，a.txt文件的内容为b.txt,b.txt文件的内容是一段描述文字，现在要求用a.txt的得到最终的描述文字，代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let  fs  =  require(&apos;fs&apos;);</span><br><span class="line">//首先将异步方法封装在一个promise中，异步结果成功调用resolve方法，失败调用reject方法。</span><br><span class="line">function  read(url) &#123;</span><br><span class="line">    return  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        fs.readFile(url, &apos;utf8&apos;, function (err, data) &#123;</span><br><span class="line">            if (err) reject();</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//因为read方法返回的是一个promise，所以可以使用promise的then方法</span><br><span class="line">read(&apos;a.txt&apos;).then((data) =&gt; &#123;</span><br><span class="line">//第一次异步成功后拿到结果继续返回一个promise可以实现链式调用。</span><br><span class="line">    console.log(data);//b.txt</span><br><span class="line">return  read(data);</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;</span><br><span class="line">//最后两次的结果分别对应两次异步的返回内容</span><br><span class="line">    console.log(data)//描述文字</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>总结：如果一个promise的then方法中还返回另一个promise，那么这个promise的成功状态会走到外层promise的下一次then方法的成功，如果失败，返回外层promise下一次then的失败。</p></blockquote><h3 id="promise的链式调用"><a href="#promise的链式调用" class="headerlink" title="promise的链式调用"></a>promise的链式调用</h3><ul><li>如果then中返回的是一个普通值，就会走到下一次then的成功回调。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read().then((data) =&gt; &#123;</span><br><span class="line">return  111</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;</span><br><span class="line">console.log(data)//111</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;)</span><br></pre></td></tr></table></figure><ul><li>如果then中返回的是一个错误，就会走到下一次then的失败回调。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read().then((data) =&gt; &#123;</span><br><span class="line">throw  new  Error(&apos;出错了~&apos;)</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;</span><br><span class="line">console.log(data)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">console.log(err)//出错了~</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>如果then中什么也不返回，就会走到下一次then的成功回调，得到的值为undefined。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read().then((data) =&gt; &#123;</span><br><span class="line">cons.log(111)</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;</span><br><span class="line">console.log(data)//undefined</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>如果想统一处理错误内容，可以使用catch。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read().then((data) =&gt; &#123;</span><br><span class="line">throw  new  Error(&apos;出错了~&apos;)</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;&#125;, (err) =&gt; &#123;&#125;).catch((err)=&gt;&#123;</span><br><span class="line">    //错误处理</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>统一处理错误后，还可以使用then。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read().then((data) =&gt; &#123;</span><br><span class="line">throw  new  Error(&apos;出错了~&apos;)</span><br><span class="line">&#125;, (err) =&gt; &#123; &#125;).then((data) =&gt; &#123;&#125;, (err) =&gt; &#123;&#125;).catch((err)=&gt;&#123;</span><br><span class="line">    //错误处理</span><br><span class="line">&#125;).then((data) =&gt; &#123;&#125;, (err) =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><blockquote><p>all方法可以处理多个请求并发的问题。参数是一个数组。all方法调用后会返回一个新的promise。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let  fs  =  require(&apos;fs&apos;);</span><br><span class="line">function  read(url) &#123;</span><br><span class="line">    return  new  Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        fs.readFile(url, &apos;utf8&apos;, function (err, data) &#123;</span><br><span class="line">            if (err) reject();</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Promise.all([read(&apos;1.txt&apos;), read(&apos;2.txt&apos;)]).then((data) =&gt; &#123;</span><br><span class="line">    console.log(data)//[ &apos;文本1内容&apos;, &apos;文本2内容&apos; ]</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在all方法中一个失败了就全部失败，所以都成功了才会走成功回调。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([read(&apos;1.txt&apos;), read(&apos;3.txt&apos;)]).then((data) =&gt; &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    console.log(&apos;失败了&apos;);//失败了</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><blockquote><p>多个请求中，谁的返回数据最快，结果就是谁</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.race([read(&apos;1.txt&apos;), read(&apos;2.txt&apos;)]).then((data) =&gt; &#123;</span><br><span class="line">    console.log(data)////文本2内容</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">    console.log(&apos;失败了&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><blockquote><p>返回一个成功的Promise</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&apos;123&apos;).then((data) =&gt; &#123;</span><br><span class="line">    console.log(data)//123</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><blockquote><p>返回一个失败的Promise</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(&apos;123&apos;).then((data) =&gt; &#123;</span><br><span class="line">    console.log(&apos;err&apos;, data)//err 123</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;作者：离秋&lt;br&gt;链接：&lt;a href=&quot;https://juejin.im/post/5bed21156fb9a04a0c2e02
      
    
    </summary>
    
      <category term="分享" scheme="http://cansolve.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="es6" scheme="http://cansolve.cn/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>重新理解一遍回流(reflow)与重绘(repaint)</title>
    <link href="http://cansolve.cn/2018/11/04/daily15/"/>
    <id>http://cansolve.cn/2018/11/04/daily15/</id>
    <published>2018-11-04T10:02:04.000Z</published>
    <updated>2019-01-04T10:37:56.420Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><p>一次页面重构过程中遇到的问题，回流和重绘，面试题中经常有，可是我之前一直不是很清楚这两步具体做了什么事情。今天刚好事情做完又看到这个问题，就去查了查资料，理解一下，写了这篇文章加深一下印象，有什么写的不好的希望大家多指正。</p><h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><p>这里得先从浏览器的渲染过程讲起，此处你也可以跳过，因为得先了解渲染过程才能知道回流和重排在哪个阶段执行。</p><p><img src="/2018/11/04/daily15/001.png" alt="webkit渲染过程"></p><p>从这个图就可以看出浏览器渲染过程；</p><ul><li><p>解析html和css，生成DOM树以及cssom；</p></li><li><p>html和css结合起来生成Render Tree；</p></li><li><p><strong>回流：</strong> 根据生成的渲染树，进行回流(Layout)，得到可见节点的几何信息（位置，大小）</p></li><li><p><strong>重排：</strong> 根据回流得到的信息结合渲染树，进行渲染展示</p><p>#</p></li></ul><h3 id="生成渲染树"><a href="#生成渲染树" class="headerlink" title="生成渲染树"></a>生成渲染树</h3><p>为了构建渲染树，浏览器主要完成了以下工作：</p><ol><li><p>从DOM树的根节点开始遍历每个<strong>可见节点</strong>。</p></li><li><p>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</p></li><li><p>根据每个可见节点以及其对应的样式，组合生成渲染树。</p></li></ol><p>这里说到了要遍历可见的节点，什么节点是不可见的。不可见的节点包括：</p><ol><li><p>一些不会渲染输出的节点，比如script、meta、link等。</p></li><li><p>一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</p></li></ol><p><strong>注意：渲染树只包含可见的节点</strong></p><h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><p>前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，<strong>当render树中的一部分或者全部因为大小边距等问题发生改变而需要重建的过程叫做回流</strong>。</p><p>为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">            &lt;title&gt;Critial Path: Hello world!&lt;/title&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">            &lt;div style=&quot;width: 50%&quot;&gt;</span><br><span class="line">                &lt;div style=&quot;width: 50%&quot;&gt;Hello world!&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;</span><br></pre></td></tr></table></figure><p>我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图）</p><p><img src="/2018/11/04/daily15/002.png" alt=""></p><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>最终，我们通过构造渲染树和回流阶段，有了DOM结构的节点，有了节点的位置样式，接下来就开始渲染到页面上，<strong>当元素的一部分属性发生变化，如外观背景色不会引起布局变化而需要重新渲染的过程叫做重绘</strong></p><p>现在知道了浏览器的渲染过程，我们就来探讨下，何时会发生回流重绘。</p><h2 id="何时发生回流重绘"><a href="#何时发生回流重绘" class="headerlink" title="何时发生回流重绘"></a>何时发生回流重绘</h2><p>我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，所以可以理解当页面布局和几何信息发生变化的时候，肯定会发生回流。比如以下情况：</p><ul><li><p>添加或删除可见的DOM元素</p></li><li><p>元素的位置、尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</p></li><li><p>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</p></li><li><p>页面一开始渲染的时候（这肯定避免不了）</p></li><li><p>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s = document.body.style;</span><br><span class="line"> s.padding = &quot;2px&quot;; // 回流+重绘</span><br><span class="line"> s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘</span><br><span class="line"> s.color = &quot;blue&quot;; // 再一次重绘</span><br><span class="line"> s.backgroundColor = &quot;#ccc&quot;; // 再一次 重绘</span><br><span class="line"> s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘</span><br><span class="line"> // 添加node，再一次 回流+重绘</span><br><span class="line"> document.body.appendChild(document.createTextNode(&apos;abc!&apos;));</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：回流一定会触发重绘，而重绘不一定会回流</strong></p><p>为什么：上面说了定义很明显—如外观背景色不会引起布局变化而需要重新渲染的过程叫做重绘，布局没有变化就不会发生回流；</p><p>触发回流的css 属性有这些:</p><p><img src="/2018/11/04/daily15/003.png" alt=""></p><p>而触发重绘的有这些:</p><p><img src="/2018/11/04/daily15/004.png" alt=""></p><p>说到这里大家都知道回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系，假设你直接操作body，比如在body最前面插入1个元素，会导致整个render tree回流，这样代价当然会比较高，但如果是指body后面插入1个元素，则不会影响前面元素的回流。</p><h2 id="浏览器的优化机制"><a href="#浏览器的优化机制" class="headerlink" title="浏览器的优化机制"></a>浏览器的优化机制</h2><p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>，比如当你访问以下属性或者使用以下方法：</p><ul><li><p>offsetTop、offsetLeft、offsetWidth、offsetHeight</p></li><li><p>scrollTop、scrollLeft、scrollWidth、scrollHeight</p></li><li><p>clientTop、clientLeft、clientWidth、clientHeight</p></li><li><p>getComputedStyle()</p></li><li><p>getBoundingClientRect</p></li><li><p>具体可以访问这个网站：<a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank" rel="noopener">https://gist.github.com/paulirish/5d52fb081b3570c81e3a</a></p></li></ul><p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列。</strong>如果要使用它们，最好将值缓存起来。</p><h2 id="最小化重绘和重排"><a href="#最小化重绘和重排" class="headerlink" title="最小化重绘和重排"></a>最小化重绘和重排</h2><p>由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。总结了以下几点：</p><p>1：用transform 代替 top，left ，margin-top， margin-left… 这些位移属性</p><p>2：用opacity 代替 visibility，但是要同时有translate3d 或 translateZ 这些可以创建的图层的属性存在才可以阻止回流</p><p>但是第二点经过我的实验，发现如果不加 transform: translateZ(0) 配合opacity的话还是会产生回流的，而只用visibility 就只会产生重绘不会回流</p><p>而 opacity 加上 transform: translateZ/3d 这个属性之后便不会发生回流和重绘了</p><p>3：不要直接使用js操作dom元素的样式，选择用一个class 代替之。</p><p>4：如果确实需要用 js 对 dom 设置多条样式那么可以将这个dom 先隐藏，然后再对其设置</p><p>5：不要在循环内获取dom 的样式例如：offsetWidth, offsetHeight, clientWidth, clientHeight… 这些。浏览器有一个回流的缓冲机制，即多个回流会保存在一个栈里面，当这个栈满了浏览器便会一次性触发所有样式的更改且刷新这个栈。但是如果你多次获取这些元素的实际样式，浏览器为了给你一个准确的答案便会不停刷新这个缓冲栈，导致页面回流增加。</p><p>所以为了避免这个问题，应该用一个变量保存在循环体外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">clientWidth在循环体内：</span><br><span class="line">function startTest1() &#123;</span><br><span class="line">      const box1 = document.querySelector(&apos;#box1&apos;);      </span><br><span class="line">      const p = document.querySelectorAll(&apos;p&apos;);</span><br><span class="line">      for (let i = 0; i &lt; p.length; i++) &#123;</span><br><span class="line">        p[i].style.width = box1.clientWidth + &apos;px&apos;;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">clientWidth在循环体外：</span><br><span class="line">function startTest2() &#123;</span><br><span class="line">      const box2 = document.querySelector(&apos;#box2&apos;);</span><br><span class="line">      const p = document.querySelectorAll(&apos;p&apos;);</span><br><span class="line">      const width = box2.clientWidth;</span><br><span class="line">      for (let i = 0; i &lt; p.length; i++) &#123;</span><br><span class="line">        p[i].style.width = width + &apos;px&apos;;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>6：不要使用table 布局，因为table 的每一个行甚至每一个单元格的样式更新都会导致整个table 重新布局</p><p>7：动画的速度按照业务按需决定</p><p>8：对于频繁变化的元素应该为其加一个 transform 属性，对于视频使用video 标签</p><p>9：必要时可以开启 GPU 加速，但是不能滥用</p><ol><li><p>使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘</p></li><li><p>对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p><h4 id="css3硬件加速的坑"><a href="#css3硬件加速的坑" class="headerlink" title="css3硬件加速的坑"></a>css3硬件加速的坑</h4><ul><li><p>如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。</p></li><li><p>在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。</p></li></ul></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;p&gt;一次页面重构过程中遇到的问题，回流和重绘，面试题中经常有，可是我之前一直不是很清楚这两步具体做了什么事情。今天刚好事情做完又看到这个问题，就去查了查资料，理
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="其他" scheme="http://cansolve.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>viewport-fit解决iPhone X、XS、XS Max、XR刘海屏问题</title>
    <link href="http://cansolve.cn/2018/10/10/daily2/"/>
    <id>http://cansolve.cn/2018/10/10/daily2/</id>
    <published>2018-10-10T03:28:29.000Z</published>
    <updated>2018-12-14T07:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><h4 id="一次活动页面发现的iPhone-X、XS、XS-Max、XR刘海屏问题"><a href="#一次活动页面发现的iPhone-X、XS、XS-Max、XR刘海屏问题" class="headerlink" title="一次活动页面发现的iPhone X、XS、XS Max、XR刘海屏问题"></a>一次活动页面发现的iPhone X、XS、XS Max、XR刘海屏问题</h4><p>起因：游戏内嵌内嵌H5页面，提供的webview容器是全屏的，所以H5页面要处理以上设备的刘海问题【烦】。</p><p>尺寸了解我这里就不写了，尺寸问题我就不写了，<a href="https://blog.csdn.net/qq_33608748/article/details/82769570" target="_blank" rel="noopener">顶楼电梯</a></p><p>iPhone X 配备一个覆盖整个手机的全面屏,顶部的“刘海”突出来使得网站被限制在一个“安全区域”,在两侧边缘会出现白条儿。移除这个白条儿也不难,给 body 设置一个 background-color 就可以搞定。</p><p>但是我们内嵌的游戏页面背景色有时候不好设置背景色为纯色，另一种方法就是添加 viewport-fit=cover meta 标签,将整个网站扩展到整个屏幕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, viewport-fit=cover&quot;&gt;</span><br></pre></td></tr></table></figure><p>iPhone XS等手机还未发布之前，我们也是跟着学做已经做一些兼容来搞定iPhoneX。</p><p>这里只是横屏代码，竖屏同理；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var isIPhoneX = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 375 &amp;&amp; window.screen.width === 812;</span><br></pre></td></tr></table></figure><p>这里我们判断如果是iPhone X，把顶部增加高度30px的容器垫高，避开刘海头区域，各种方式都可以padding-left、absolute、margin-left。。。你能想到的方法都可以，这样标题正好避开刘海头。</p><p>因为自己当时还没有用iPhone X，只知道iPhone X有刘海头，不知道其他细节问题。</p><p>又到一年一度的9月份，苹果发布了3X机系列，有同事在Mac下的iPhone模拟器访问，发现这个页面iPhone XS Max下有问题。看了一下上面文章发现尺寸不一样，当初只判断了iPhone X加垫高，其他几个机型都未判断，所以就很自然的写了新机型，加上判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// iPhone X、iPhone XS</span><br><span class="line">var isIPhoneX = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 375 &amp;&amp; window.screen.width === 812;</span><br><span class="line">// iPhone XS Max</span><br><span class="line">var isIPhoneXSMax = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 414 &amp;&amp; window.screen.width === 896;</span><br><span class="line">// iPhone XR</span><br><span class="line">var isIPhoneXR = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 2 &amp;&amp; window.screen.height === 414 &amp;&amp; window.screen.width === 896;</span><br></pre></td></tr></table></figure><p>原来代码是if(isIPhoneX)垫高，现在改成if(isIPhoneX || isIPhoneXSMax || isIPhoneXR)垫高。</p><p>这里有个坑，官方提供的安全区域代码constant(safe-area-inset-top) env(safe-area-inset-top)，使用后都在刘海头下面，如图（黑灰色区域状态栏）：</p><p><img src="http://ons.me/wp-content/uploads/2018/10/4.jpg" alt=""></p><p>当初没有用安全区域代码，一方面是因为页面有悬浮容器，会悬浮到安全区域外部，兼容页面正文麻烦，另一方面就是正文内容靠下，离刘海头有一段距离，感觉太丑干脆不用。</p><p>总结：依旧不用安全区域代码，如果要做刘海头，if(isIPhoneX || isIPhoneXSMax || isIPhoneXR) 垫高44px。</p><p>备注：iPhone X、iPhone XS、iPhone XS Max刘海头高度30px，iPhone XR刘海头高度33px。本文提到的30px、33px、44px，均为initial-scale=1下，px是在通用属性下，用rem写页面的请自行转换。设计稿像素应该都需要乘以2倍或3倍。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;h4 id=&quot;一次活动页面发现的iPhone-X、XS、XS-Max、XR刘海屏问题&quot;&gt;&lt;a href=&quot;#一次活动页面发现的iPhone-X、XS、XS-Ma
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="移动端" scheme="http://cansolve.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git 使用经验分享</title>
    <link href="http://cansolve.cn/2018/10/07/daily9/"/>
    <id>http://cansolve.cn/2018/10/07/daily9/</id>
    <published>2018-10-07T01:05:40.000Z</published>
    <updated>2018-12-20T08:19:53.780Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>Git 是分布式版本控制.每一台用户终端都可以充当中央仓库的角色,镜像整个仓库。 Git 主要对提交的全部文件制作一个快照并保存这个快照的索引，所以高效。</p><h3 id="Git开发流程"><a href="#Git开发流程" class="headerlink" title="Git开发流程"></a>Git开发流程</h3><p>Git开发过程中牵涉到：工作区、暂存区、仓库（本地仓库和远程仓库）</p><h3 id="Git-本地仓库常用操作"><a href="#Git-本地仓库常用操作" class="headerlink" title="Git 本地仓库常用操作"></a>Git 本地仓库常用操作</h3><ol><li>添加与删除暂存区操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git add 将文件加入到暂存区域</span><br><span class="line">git add . 添加当前目录的所有文件到暂存区</span><br><span class="line">git add [dir] 添加指定文件或文件夹到暂存区</span><br><span class="line">git add [file1] [file2] ... 添加指定文件到暂存区</span><br><span class="line">git add ./*.java 支持正则表达式</span><br><span class="line">git rm 删除文件.</span><br><span class="line">git rm [file1] [file2] 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">git rm --cached [file] 删除暂存索引, 保留文件, 即恢复成untracked状态，并且将这次删除放入暂存区（已跟踪）</span><br></pre></td></tr></table></figure><ol start="2"><li>提交本地库操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit 将暂存区域的文件提交到版本库</span><br><span class="line">git commit --amend -m [message] 使用一次新的commit，替代上一次提交。如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">git commit -a 则将已跟踪但未暂存的文件和已跟踪且已暂存的文件一起提交</span><br></pre></td></tr></table></figure><ol start="3"><li>本地分支操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout [branch] 切换分支</span><br><span class="line">git checkout -b [branch] 创建并且切换分支</span><br><span class="line">git checkout master file_name 放弃当前对文件file_name的修改，用本地库当前分支的文件进行替换</span><br><span class="line">git checkout commit_id file_name 取文件file_name的 在commit_id是的版本。</span><br></pre></td></tr></table></figure><ol start="4"><li>分支合并操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git merge [branch] 合并指定分支到当前分支，并且提交版本库，把分支的commit log带到新分支</span><br><span class="line">git merge [branch] --squash 合并指定分支到当前分支，不移动HEAD，不提交。需要进行一次额外的 git commit 来.带来好处不会把分支的 commit 记录带到新分支来。</span><br><span class="line">git merge [master] [branch] 将[master]合并到[branch] 分支</span><br><span class="line">git reset --hard HEAD 可以用此来撤销合并，其实就是回滚合并前的状态</span><br><span class="line">git cherry-pick [commit] 选择一个commit，合并进当前分支，用在部分功能合并</span><br></pre></td></tr></table></figure><h3 id="Git-远程仓库常用操作"><a href="#Git-远程仓库常用操作" class="headerlink" title="Git 远程仓库常用操作"></a>Git 远程仓库常用操作</h3><p>1.提交到远程库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br><span class="line">git push origin 当前分支与远程分支之间存在追踪关系（git clone，或手动建立 git branch --set-upstream master origin/next），则本地分支和远程分支都可以省略。</span><br><span class="line">git push 当前分支只有一个追踪分支，那么远程别名都可以省略</span><br></pre></td></tr></table></figure><p>2.取回远程仓库的变更但并不自动合并当前的工作分支（fetch）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master 取回远程 origin 的 master 分支变更该命令经常与 git checkout 搭配使用，用来获取远程仓库的分支</span><br></pre></td></tr></table></figure><p>3.获取更新 并且合并当前分支（pull）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull (= git fetch + git merge)</span><br><span class="line"> git pull 命令相当于 git fetch + git merge, 即从远程仓库中拉取所有你本地仓库中还没有的数据, 并自动合并到当前工作分支.</span><br></pre></td></tr></table></figure><h3 id="开发中常用"><a href="#开发中常用" class="headerlink" title="开发中常用"></a>开发中常用</h3><p>一. 获取远程分支，进入分支开发功能,开发完后合并主干，最后提交主版本到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1 git remote show origin （查看远程分支情况）</span><br><span class="line">    </span><br><span class="line">2 git fetch origin new_branch (获取远程分支的变更到本地仓库)</span><br><span class="line">    </span><br><span class="line">3 git checkout new_branch （切换分支new_branch进行开发）</span><br><span class="line">    </span><br><span class="line">4 开发相关功能文件</span><br><span class="line">    </span><br><span class="line">5 git add file</span><br><span class="line">    </span><br><span class="line">6 git commit</span><br><span class="line">    </span><br><span class="line">7 git checkout master （切换到主干）</span><br><span class="line">    </span><br><span class="line">8 git merge new_branch (把new_branch合并到当前的所在分支)</span><br><span class="line">    </span><br><span class="line">9 git push origin master</span><br><span class="line">    </span><br><span class="line">10 git branch -d new_branch (删除分支)</span><br><span class="line">    </span><br><span class="line">11 git branch (查看当前分支情况，确认删除)</span><br></pre></td></tr></table></figure><p>二. 文件修改后想还原到上次提交的状态（不保留修改内容）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout  (文件未提交到暂存区用法)</span><br><span class="line">git checkout HEAD  （如提交到暂存区执行该命令后，不保存暂存区）</span><br><span class="line">git reset --hard HEAD （如提交到暂存区执行该命令后，不保存暂存区）</span><br></pre></td></tr></table></figure><p>三. 撤销上一次提交本地仓库的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 git log (查看提交版本信息) git reset 前一个SHA值（7位数）（撤销commit，会保留提交前的修改内容）</span><br><span class="line">    </span><br><span class="line">2 git reset --soft HEAD^1 退到commit前，保留stage（暂存区）和提交前修改内容</span><br><span class="line">    </span><br><span class="line">3 git reset --mixed HEAD^1 退到commit前，保留提交前修改内容（默认）</span><br><span class="line">    </span><br><span class="line">4 git reset --hard HEAD^1退到commit前且恢复到未修改时内容（内容退回到上次commit时的状态）</span><br><span class="line">    </span><br><span class="line">5 git reset SHA值  让单个文件退回到指定版本</span><br></pre></td></tr></table></figure><p>四. 回滚区别(reset与revert)</p><p>共同点：都可用回滚</p><p>不同点：<br>reset 可回滚到之前某个提交（可能是批量回滚），删除被回滚的log，另外不可回滚到已 push 过的的提交，否则回滚后当前版本低于远程版本，被禁止提交。<br>使用场景：对本地仓库中未push的提交的回滚<br>revert 撤销一个提交的同时会创建一个新的提交<br>可用于回滚被 push 过的提交。被回滚的版本git log不会被删除。<br>使用场景：你在追踪一个 bug，然后你发现它是由一个提交造成的，这时候撤销就很有用。与其说自己去修复它，然后提交一个新的快照，不如用 git revert，它帮你做了所有的事情。</p><p>五. 当前文件与本地仓库文件比较区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff 比较的是工作目录树与暂存区之间的区别</span><br><span class="line">git diff --staged 比较的是暂存区和版本库最后一个版本的区别。</span><br><span class="line">git diff HEAD 比较的是工作目录树（包括暂存的和未暂存的修改）与版本库最后一个版本的差别。</span><br></pre></td></tr></table></figure><p>六. 保持本地仓库与远程仓库分支同步的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 git remote show origin （显示本地与远程仓库所有分支情况）如远程分支删除后，本地还有，用 git branch -a 是看不出远程仓库分支已经被删除</span><br><span class="line">    </span><br><span class="line">2 git remote prune origin --dry-run （该命令显示本地无效分支）</span><br><span class="line">    </span><br><span class="line">3 git remote prune origin （同步本地与远程仓库变更（所有分支），执行后可用git branch -a查看）</span><br><span class="line">    </span><br><span class="line">4 git fetch origin [branch]</span><br></pre></td></tr></table></figure><p>七. Git 客户端工具</p><p>可视化操作工具推荐使用：<a href="[https://www.sourcetreeapp.com/](https://www.sourcetreeapp.com/">Sourcetree</a>)</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;h3 id=&quot;版本控制&quot;&gt;&lt;a href=&quot;#版本控制&quot; class=&quot;headerlink&quot; title=&quot;版本控制&quot;&gt;&lt;/a&gt;版本控制&lt;/h3&gt;&lt;p&gt;Git
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="git" scheme="http://cansolve.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的this</title>
    <link href="http://cansolve.cn/2018/09/22/daily5/"/>
    <id>http://cansolve.cn/2018/09/22/daily5/</id>
    <published>2018-09-22T08:11:23.000Z</published>
    <updated>2018-12-20T02:54:25.567Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><p>原文链接：<a href="https://flaviocopes.com/javascript-this/" target="_blank" rel="noopener">flaviocopes.com</a></p><p>翻译：我可是兔子</p><p><code>this</code>在不同的地方被调用有不同的值。</p><p>不知道这些细节可能会导致很多头疼的问题, 所以你不妨花5分钟的时间来了解一下这些坑。</p><h2 id="this在严格模式下"><a href="#this在严格模式下" class="headerlink" title="this在严格模式下"></a><code>this</code>在严格模式下</h2><p>除了在声明的对象内被调用,<code>this</code>在<strong>严格模式下</strong>永远是<code>undefined</code>。</p><p>注意我提到的是严格模式。如果不是在严格模式下 (在js的头部，你没有明确的添加<code>&#39;use strict&#39;</code>关键字 ), 那么你就处在非严格模式的状态下,<code>this</code>在这个环境下， 除了我下面提到的特殊案例外 ，this指代的是全局对象的值。</p><p>在浏览器的上下文环境中，这个值就是<code>window</code>。</p><h2 id="在函数方法中的this"><a href="#在函数方法中的this" class="headerlink" title="在函数方法中的this"></a>在函数方法中的<code>this</code></h2><p>方法就是以函数形式附属于一个对象。</p><p>函数可以有不同的声明形式。</p><p>下面就是其中的一种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  maker: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;,</span><br><span class="line"></span><br><span class="line">  drive() &#123;</span><br><span class="line">    console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.drive()</span><br><span class="line">//Driving a Ford Fiesta car!</span><br></pre></td></tr></table></figure><p>在这个例子中，使用了常规的函数声明的形式,<code>this</code>自动绑定为car这个对象。</p><p>注意: 上面的函数声明是<code>drive: function() {</code>…这样声明的缩写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  maker: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;,</span><br><span class="line"></span><br><span class="line">  drive: function() &#123;</span><br><span class="line">    console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面的例子一样的指代:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  maker: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.drive = function() &#123;</span><br><span class="line">  console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.drive()</span><br><span class="line">//Driving a Ford Fiesta car!</span><br></pre></td></tr></table></figure><p>在同样的语境下，使用箭头函数来声明函数，<code>this</code>的指代是不一样的，它属于词法（静态）绑定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  maker: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;,</span><br><span class="line"></span><br><span class="line">  drive: () =&gt; &#123;</span><br><span class="line">    console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.drive()</span><br><span class="line">//Driving a undefined undefined car!</span><br></pre></td></tr></table></figure><h2 id="使用箭头函数"><a href="#使用箭头函数" class="headerlink" title="使用箭头函数"></a>使用箭头函数</h2><p>你不能在箭头函数中像其他正常的函数声明形式那样给函数绑定一个值来改变this的值。</p><p>导致这个的主要原因是箭头函数的工作原理。<code>this</code>在箭头函数中是<strong>词法绑定</strong>的, 也就是说它的值仅取决于它在哪个对象下被定义。</p><h2 id="明确地传递一个对象来改变this的值"><a href="#明确地传递一个对象来改变this的值" class="headerlink" title="明确地传递一个对象来改变this的值"></a>明确地传递一个对象来改变<code>this</code>的值</h2><p>JavaScript提供了一些方法来映射this所指代的对象，从而得到你想要的值。</p><p>在<strong>函数声明</strong>的阶段，使用<code>bind()</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  maker: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const drive = function() &#123;</span><br><span class="line">  console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)</span><br><span class="line">&#125;.bind(car)</span><br><span class="line"></span><br><span class="line">drive()</span><br><span class="line">//Driving a Ford Fiesta car!</span><br></pre></td></tr></table></figure><p>你可以绑定一个已定义的对象来改变<code>this</code>的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  maker: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;,</span><br><span class="line"></span><br><span class="line">  drive() &#123;</span><br><span class="line">    console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const anotherCar = &#123;</span><br><span class="line">  maker: &apos;Audi&apos;,</span><br><span class="line">  model: &apos;A4&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">car.drive.bind(anotherCar)()</span><br><span class="line">//Driving a Audi A4 car!</span><br></pre></td></tr></table></figure><p>使用<code>call()</code>或者<code>apply()</code>, 在<strong>函数调用</strong>阶段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  maker: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const drive = function(kmh) &#123;</span><br><span class="line">  console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car at $&#123;kmh&#125; km/h!)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drive.call(car, 100)</span><br><span class="line">//Driving a Ford Fiesta car at 100 km/h!</span><br><span class="line"></span><br><span class="line">drive.apply(car, [100])</span><br><span class="line">//Driving a Ford Fiesta car at 100 km/h!</span><br></pre></td></tr></table></figure><p>第一个传递给<code>call()</code>或者<code>apply()</code>的参数是新的<code>this</code>所指代的值。 call() 和 apply()两个函数的差异在于第二个参数，apply() 接受的是一个数组来作为它的参数，而call() 函数接受的是一串参数列表。</p><h2 id="DOM事件处理函数的特殊案例"><a href="#DOM事件处理函数的特殊案例" class="headerlink" title="DOM事件处理函数的特殊案例"></a>DOM事件处理函数的特殊案例</h2><p>在浏览器事件处理函数的时候,<code>this</code>指代的是HTML对象，像下面的这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&apos;#button&apos;).addEventListener(&apos;click&apos;, function(e) &#123;</span><br><span class="line">  console.log(this) //HTMLElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但你可以使用bind() 函数来改变this值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&apos;#button&apos;).addEventListener(</span><br><span class="line">  &apos;click&apos;,</span><br><span class="line">  function(e) &#123;</span><br><span class="line">    console.log(this) //Window if global, or your context</span><br><span class="line">  &#125;.bind(this)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;p&gt;原文链接：&lt;a href=&quot;https://flaviocopes.com/javascript-this/&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
      <category term="分享" scheme="http://cansolve.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="js" scheme="http://cansolve.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>移动端滚动事件overflow-y:scroll使用心得</title>
    <link href="http://cansolve.cn/2018/09/18/daily4/"/>
    <id>http://cansolve.cn/2018/09/18/daily4/</id>
    <published>2018-09-18T07:45:43.000Z</published>
    <updated>2018-12-18T08:06:30.332Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><blockquote><p>作者：夏大师</p><p><a href="https://www.cnblogs.com/xiahj/p/8036419.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiahj/p/8036419.html</a></p></blockquote><h2 id="1-webkit-overflow-scrolling-touch是什么？"><a href="#1-webkit-overflow-scrolling-touch是什么？" class="headerlink" title="1. -webkit-overflow-scrolling:touch是什么？"></a>1. -webkit-overflow-scrolling:touch是什么？</h2><p>MDN上是这样定义的：</p><blockquote><p><code>-webkit-overflow-scrolling</code>属性控制元素在移动设备上是否使用滚动回弹效果.<br><code>auto</code>: 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。<br><code>touch</code>: 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。</p></blockquote><p>在移动端上，在你用<code>overflow-y:scorll</code>属性的时候，你会发现滚动的效果很木，很慢，这时候可以使用<code>-webkit-overflow-scrolling:touch</code>这个属性，让滚动条产生<strong>滚动回弹</strong>的效果，就像ios原生的滚动条一样流畅。</p><h2 id="2-解决safari布局抖动的例子"><a href="#2-解决safari布局抖动的例子" class="headerlink" title="2. 解决safari布局抖动的例子"></a>2. 解决safari布局抖动的例子</h2><p><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103503613-582028000.png" alt=""></p><p><strong>想实现一个布局为header、main、bottom的布局，其中头部和底部通过fixed固定，中间部分通过滚动条滑动。</strong></p><p>如果目的是实现只要中间的内容超过屏幕高度时，中间内容会自动滚动的效果的话，<code>main</code>部分加上上下的<code>padding</code>，然后不需要自己添加任何滚动条属性，当超出高度时，<code>body</code>会自动产生滚动条。这样我们的目的其实是实现了的。</p><p>但是在<strong>safari</strong>上，当超出高度，页面往下滑时，浏览器底部的工具栏<strong>会随着页面一起晃动</strong>（向下滚动时会拉起底部工具栏），造成了很不好的体验。所以我们想在中间的<code>main</code>部分加一个<strong>独立的滚动条</strong>。</p><h3 id="2-1-方案一"><a href="#2-1-方案一" class="headerlink" title="2.1 方案一"></a>2.1 方案一</h3><p>在main上使用fixed定位，加上overflow-y属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.main &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 50px;</span><br><span class="line">    bottom: 50px;</span><br><span class="line">    overflow-y: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过不推荐这个fixed方案，因为页面偶尔卡住不动，下面说到了这个问题。</p><h3 id="2-2-方案二"><a href="#2-2-方案二" class="headerlink" title="2.2 方案二"></a>2.2 方案二</h3><p>中间的<strong>main不设定位</strong>，<strong>高度100%</strong>，再<strong>padding头部和尾部</strong>，</p><p>其中头部和底部的定位设为<code>absolute</code>会比设为<code>fixed</code>体验更好（况且fix布局在移动端本来就有各种各样的问题，还是尽量避开:) ）。</p><p>大致代码如下，仍是<code>overflow-y</code>和<code>-webkit-overflow-scrolling</code>，重点在于中间部分依照文本流布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html, body &#123;</span><br><span class="line"> height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">main &#123;</span><br><span class="line">    padding: 50px 0;</span><br><span class="line">    height: 100%;</span><br><span class="line">    overflow-y: scroll;</span><br><span class="line">    -webkit-overflow-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-探究-webkit-overflow-scrolling-touch偶尔卡住或不能滑动的bug"><a href="#3-探究-webkit-overflow-scrolling-touch偶尔卡住或不能滑动的bug" class="headerlink" title="3. 探究-webkit-overflow-scrolling:touch偶尔卡住或不能滑动的bug"></a>3. 探究-webkit-overflow-scrolling:touch偶尔卡住或不能滑动的bug</h2><p>-webkit-overflow-scrolling:touch这个属性真的是各种坑，我研究这个属性已经大半年了，还没有发现能够在safari上完美使用无bug的例子。</p><blockquote><p>最常见的例子就是，</p><ul><li><p>在safari上，使用了<code>-webkit-overflow-scrolling:touch</code>之后，页面偶尔会卡住不动。</p></li><li><p>在safari上，点击其他区域，再在滚动区域滑动，滚动条无法滚动的bug。</p></li><li><p>通过动态添加内容撑开容器，结果根本不能滑动的bug。</p></li></ul></blockquote><p>在网上也看到了一些人在问这个问题，不过不多，国外倒是讨论的更多一点，描述如下。</p><p><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103539816-1960538934.png" alt=""><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103539816-1960538934.png" alt=""></p><p>偶尔卡住的问题，解决方案网上众说纷纭，遇到了很多相同的说法，比如如果卡住不动的话，就加一个<code>z-index</code>，就能解决该问题的说法。</p><p>在试了很多次之后，这种说法没有一次解决过这个问题。这个说法能够传播出来，可能是使用者当时在使用的时候遇到了<code>-webkit-overflow-scrolling:touch</code>点透或者层级的问题。所以该方案不具有适用性。</p><p>所以这个东西真的让我很苦恼了很久，以致于那段时间所有的滚动条不是通过body自己滚动，就是使用iScroll这样的库，繁琐地让我几乎想要放弃移动web，拥抱hybrid，不过在stackoverflow潜水了很久之后，总结了以下几种解决方案：</p><h3 id="3-1-保证使用了该属性的元素上没有设置定位"><a href="#3-1-保证使用了该属性的元素上没有设置定位" class="headerlink" title="3.1 保证使用了该属性的元素上没有设置定位"></a>3.1 保证使用了该属性的元素上没有设置定位</h3><p>如果出现偶尔卡住不动的情况，那么在使用该属性的元素上<strong>不设置定位</strong>或者手动设置定位为<strong><code>static</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: static</span><br></pre></td></tr></table></figure><p>这样会解决<strong>部分</strong>因为定位(relative、fixed、absolute)导致的页面偶尔不能滚动的bug。</p><blockquote><p>但是滑动到顶部继续手指往下滑，或者到底部继续往上滑，还是会触发卡住的问题（其实是整个页面上下回弹），说他算bug，其实就是ios8以上的特性，如果滚动区域大一点，用户不会觉得这是bug，如果小了，用户会不知道发生了什么而卡住了。<br>视频在这，有梯子的同学可以看一看<a href="https://www.youtube.com/watch?v=MkAVYbO_joo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=MkAVYbO_joo</a>。</p></blockquote><h3 id="3-2-如果添加动态内容页面不能滚动，让子元素height-1"><a href="#3-2-如果添加动态内容页面不能滚动，让子元素height-1" class="headerlink" title="3.2 如果添加动态内容页面不能滚动，让子元素height+1"></a>3.2 如果添加动态内容页面不能滚动，让子元素height+1</h3><p>如果在<code>-webkit-overflow-scrolling:touch</code>属性的元素上，想通过<strong>动态添加内容</strong>来撑开容器，触发滚动，是有bug 的，页面是会卡住不动的。</p><p>国内没有人讨论这个问题，国外倒是很多，例如下面的描述：</p><p><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103630754-707308829.png" alt=""><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103630754-707308829.png" alt=""></p><p>收集了很多资料，用了之后，下面的方法真正的解决了我的问题，真是直呼神奇，方案如下图：</p><p>图一：</p><p><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103636379-1667026180.png" alt=""><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103636379-1667026180.png" alt=""></p><p>图二：</p><p><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103640113-1071673514.png" alt=""><img src="https://images2017.cnblogs.com/blog/1294929/201712/1294929-20171214103640113-1071673514.png" alt=""></p><p>方法就是在<code>webkit-overflow-scrolling:touch</code>属性的<strong>下一层子元素</strong>上，将<strong>height加1%或1px</strong>。从而<strong>主动触发scrollbar</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main-inner &#123;</span><br><span class="line">    min-height: calc(100% + 1px)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以直接加伪元素上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main:after &#123;</span><br><span class="line">    min-height: calc(100% + 1px)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案不得不说真的好用。。</p><p>当然还有其他方案，不过要写js或者jq了，麻烦。</p><h3 id="3-3-为什么会有卡住不动的这个bug"><a href="#3-3-为什么会有卡住不动的这个bug" class="headerlink" title="3.3 为什么会有卡住不动的这个bug"></a>3.3 为什么会有卡住不动的这个bug</h3><p>这个bug产生于ios8以上（不十分肯定，但在ios5~7上需要手动使用translateZ(0)打开硬件加速）</p><p><code>Safari</code>对于<code>overflow-scrolling</code>用了原生控件来实现。对于有<code>-webkit-overflow-scrolling</code>的网页，会创建一个<code>UIScrollView</code>，提供子<code>layer</code>给渲染模块使用。</p><p>我想说作为一个苦逼的前端只能解决到这了。</p><h2 id="4-webkit-overflow-scrolling-touch的其他坑"><a href="#4-webkit-overflow-scrolling-touch的其他坑" class="headerlink" title="4. -webkit-overflow-scrolling:touch的其他坑"></a>4. -webkit-overflow-scrolling:touch的其他坑</h2><p>除此之外，这个属性还有很多bug，包括且不限于以下几种：</p><blockquote><ul><li><p>滚动中 scrollTop 属性不会变化</p></li><li><p>手势可穿过其他元素触发元素滚动</p></li><li><p>滚动时暂停其他 transition</p></li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;作者：夏大师&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiahj/p/8036419.html
      
    
    </summary>
    
      <category term="分享" scheme="http://cansolve.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="移动端" scheme="http://cansolve.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>基于react + bootstrap 的 react-admin</title>
    <link href="http://cansolve.cn/2018/09/14/daily3/"/>
    <id>http://cansolve.cn/2018/09/14/daily3/</id>
    <published>2018-09-14T07:52:19.000Z</published>
    <updated>2018-12-18T09:16:49.973Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><p><img src="/2018/09/14/daily3/WechatIMG10.jpeg" alt="效果图 1"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此 react-admin 项目是基于 bootstrap-ace 框架之上，用 react 全家桶 + bootstrap 的进行再次开发的，项目已经开源，项目地址在 github 上。</p><p>框架效果预览 <a href="http://www.pydyun.com/other/ace/index.html" target="_blank" rel="noopener">http://www.pydyun.com/other/ace/index.html</a><br>github地址 <a href="https://github.com/cansolve/react-manage" target="_blank" rel="noopener">github</a></p><h2 id="1-后台管理主要项目结构"><a href="#1-后台管理主要项目结构" class="headerlink" title="1. 后台管理主要项目结构"></a>1. 后台管理主要项目结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">demo //项目名</span><br><span class="line">  -- dist  //预编译，自动构建之后会生成的文件，默认初始化是没有当前这个文件</span><br><span class="line">  -- asserts  //静态资源目录，css,font,image</span><br><span class="line">  -- public  //html模板文件</span><br><span class="line">  -- webpack  //webpack配置文件</span><br><span class="line">    -- webpack.base.config.js  //公用</span><br><span class="line">    -- webpack.dev.config.js  //开发环境</span><br><span class="line">    -- webpack.prod.config.js  //生产环境</span><br><span class="line">  -- src  //js编写文件</span><br><span class="line">      -- index.js  // 初始化js</span><br><span class="line">      -- module  // 基础UI模块目录</span><br><span class="line">      -- tools   // js方法工具库目录</span><br><span class="line">      -- action     // action 目录</span><br><span class="line">      -- component  // 对应的模块 目录</span><br><span class="line">      -- dispatch   // dispatch 目录</span><br><span class="line">      -- reducers   // reducers 目录</span><br><span class="line">      -- index.js   // 前端渲染</span><br><span class="line">      -- router.js  // 前端路由</span><br><span class="line">      -- store.js   // store 文件 </span><br><span class="line">  -- .babelr   //babel的校验文件</span><br><span class="line">  -- .eslintrc  //js编写校验配置文件</span><br><span class="line">  -- .gitignore  //git过滤文件</span><br><span class="line">  -- package.json  //node 安装包文件</span><br><span class="line">  -- README.md   //readme 文件</span><br></pre></td></tr></table></figure><h2 id="2-本地必须要有node和git环境"><a href="#2-本地必须要有node和git环境" class="headerlink" title="2. 本地必须要有node和git环境"></a>2. 本地必须要有<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node</a>和<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>环境</h2><ul><li>webpack 4</li><li>bootstrap + ace</li><li>react 16</li><li>react-router 4</li><li>redux 3</li><li>babel</li><li>promise</li><li>async + await</li></ul><hr><h2 id="3-项目开始"><a href="#3-项目开始" class="headerlink" title="3. 项目开始"></a>3. 项目开始</h2><p>先在对应的git先创建git仓库，比如：XX管理后台 <code>demo</code> 项目，然后 <code>git clone</code> 到本来的开发环境，进入当前项目目录，代码如入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone ssh://git@github.com:cansolve/react-manage.git</span><br><span class="line">cd demo</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd demo</span><br><span class="line">git remote add origin ssh://git@github.com:cansolve/react-manage.git</span><br></pre></td></tr></table></figure><p>这时，通过git来添加前端开发初始化的工程目录，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add base ssh://git@github.com:cansolve/react-manage.git</span><br><span class="line">git pull base master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><p>然后可以推送到开发项目上面去，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &apos;前端项目初始化&apos;</span><br><span class="line">git push origin demo</span><br></pre></td></tr></table></figure><p>到此，你的 <code>demo</code> 项目前端搭建和初始化已完毕，接下来你就可以开始 前端开发 了</p><hr><h2 id="4-本地项目开始"><a href="#4-本地项目开始" class="headerlink" title="4. 本地项目开始"></a>4. 本地项目开始</h2><p>先安装编译第三方的依赖包<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//如果开发之前本地没有对应的server服务器，也可以用node搭个server服务器，默认是8080端口:127.0.0.1:8080,如果有的话，直接跳过这一步</span><br><span class="line">npm install -g http-server</span><br><span class="line">http-server -c-1</span><br></pre></td></tr></table></figure><h3 id="4-1-开发环境"><a href="#4-1-开发环境" class="headerlink" title="4.1 开发环境"></a>4.1 开发环境</h3><p>生产环境中开发监听对应的文件修改<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure><p></p><h3 id="4-2-生产环境"><a href="#4-2-生产环境" class="headerlink" title="4.2 生产环境"></a>4.2 生产环境</h3><p>压缩生产对应的线上文件，生产 <code>html</code> <code>css</code> <code>image</code> <code>font</code> <code>js</code> 文件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p></p><hr><h3 id="4-3-前端的升级和更新"><a href="#4-3-前端的升级和更新" class="headerlink" title="4.3 前端的升级和更新"></a>4.3 前端的升级和更新</h3><p>后续当前项目的前端库升级，bug修复，版本更新，直接可以通过命令来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull base master</span><br></pre></td></tr></table></figure><p>如有改动跟本地开发的导致冲突，请手动处理冲突文件，然后push到对应项目中去。</p><h2 id="5-项目组建介绍"><a href="#5-项目组建介绍" class="headerlink" title="5. 项目组建介绍"></a>5. 项目组建介绍</h2><h4 id="5-1-表格组建"><a href="#5-1-表格组建" class="headerlink" title="5.1 表格组建"></a>5.1 表格组建</h4><p><img src="/2018/09/14/daily3/WechatIMG9.jpeg" alt="效果图 2"><br>说明：这里表格已经写成组建形式，只需要传入对应的title及data <strong>后台获取数据</strong> 即可渲染成表格，对应的可以选择排序、勾选、包括给详情加a标签功能;</p><h4 id="5-2-分页组建"><a href="#5-2-分页组建" class="headerlink" title="5.2 分页组建"></a>5.2 分页组建</h4><p><img src="/2018/09/14/daily3/WechatIMG8.jpeg" alt="效果图 2"><br>说明：分页组建，点击传入对应页码，支持输入跳转;</p><h4 id="5-3-日历组建"><a href="#5-3-日历组建" class="headerlink" title="5.3 日历组建"></a>5.3 日历组建</h4><p><img src="/2018/09/14/daily3/WechatIMG7.jpeg" alt="效果图 2"><br>说明：日历时间选择组建，点击展示日期列表，选择传给后台为时间戳格式;</p><h4 id="5-4-下拉选择组建"><a href="#5-4-下拉选择组建" class="headerlink" title="5.4 下拉选择组建"></a>5.4 下拉选择组建</h4><p><img src="/2018/09/14/daily3/WechatIMG6.jpeg" alt="效果图 2"><br>说明：点击出现下拉框，支持搜索功能</p><h4 id="5-4-下拉选择【多选】组建"><a href="#5-4-下拉选择【多选】组建" class="headerlink" title="5.4 下拉选择【多选】组建"></a>5.4 下拉选择【多选】组建</h4><p><img src="/2018/09/14/daily3/WechatIMG5.jpeg" alt="效果图 2"><br>说明：点击出现下拉框，多选功能</p><h4 id="5-4-树组建"><a href="#5-4-树组建" class="headerlink" title="5.4 树组建"></a>5.4 树组建</h4><p><img src="/2018/09/14/daily3/WechatIMG4.jpeg" alt="效果图 2"><br>说明：传入对应的数据即可渲染成树</p><h4 id="5-4-双向选择组建"><a href="#5-4-双向选择组建" class="headerlink" title="5.4 双向选择组建"></a>5.4 双向选择组建</h4><p><img src="/2018/09/14/daily3/WechatIMG3.jpeg" alt="效果图 2"><br>说明：两边数据可以互通选择，支持一键全部选择，两边数据都支持搜索功能；</p><h5 id="具体使用api在组建里面已经写的比较详细，类似下图，再有不明白的可以联系我，一起进步；"><a href="#具体使用api在组建里面已经写的比较详细，类似下图，再有不明白的可以联系我，一起进步；" class="headerlink" title="具体使用api在组建里面已经写的比较详细，类似下图，再有不明白的可以联系我，一起进步；"></a>具体使用api在组建里面已经写的比较详细，类似下图，再有不明白的可以联系我，一起进步；</h5><p><img src="/2018/09/14/daily3/WechatIMG11.jpeg" alt="效果图 2"></p><h2 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h2><p>因为这是本人自己依据creat-react-app搭建的，跟公司项目目录还是有一定区别的，包括本人写代码的一些不好的地方还请多指正。<br>大神请绕道，放小弟一条生路，谢谢啦！！<br>本人公众号 <strong>码上关注</strong> 不定期分享一些前端知识，一起相互交流学习。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;p&gt;&lt;img src=&quot;/2018/09/14/daily3/WechatIMG10.jpeg&quot; alt=&quot;效果图 1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="react" scheme="http://cansolve.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>前端自动化部署jenkins</title>
    <link href="http://cansolve.cn/2018/08/24/daily11/"/>
    <id>http://cansolve.cn/2018/08/24/daily11/</id>
    <published>2018-08-24T09:19:59.000Z</published>
    <updated>2018-12-24T10:24:03.553Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><p>一、jenkins工具的安装、卸载、启用</p><p>注意：安装jenkins必须先安装java sdk，同时安装好brew工具（<a href="http://brew.sh/index_zh-cn.html）" target="_blank" rel="noopener">http://brew.sh/index_zh-cn.html）</a></p><p>1、安装、卸载</p><p>（1）安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install jenkins</span><br></pre></td></tr></table></figure><p>（2）卸载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall jenkins</span><br></pre></td></tr></table></figure><p>2、启用</p><p>终端命令启动（仅对终端命令安装有效）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenkins</span><br></pre></td></tr></table></figure><p>开机自动启动：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sfv /usr/local/opt/jenkins<span class="comment">/*.plist ~/Library/LaunchAgents</span></span><br></pre></td></tr></table></figure><p><img src="/2018/08/24/daily11/WechatIMG19.jpeg" alt="WechatIMG19"></p><p>3、登录</p><p><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a></p><p>运行成功会在用户个人目录下新建.jenkins/文件夹<br>访问localhost:8080就能到达Jenkins首页</p><p><img src="/2018/08/24/daily11/WechatIMG18.jpeg" alt="WechatIMG18"><br>第一次需要从文件夹下获取生成的密码登录，复制粘贴</p><p><img src="/2018/08/24/daily11/WechatIMG14.jpeg" alt="WechatIMG14"></p><p>密码验证成功后进入页面，选择插件模式</p><p><img src="/2018/08/24/daily11/20180823112315256.png" alt="clipboard.png"><br>大家都是默认选第一个</p><p><img src="/2018/08/24/daily11/20180823112327328.png" alt="clipboard.png"><br><img src="/2018/08/24/daily11/20180823112343266.png" alt="clipboard.png"><br>稍等一会，插件安装好了进入用户登录界面，设定用户名、密码及邮箱。</p><p><strong>然后登陆就用你设置的用户名跟密码，记住哦！！</strong></p><p>配置项目的 jenkins job<br>1、在 jenkins 左边栏点击 “新建”， 输入 job 名称，选择 “构建一个自由风格的软件项目” 一项。点击 “OK”</p><p><img src="/2018/08/24/daily11/WechatIMG15.jpeg" alt="WechatIMG15"></p><p><img src="/2018/08/24/daily11/WechatIMG16.jpeg" alt="WechatIMG16"><br>2、进入 job ”配置“页面，点击 “General” 选项，配置名称和描述，我们用的github项目，那么勾选github并且填入项目地址</p><p><img src="/2018/08/24/daily11/WechatIMG20.jpeg" alt="WechatIMG20"><br>3、点击 “源码管理” 选项，配置项目的 git 仓库地址的需要构建的分支信息</p><p><img src="/2018/08/24/daily11/WechatIMG21.jpeg" alt="WechatIMG21"><br>4、点击 “构建触发器” 选项，配置 job 构建时机，勾选 “GitHub hook trigger for GITScm polling”，github hook 来触发 job 构建 ,这里没有暂时可以忽略<br><img src="/2018/08/24/daily11/WechatIMG22.jpeg" alt="WechatIMG22"></p><p>5、点击 “构建” 选项，再点击 “增加构建步骤”， 选择 “Execute shell”，配置构建命令。 如下，这里配置了 npm install、npm run unit、npm run build, 分别做安装依赖、测试、打包三件事。</p><p><img src="/2018/08/24/daily11/WechatIMG23.jpeg" alt="WechatIMG23"></p><p><strong>后续继续补充</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;p&gt;一、jenkins工具的安装、卸载、启用&lt;/p&gt;&lt;p&gt;注意：安装jenkins必须先安装java sdk，同时安装好brew工具（&lt;a href=&quot;http
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="服务器" scheme="http://cansolve.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Eruda～一款移动端的调试神器</title>
    <link href="http://cansolve.cn/2018/06/27/daily14/"/>
    <id>http://cansolve.cn/2018/06/27/daily14/</id>
    <published>2018-06-27T11:20:08.000Z</published>
    <updated>2018-12-26T07:41:43.990Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><p>昨天介绍了一下抓包工具 <a href="https://cansolve.cn/2018/06/26/daily13/">Charles</a>的使用，今天再介绍一款移动端的调试面板；<br><strong>Eruda</strong>是什么？Eruda 是一个专为前端<strong>移动端</strong>、<strong>移动端</strong>设计的调试面板，类似<code>Chrome DevTools</code>的迷你版，其主要功能包括：捕获<code>console</code>日志、检查元素状态、显示性能指标、捕获XHR请求、显示<code>本地存储</code>和<code>Cookie</code>信息、浏览器特性检测等等。</p><p><strong>引用方式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">方式一 默认引入：</span><br><span class="line">&lt;script src=&quot;//cdn.jsdelivr.net/npm/eruda&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;eruda.init();&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">方式二 动态加载：</span><br><span class="line">__DEBUG__ &amp;&amp; loadJS(&apos;http://cdn.jsdelivr.net/eruda/1.0.5/eruda.min.js&apos;, ()=&gt;&#123;</span><br><span class="line"> eruda.init();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">方式三 指定场景加载：</span><br><span class="line">;(function () &#123;</span><br><span class="line"> var src = &apos;http://cdn.jsdelivr.net/eruda/1.0.5/eruda.min.js&apos;;</span><br><span class="line"> if (!/eruda=true/.test(window.location) &amp;&amp; localStorage.getItem(&apos;active-eruda&apos;) != &apos;true&apos;) return;</span><br><span class="line"> document.write(&apos;&lt;scr&apos; + &apos;ipt src=&quot;&apos; + src + &apos;&quot;&gt;&lt;/scr&apos; + &apos;ipt&gt;&apos;);</span><br><span class="line"> document.write(&apos;&lt;scr&apos; + &apos;ipt&gt;eruda.init();&lt;/scr&apos; + &apos;ipt&gt;&apos;);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">方式四 npm：</span><br><span class="line"> npm install eruda --save</span><br><span class="line">…… 加载的方式很多</span><br></pre></td></tr></table></figure><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li><p><strong>eruda</strong>能帮我们解决这个问题；所有的日志、错误都能帮我们捕获到，不要再去因为调试打印一堆的alert</p></li><li><p>甚至我们还能像<code>chrome</code>,直接在控制台执行js代码；</p></li></ul><p><img src="/2018/06/27/daily14/13453575-fe620ea0a6bcbbdd.png" alt="微信开发必备h5开发调试，利器Eruda"></p><h4 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h4><ul><li><p><strong>eruda</strong>它没有在PC端这么直观，但也因为在移动端展示的方式局限性，</p></li><li><p>它能把每一个父节点下的每一个子节点全部列出来；你点击某个子节点时，列出当前节点全部的属性、样式、盒子模型等；</p></li><li><p>查看标签内容及属性；查看Dom上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看Dom上绑定的各类事件。</p></li><li><p>甚至也能使用<code>Plugins</code>插件，做到跟PC端一样，形成 dom tree；</p></li></ul><p><img src="/2018/06/27/daily14/13453575-0c5fda5cb56478b9.png" alt="使用神器eruda进行移动端调试"><br><img src="/2018/06/27/daily14/13453575-94ce6ec7945edc32.png" alt="PC、Mobile调试节点对比"></p><h4 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h4><ul><li><p>现在的项目大多都是前后端分享的形式了，前端处理的业务越来越多、各种请求资源等；</p></li><li><p>干的越多承担责任也越多、锅也越多，又大又平的那种哦～</p></li><li><p>所以<strong>Network</strong>的必要性不言而喻，它能捕获请求，查看发送数据、返回头、返回内容等信息，它对于我们平时前后端联调出现的问题定位是有很大帮助的，比如：后端说你请求参数少了，前端你看了代码逻辑没有问题，但在手机上就是调不通，Network 能很直接明了的看到你请求带了什么。</p></li></ul><p><img src="/2018/06/27/daily14/13453575-15477c54341c764c.png" alt="今天的主角男一号是：Eruda！vConsole的同类。,PC、eruda数据请求对比"></p><h4 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h4><ul><li><p>它跟 Chrome Devtools 里的<code>Application</code>+<strong>Source</strong>,两者的结合体；</p></li><li><p>Resources 它能查看 Cookie、localStorage、sessionStorage等信息，并且还能执行清除操作（Application）；</p></li><li><p>它还查看当前页面加载脚本及样式文件；查看页面加载过的图片等资源（Source）；</p></li><li><p>好吧，感觉说的再多，也不如上图直接：</p><p><img src="/2018/06/27/daily14/13453575-c550eeb1b547abb3.png" alt="Resources功能分析"></p></li></ul><h4 id="Sources-Info"><a href="#Sources-Info" class="headerlink" title="Sources/Info"></a>Sources/Info</h4><ul><li><p>Sources：查看页面源码；格式化html，css，js代码及json数据。</p></li><li><p>Info：主要输出URL信息及User Agent；及其他的一些手机系统信息，同时也支持自定义输出内容哦。</p></li></ul><p><img src="/2018/06/27/daily14/13453575-56be572d3b102124.png" alt="Resources功能分析"></p><h2 id="高阶用法"><a href="#高阶用法" class="headerlink" title="高阶用法"></a>高阶用法</h2><ul><li><p>以上刚才介绍的是它的一些基本的功能，也是我自己在工作中用的较多的；</p></li><li><p>最近发现新版本功能要强大不少，之前一直用的<code>1.0.5</code>，好像是没有插件这一项的；</p></li><li><p>大概看了一下，都蛮强大，包括上面的<code>Dom tree</code>,插件这部分并没有都实际应用过，所以也就不<code>打肿脸充胖子</code>了，有兴趣的同学可以自己看看。</p></li><li><p>如果觉得已经的插件都满足不了你的需求，它还支持自定义插件自己编写。</p></li></ul><p><img src="/2018/06/27/daily14/13453575-d6b7e67e6cd247ba.png" alt="高级插件用法等你去发现～"></p><p>在贴一下原文地址<a href="https://github.com/liriliri/eruda" target="_blank" rel="noopener">eruda</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;p&gt;昨天介绍了一下抓包工具 &lt;a href=&quot;https://cansolve.cn/2018/06/26/daily13/&quot;&gt;Charles&lt;/a&gt;的使用，今
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="其他" scheme="http://cansolve.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Charles抓包工具的使用</title>
    <link href="http://cansolve.cn/2018/06/26/daily13/"/>
    <id>http://cansolve.cn/2018/06/26/daily13/</id>
    <published>2018-06-26T06:29:08.000Z</published>
    <updated>2018-12-26T06:44:07.586Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><blockquote><p>环境：mac OS X<br>抓取苹果手机（ios）app里面的https请求包，对数据进行排查。Charles支持针对Https包解析。</p></blockquote><p><strong>1.安装Charles</strong><br><strong>2.电脑安装Charles证书</strong></p><p><img src="/2018/06/26/daily13/1901430-a2e383a5c13faeed.png" alt=""></p><p>电脑安装证书</p><p><img src="/2018/06/26/daily13/1901430-645b0affc6d31940.jpeg" alt=""></p><p>双击还是信任下吧</p><p><strong>3.手机安装证书</strong></p><p><img src="/2018/06/26/daily13/1901430-ae1660183e196ded.png" alt=""></p><p>手机安装证书</p><p><strong>4.手机网页输入网址 下载证书并信任</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.charlesproxy.com/documentation/additional/legacy-ssl-proxying/</span><br></pre></td></tr></table></figure><p>或者直接在safari 浏览器打开下面的地址就可以下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.charlesproxy.com/assets/legacy-ssl/charles.crt</span><br></pre></td></tr></table></figure><p>手机证书下载网址</p><p><img src="/2018/06/26/daily13/1901430-7bc4aeef100b2746.png" alt=""></p><p>安装到手机上</p><p><code>注意</code>：在iOS 10.3之前,当你将安装一个自定义证书,iOS会默认信任,不需要进一步的设置。而iOS 10.3之后,安装新的自定义证书默认是不受信任的。如果要信任已安装的自定义证书,需要手动打开开关以信任证书。</p><p>iOS11下需要手动信任已下载好的证书，方法如下：</p><blockquote><p>设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到charles proxy custom root certificate然后信任该证书即可.</p><p><img src="/2018/06/26/daily13/1901430-c23912a0181d3ebf.jpeg" alt=""></p><p>iOS11下手动信任证书</p></blockquote><p><strong>5.开始抓包</strong><br>Charles设置Proxy<br>Proxy -&gt; SSL Proxying Settings…，如下图所示：</p><p><img src="/2018/06/26/daily13/1901430-1d6e60dbb846cb29.png" alt=""></p><p>疑问1，如果设置成特定的域名发现还是抓不了包，不知道为什么</p><p>选择Proxy | Recording Settings，弹出Recording Settings设置选项卡，勾选include</p><p><img src="/2018/06/26/daily13/1901430-2c289b1801e24d68.png" alt=""></p><ul><li>抓包</li></ul><p><img src="/2018/06/26/daily13/2622600698-572c09c3f1858_articlex.jpeg" alt="图片描述" title="图片描述"></p><p><a href="http://blog.devtang.com/2015/11/14/charles-introduction/" target="_blank" rel="noopener">这里贴一个比较详细的过程</a></p><p>补充：</p><p>如果用户不选择信任安装Charles的CA证书，Charles也无法获取请求内容。还有一种，如果客户端内置了本身的CA证书，这时如果Charles把自己的证书发送给客户端，客户端会发现与程序内的证书不一致，不予通过，此时Charles也是无法获取信息的。</p><p>Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;环境：mac OS X&lt;br&gt;抓取苹果手机（ios）app里面的https请求包，对数据进行排查。Charles支持针对Https包
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="其他" scheme="http://cansolve.cn/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>常见 React 面试题</title>
    <link href="http://cansolve.cn/2018/06/17/daily7/"/>
    <id>http://cansolve.cn/2018/06/17/daily7/</id>
    <published>2018-06-17T04:11:23.000Z</published>
    <updated>2018-12-24T06:27:50.161Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><blockquote><p>作者：小胡<br><a href="https://github.com/nanhupatar/FEGuide/blob/master/框架/react.md" target="_blank" rel="noopener">https://github.com/nanhupatar/FEGuide/blob/master/框架/react.md</a></p></blockquote><h3 id="React-中-keys-的作用是什么？"><a href="#React-中-keys-的作用是什么？" class="headerlink" title="React 中 keys 的作用是什么？"></a>React 中 keys 的作用是什么？</h3><p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;return (    </span><br><span class="line">          </span><br><span class="line">        &#123;this.state.todoItems.map((&#123;item, key&#125;) =&gt; &#123;      </span><br><span class="line">            return &#123;item&#125;      </span><br><span class="line">        &#125;)&#125;    </span><br><span class="line">       </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。</p><h3 id="调用-setState-之后发生了什么？"><a href="#调用-setState-之后发生了什么？" class="headerlink" title="调用 setState 之后发生了什么？"></a>调用 setState 之后发生了什么？</h3><p>在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p><h3 id="react-生命周期函数"><a href="#react-生命周期函数" class="headerlink" title="react 生命周期函数"></a>react 生命周期函数</h3><ul><li><p>初始化阶段：</p></li><li><p>getDefaultProps:获取实例的默认属性</p></li><li><p>getInitialState:获取每个实例的初始化状态</p></li><li><p>componentWillMount：组件即将被装载、渲染到页面上</p></li><li><p>render:组件在这里生成虚拟的 DOM 节点</p></li><li><p>componentDidMount:组件真正在被装载之后</p></li><li><p>运行中状态：</p></li><li><p>componentWillReceiveProps:组件将要接收到属性的时候调用</p></li><li><p>shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）</p></li><li><p>componentWillUpdate:组件即将更新不能修改属性和状态</p></li><li><p>render:组件重新描绘</p></li><li><p>componentDidUpdate:组件已经更新</p></li><li><p>销毁阶段：</p></li><li><p>componentWillUnmount:组件即将销毁</p></li></ul><h3 id="shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）"><a href="#shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）" class="headerlink" title="shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）"></a>shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</h3><p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p><p>参考 <a href="https://segmentfault.com/a/1190000008925295" target="_blank" rel="noopener">React进阶—性能优化</a></p><h3 id="为什么虚拟-dom-会提高性能-必考"><a href="#为什么虚拟-dom-会提高性能-必考" class="headerlink" title="为什么虚拟 dom 会提高性能?(必考)"></a>为什么虚拟 dom 会提高性能?(必考)</h3><p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。</p><p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p><p>参考 <a href="https://blog.csdn.net/qq_27626333/article/details/76082755" target="_blank" rel="noopener">如何理解虚拟 DOM?</a></p><h3 id="react-diff-原理（常考，大厂必考）"><a href="#react-diff-原理（常考，大厂必考）" class="headerlink" title="react diff 原理（常考，大厂必考）"></a>react diff 原理（常考，大厂必考）</h3><ul><li><p>把树形结构按照层级分解，只比较同级元素。</p></li><li><p>给列表结构的每个单元添加唯一的 key 属性，方便比较。</p></li><li><p>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</p></li><li><p>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</p></li><li><p>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p></li></ul><p>参考：<a href="https://blog.csdn.net/qq_26708777/article/details/78107577" target="_blank" rel="noopener">React 的 diff 算法</a></p><h3 id="React-中-refs-的作用是什么？"><a href="#React-中-refs-的作用是什么？" class="headerlink" title="React 中 refs 的作用是什么？"></a>React 中 refs 的作用是什么？</h3><p>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CustomForm extends Component &#123;</span><br><span class="line">  handleSubmit = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;Input Value: &quot;, this.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&apos;text&apos;</span><br><span class="line">          ref=&#123;(input) =&gt; this.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function CustomForm (&#123;handleSubmit&#125;) &#123;</span><br><span class="line">  let inputElement</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&apos;text&apos;</span><br><span class="line">        ref=&#123;(input) =&gt; inputElement = input&#125; /&gt;</span><br><span class="line">      &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如果你创建了类似于下面的-Twitter-元素，那么它相关的类定义是啥样子的？"><a href="#如果你创建了类似于下面的-Twitter-元素，那么它相关的类定义是啥样子的？" class="headerlink" title="如果你创建了类似于下面的 Twitter 元素，那么它相关的类定义是啥样子的？"></a>如果你创建了类似于下面的 Twitter 元素，那么它相关的类定义是啥样子的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Twitter username=&apos;tylermcginnis33&apos;&gt;</span><br><span class="line">  &#123;(user) =&gt; user === null</span><br><span class="line">    ? &lt;Loading /&gt;</span><br><span class="line">    : &lt;Badge info=&#123;user&#125; /&gt;&#125;</span><br><span class="line">&lt;/Twitter&gt;</span><br><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;</span><br><span class="line">import fetchUser from &apos;twitter&apos;</span><br><span class="line">// fetchUser take in a username returns a promise</span><br><span class="line">// which will resolve with that username&apos;s data.</span><br><span class="line">class Twitter extends Component &#123;</span><br><span class="line">  // finish this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你还不熟悉回调渲染模式（Render Callback Pattern），这个代码可能看起来有点怪。这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以 props.children 进行调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;</span><br><span class="line">import fetchUser from &apos;twitter&apos;</span><br><span class="line">class Twitter extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    user: null,</span><br><span class="line">  &#125;</span><br><span class="line">  static propTypes = &#123;</span><br><span class="line">    username: PropTypes.string.isRequired,</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    fetchUser(this.props.username)</span><br><span class="line">      .then((user) =&gt; this.setState(&#123;user&#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return this.props.children(this.state.user)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式的优势在于将父组件与子组件解耦和，父组件可以直接访问子组件的内部状态而不需要再通过 Props 传递，这样父组件能够更为方便地控制子组件展示的 UI 界面。譬如产品经理让我们将原本展示的 Badge 替换为 Profile，我们可以轻易地修改下回调函数即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Twitter username=&apos;tylermcginnis33&apos;&gt;</span><br><span class="line">  &#123;(user) =&gt; user === null</span><br><span class="line">    ? &lt;Loading /&gt;</span><br><span class="line">    : &lt;Profile info=&#123;user&#125; /&gt;&#125;</span><br><span class="line">&lt;/Twitter&gt;</span><br></pre></td></tr></table></figure><h3 id="展示组件-Presentational-component-和容器组件-Container-component-之间有何不同"><a href="#展示组件-Presentational-component-和容器组件-Container-component-之间有何不同" class="headerlink" title="展示组件(Presentational component)和容器组件(Container component)之间有何不同"></a>展示组件(Presentational component)和容器组件(Container component)之间有何不同</h3><ul><li><p>展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。</p></li><li><p>容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。</p></li></ul><h3 id="类组件-Class-component-和函数式组件-Functional-component-之间有何不同"><a href="#类组件-Class-component-和函数式组件-Functional-component-之间有何不同" class="headerlink" title="类组件(Class component)和函数式组件(Functional component)之间有何不同"></a>类组件(Class component)和函数式组件(Functional component)之间有何不同</h3><ul><li><p>类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态</p></li><li><p>当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件</p></li></ul><h3 id="组件的-状态-state-和属性-props-之间有何不同"><a href="#组件的-状态-state-和属性-props-之间有何不同" class="headerlink" title="(组件的)状态(state)和属性(props)之间有何不同"></a>(组件的)状态(state)和属性(props)之间有何不同</h3><ul><li><p>State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。</p></li><li><p>Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</p></li></ul><h3 id="何为受控组件-controlled-component"><a href="#何为受控组件-controlled-component" class="headerlink" title="何为受控组件(controlled component)"></a>何为受控组件(controlled component)</h3><p>在 HTML 中，类似 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。</p><h3 id="何为高阶组件-higher-order-component"><a href="#何为高阶组件-higher-order-component" class="headerlink" title="何为高阶组件(higher order component)"></a>何为高阶组件(higher order component)</h3><p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。</p><h3 id="为什么建议传递给-setState-的参数是一个-callback-而不是一个对象"><a href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象" class="headerlink" title="为什么建议传递给 setState 的参数是一个 callback 而不是一个对象"></a>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</h3><p>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。</p><h3 id="除了在构造函数中绑定-this，还有其它方式吗"><a href="#除了在构造函数中绑定-this，还有其它方式吗" class="headerlink" title="除了在构造函数中绑定 this，还有其它方式吗"></a>除了在构造函数中绑定 this，还有其它方式吗</h3><p>你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p><h3 id="在构造函数中-调用-super-props-的目的是什么"><a href="#在构造函数中-调用-super-props-的目的是什么" class="headerlink" title="(在构造函数中)调用 super(props) 的目的是什么"></a>(在构造函数中)调用 super(props) 的目的是什么</h3><p>在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。</p><h3 id="应该在-React-组件的何处发起-Ajax-请求"><a href="#应该在-React-组件的何处发起-Ajax-请求" class="headerlink" title="应该在 React 组件的何处发起 Ajax 请求"></a>应该在 React 组件的何处发起 Ajax 请求</h3><p>在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。</p><h3 id="描述事件在-React-中的处理方式。"><a href="#描述事件在-React-中的处理方式。" class="headerlink" title="描述事件在 React 中的处理方式。"></a>描述事件在 React 中的处理方式。</h3><p>为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。</p><p>这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新 DOM 时，React 不需要担心跟踪事件监听器。</p><h3 id="createElement-和-cloneElement-有什么区别？"><a href="#createElement-和-cloneElement-有什么区别？" class="headerlink" title="createElement 和 cloneElement 有什么区别？"></a>createElement 和 cloneElement 有什么区别？</h3><p>React.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>React.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而就的子元素奖杯替换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.cloneElement(</span><br><span class="line">  element,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="React-中有三种构建组件的方式"><a href="#React-中有三种构建组件的方式" class="headerlink" title="React 中有三种构建组件的方式"></a>React 中有三种构建组件的方式</h3><p>React.createClass()、ES6 class 和无状态函数。</p><h3 id="react-组件的划分业务组件技术组件？"><a href="#react-组件的划分业务组件技术组件？" class="headerlink" title="react 组件的划分业务组件技术组件？"></a>react 组件的划分业务组件技术组件？</h3><ul><li><p>根据组件的职责通常把组件分为 UI 组件和容器组件。</p></li><li><p>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</p></li><li><p>两者通过 React-Redux 提供 connect 方法联系起来。</p></li></ul><h3 id="简述-flux-思想"><a href="#简述-flux-思想" class="headerlink" title="简述 flux 思想"></a>简述 flux 思想</h3><p>Flux 的最大特点，就是数据的”单向流动”。</p><ol><li><p>用户访问 View</p></li><li><p>View 发出用户的 Action</p></li><li><p>Dispatcher 收到 Action，要求 Store 进行相应的更新</p></li><li><p>Store 更新后，发出一个”change”事件</p></li><li><p>View 收到”change”事件后，更新页面</p></li></ol><h3 id="React-项目用过什么脚手架（本题是开放性题目）"><a href="#React-项目用过什么脚手架（本题是开放性题目）" class="headerlink" title="React 项目用过什么脚手架（本题是开放性题目）"></a>React 项目用过什么脚手架（本题是开放性题目）</h3><p>creat-react-app Yeoman 等</p><h3 id="了解-redux-么，说一下-redux-把"><a href="#了解-redux-么，说一下-redux-把" class="headerlink" title="了解 redux 么，说一下 redux 把"></a>了解 redux 么，说一下 redux 把</h3><ul><li><p>redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据，flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰</p></li><li><p>新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们</p></li></ul><h3 id="redux-有什么缺点"><a href="#redux-有什么缺点" class="headerlink" title="redux 有什么缺点"></a>redux 有什么缺点</h3><ul><li><p>一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。</p></li><li><p>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;作者：小胡&lt;br&gt;&lt;a href=&quot;https://github.com/nanhupatar/FEGuide/blob/maste
      
    
    </summary>
    
      <category term="分享" scheme="http://cansolve.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="react" scheme="http://cansolve.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>滑向未来（现代 JS 与 CSS 滚动实现指南)</title>
    <link href="http://cansolve.cn/2018/06/03/daily6/"/>
    <id>http://cansolve.cn/2018/06/03/daily6/</id>
    <published>2018-06-03T04:11:23.000Z</published>
    <updated>2018-12-18T11:13:26.305Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><blockquote><p>英文： Evil Martians 译文：众成翻译/sea_ljf<br><a href="http://www.zcfy.cc/article/scroll-to-the-future" target="_blank" rel="noopener">www.zcfy.cc/article/scroll-to-the-future</a></p></blockquote><p>一些（网站）滚动的效果是如此令人着迷但你却不知该如何实现，本文将为你揭开它们的神秘面纱。我们将基于最新的技术与规范为你介绍最新的 JavaScript 与 CSS 特性，（当你付诸实践时，）将使你的页面滚动更平滑、美观且性能更好。</p><p>大多数的网页的内容都无法在一屏内全部展现，因而（页面）滚动对于用户而言是必不可少的。对于前端工程师与 UX 设计师而言，跨浏览器提供良好的滚动体验，同时符合设计（要求），无疑是一个挑战。尽管 web 标准的发展速度远超从前，但代码的实现往往是落后的。下文将为你介绍一些常见的关于滚动的案例，检查一下你所用的解决方案是否被更优雅的方案所代替。</p><p><strong>消逝的滚动条</strong></p><p>在过去的三十年里，滚动条的外观不断改变以符合设计的趋势，设计师们为（滚动条的）颜色、阴影、上下箭头的形状与边框的圆角实验了多种风格。以下是 Windows 上的变化历程：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1S4or5PlS9mBibR4uwkGagfzgsOgAT11uFEPedxAicRlYjePnTImjsvTpKpRnh9MwyTOaCoAU3yq7Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="">（Windows 上的滚动条）</p><p>在2011年，苹果设计师从 ios 上获得灵感，为如何定义“美观的”滚动条确定了方向。所有滚动条均从 Mac 电脑中消失，不再占据任何页面空间，只有在用户触发滚动时（滚动条）才会重新出现（有些用户会设置不隐藏滚动条）。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1S4or5PlS9mBibR4uwkGagfFRq6PHibZL73jSVzmIrG2gzZ9xW8liaEqR9sYyd5icjOvIz0ianGCFq3JA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="">（Mac 上的滚动条）</p><p>滚动条安静地消逝并未引起苹果粉丝的不满，已经习惯了 iPhone 与 iPad 上滚动方式的用户很快地习惯了这一设计。大多数开发人员与设计师都认为这是一个“好消息”，因为计算滚动条的宽度可真是件苦差事。</p><p>然而，我们生活在一个拥有众多操作系统与浏览器的世界中，它们（对于滚动）的实现各不相同。如果你和我们一样是一名 Web 开发者，你可不能把“滚动条问题”置之不理。</p><p>以下将为你介绍一些小技巧，使你的用户在滚动时有更好的体验。</p><p><strong>隐藏但可滚动</strong></p><p>先来看看一个关于模态框的经典例子。当它被打开的时候，主页面应该停止滚动。在 CSS 中有如下的快捷实现方式：</p><blockquote><p>body{</p><p>overflow: hidden;</p><p>}</p></blockquote><p>但上述代码会带来一点不良的副作用：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/zPh0erYjkib1S4or5PlS9mBibR4uwkGagfVFryicxsTYj8JicKyfbYcOc3ibicGdGqqzZQysibsUmmFUlyKwz4S7mibiaXQ/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p><p>（注意红色剪头）</p><p>在这个示例中，为了演示目的，我们在 Mac 系统中设置了强制显示滚动条，因而用户体验与 Windows 用户相似。</p><p>我们该如何解决这个问题呢？如果我们知道滚动条的宽度，每次当模态框出现时，可在主页面的右边设置一点边距。</p><p>由于不同的操作系统与浏览器对滚动条的宽度不一，因而获取它的宽度并不容易。在Mac 系统中，无论任何浏览器（滚动条）都是统一15px，然而 Windows 系统可会令开发者发狂：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1S4or5PlS9mBibR4uwkGagfELwBFv2dOYiciaiaDrbUcw1ia3CVGlTYexd6gH99OakkM9o56AF6Vnxmmw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p><p>（“百花齐放”的宽度）</p><p>注意，以上仅是 Windows 系统下基于当前最新版浏览器（测试所得）的结果。以前的（浏览器）版本（宽度）可能有所不同，也没人知道未来（滚动条的宽度）会如何变化。</p><p>不同于猜测（滚动条的宽度），你可以通过 JavaScript 计算它的宽度（译者注：实测以下代码仅能测出原始的宽度，通过 CSS 改变了滚动条宽度后，以下代码也无法测出实际宽度）：</p><blockquote><p>constouter = document.createElement(‘div’);</p><p>constinner = document.createElement(‘div’);</p><p>outer.style.overflow = ‘scroll’;</p><p>document.body.appendChild(outer);</p><p>outer.appendChild(inner);</p><p>constscrollbarWidth = outer.offsetWidth - inner.offsetWidth;</p><p>document.body.removeChild(outer);</p></blockquote><p>尽管仅仅七行代码（就能测出滚动条的宽度），但有数行代码是操作 DOM 的。（为性能起见，）如非必要，尽量避免进行 DOM 操作。</p><p>解决这个问题的另一个方法是在模态框出现时仍保留滚动条，以下是基于这思路的纯 CSS 实现：</p><blockquote><p>html{</p><p>overflow-y: scroll;</p><p>}</p></blockquote><p>尽管“模态框抖动”问题解决了，但整体的外观却被一个无法使用的滚动条影响了，这无疑是设计中的硬伤。</p><p>在我们看来，更好的解决方案是完全地隐藏滚动条。纯粹用 CSS 也是可以实现的。该方法（达到的效果）和 macOS 的表现并不是完全一致，（当用户）滚动时滚动条仍然是不可见的。滚动条总是处于不可见状态，然而页面是可被滚动的。对于Chrome，Safari 和 Opera 而言，可以使用以下的 CSS：</p><blockquote><p>.container::-webkit-scrollbar{</p><p>display: none;</p><p>}</p></blockquote><p>IE 或 Edge 可用以下代码:</p><blockquote><p>.container{</p><p>-ms-overflow-style: none;</p><p>}</p></blockquote><p>至于 Firefox，很不幸，没有任何办法隐藏滚动条。</p><p>正如你所见，并没有任何银弹。任何解决方案都有它的优点与缺点，应根据你项目的需要选择最合适的。</p><p><strong>外观争议</strong></p><p>需要承认的是，滚动条的样子在部分操作系统上并不好看。一些设计师喜欢完全掌控他们（所设计）应用的样式，任何一丝细节也不放过。在 GitHub 上有上百个库借助 JavaScript 取代系统滚动条的默认实现，以达到自定义的效果。</p><p>但如果你想根据现有的浏览器定制一个滚动条呢？（很遗憾，）并没有通用的 API，每个浏览器都有其独特的代码实现。</p><p>尽管5.5版本以后的 IE 浏览器允许你修改滚动条的样式，但它只允许你修改滚动条的颜色。以下是如何重新绘制（滚动条）拖动部分与箭头的代码：</p><blockquote><p>body{</p><p>scrollbar-face-color: blue;</p><p>}</p></blockquote><p>但只改变颜色对提高用户体验而言帮助不大。据此，WebKit 的开发者在2009年提出了（修改滚动条）样式的方案。以下是使用 -webkit 前缀在支持相关样式的浏览器中模拟 macOS 滚动条样式的代码：</p><blockquote><p>::-webkit-scrollbar{</p><p>width: 8px;</p><p>}</p><p>::-webkit-scrollbar-thumb{</p><p>background-color: #c1c1c1;</p><p>border-radius: 4px;</p><p>}</p></blockquote><p>Chrome、Safari、Opera 甚至于 UC 浏览器或者三星自带的桌面浏览器都支持（上述 CSS）。Edge 也有计划实现它们。但三年过去了，该计划仍在中等优先级中（而尚未被实现）。</p><p>当我们讨论滚动条的定制时，Mozilla 基金会基本上是无视了设计师的需求。（有开发者在）17年前就已经提出了一个希望修改滚动条样式的请求。而就在几个月前，Jeff Griffiths（Firefox 浏览器总监）终于为这个问题作出了回答：</p><p>“除非团队中有人对此有兴趣，否则我对此毫不关心。”</p><p>公平地说，从 W3C 的角度看来，尽管 WebKit 的实现得到广泛的支持，但它仍然不是标准。现有的为滚动条修改样式的草案，是基于 IE 的：仅能修改它的颜色。</p><p>伴随着请求如同 WebKit 一样支持滚动条样式修改 issue 的提交，争议仍在继续。如果你想影响 CSS 工作小组，是时候参与讨论了。也许这不是优先级最高的问题，但（如同 WebKit 一样修改滚动条样式）得到标准化后，能使很多前端工程师与设计师轻松很多。</p><p><strong>流畅的操作体验</strong></p><p>对于滚动而言，最常见的任务是登录页的导航（跳转）。通常，它是通过锚点链接来完成的。只需要知道元素的 id 即可：</p><blockquote><p>&lt;ahref=”#section”&gt;</p></blockquote><p>点击该链接会 跳 到（该锚点对应的）区块上，（然而） UX 设计师一般会坚持认为该过程应是平滑地运动的。GitHub 上有大量造好的轮子（帮你解决这个问题），然而它们或多或少都用到 JavaScript。（其实）只用一行代码也能实现同样的效果，最近DOM API 中的 Element.scrollIntoView() 可以通过传入配置对象来实现平滑滚动：</p><blockquote><p>elem.scrollIntoView({</p><p>behavior: ‘smooth’</p><p>});</p></blockquote><p>然而该属性兼容性较差且仍是通过脚本（来控制样式）。如有可能，应尽量少用额外的脚本。</p><p>幸运的是，有一个全新的 CSS 属性（仍在工作草案中），可以用简单的一行代码改变整个页面滚动的行为。</p><blockquote><p>html{</p><p>scroll-behavior: smooth;</p><p>}</p></blockquote><p>结果如下:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/zPh0erYjkib1S4or5PlS9mBibR4uwkGagfWOx5gubdeib6FTmh08zjnkyInQDMaOMiaaicFFhyPbYpNhVK6dOjbmQGw/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p><p>（从一个区块跳到另一个）</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/zPh0erYjkib1S4or5PlS9mBibR4uwkGagfEozAicEbhcECu4T64I55snoEkt52a94fWs2aSiaG7ZlibiaRAbIYnpwxew/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p><p>（平滑地滚动）</p><p>你可以在 codepen 上试验这个属性。在撰写本文时，scroll-behavior 仅在 Chrome、 Firefox 与 Opera 上被支持，但我们希望它能被广泛支持，因为使用 CSS （比使用 JavaScript）在解决页面滚动问题时优雅得多，并更符合“渐进增强”的模式。</p><p><strong>粘性 CSS</strong></p><p>另一个常见的需求是根据滚动方向动态地定住元素，即有名的“粘性（即 CSS 中的position: sticky）”效应。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/zPh0erYjkib1S4or5PlS9mBibR4uwkGagf5LPnKbh9PNT5nlRtCWMeUsjQ1OoUtbOfSMDVXpgVjFlx7NRFV3XTtA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""><br>（一个粘性元素）</p><p>在以前的日子里，要实现一个“粘性”元素需要编写复杂的滚动处理函数去计算元素的大小。（然而）该函数较难处理元素在“黏住”与“不黏住”之间微小的延迟，（通常会）导致（元素）抖动的出现。通过 JavaScript 来实行（“粘性”元素）也有性能上的问题，特别是在（需要）调用 [Element.getBoundingClientRect() ]时(<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)。" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)。</a></p><p>不久之前，CSS 实现了 position: sticky 属性。只需通过指定（某方向上的）偏移量即可实现我们想要的效果。</p><blockquote><p>.element{</p><p>position: sticky;</p><p>top: 50px;</p><p>}</p></blockquote><p>（编写上述代码后，）剩下的就交由浏览器实现即可。你可以在 codepen 上试验一下。撰写本文之时，position: sticky 在各式浏览器（包括移动端浏览器）上支持良好，所以如果你还在使用 JavaScript 去解决这个问题的话，是时候换成纯 CSS 的实现了。</p><p><strong>全面使用函数节流</strong></p><p>从浏览器的角度看来，滚动是一个事件，因此在 JavaScript 中是使用一个标准化的事件监听器 addEventListener 去处理它： ，</p><blockquote><p>window.addEventListener(‘scroll’,() =&gt; {</p><p>constscrollTop = window.scrollY;</p><p>/<em> doSomething with scrollTop </em>/</p><p>});</p></blockquote><p>用户往往高频率地滚动（页面），但如果滚动事件触发太频繁的话，会导致性能上的问题，可以通过使用函数节流这一技巧去优化它。</p><blockquote><p>window.addEventListener(‘scroll’,throttle(() =&gt; {</p><p>constscrollTop = window.scrollY;</p><p>/<em> doSomething with scrollTop </em>/</p><p>}));</p></blockquote><p>你需要定义一个节流函数包装原来的事件监听函数，（节流函数是）减少被包装函数的执行次数，只允许它在固定的时间间隔之内执行一次：</p><blockquote><p>functionthrottle(action,wait = 1000){</p><p>let time = Date.now();</p><p>returnfunction(){</p><p>if((time + wait - Date.now()) &lt; 0){</p><p>action();</p><p>time = Date.now();</p><p>}</p><p>}</p><p>}</p></blockquote><p>为了使（节流后的）滚动更平滑，你可以通过使用 window.requestAnimationFrame() 来实现函数节流：</p><blockquote><p>functionthrottle(action){</p><p>let isRunning = false;</p><p>returnfunction(){</p><p>if(isRunning)return;</p><p>isRunning = true;</p><p>window.requestAnimationFrame(() =&gt; {</p><p>action();</p><p>isRunning = false;</p><p>});</p><p>}</p><p>}</p></blockquote><p>当然，你可以通过现有的开源轮子来实现，就像 Lodash 一样。你可以访问 codepen 来看看上述解决方案与 Lodash 中的 _.throttle 之间的区别。</p><p>使用哪个（开源库）并不重要，重要的是在需要的时候，记得优化你（页面中的）滚动处理函数。</p><p><strong>在视窗中显示</strong></p><p>当你需要实现图片懒加载或者无限滚动时，需要确定元素是否出现在视窗中。这可以在事件监听器中处理，最常见的解决方案是使用 lement.getBoundingClientRect() ：</p><blockquote><p>window.addEventListener(‘scroll’,() =&gt; {</p><p>constrect = elem.getBoundingClientRect();</p><p>constinViewport = rect.bottom &gt; 0 &amp;&amp; rect.right &gt; 0 &amp;&amp;</p><p>rect.left &lt; window.innerWidth &amp;&amp;</p><p>rect.top &lt; window.innerHeight;</p><p>});</p></blockquote><p>上述代码的问题在于每次调用 getBoundingClientRect 时都会触发回流，严重地影响了性能。在事件处理函数中调用（ getBoundingClientRect ）尤为糟糕，就算使用了函数节流（的技巧）也可能对性能没多大帮助。 （回流是指浏览器为局部或整体地重绘某个元素，需要重新计算该元素在文档中的位置与形状。）</p><p>在2016年后，可以通过使用 Intersection Observer 这一 API 来解决问题。它允许你追踪目标元素与其祖先元素或视窗的交叉状态。此外，尽管只有一部分元素出现在视窗中，哪怕只有一像素，也可以选择触发回调函数：</p><blockquote><p>constobserver = newIntersectionObserver(callback,options);</p><p>observer.observe(element);</p></blockquote><p>此 API 被广泛地支持，但仍有一些浏览器需要 polyfill。尽管如此，它仍是目前最好的解决方案。</p><p><strong>滚动边界问题</strong></p><p>如果你的弹框或下拉列表是可滚动的，那你务必要了解连锁滚动相关的问题：当用户滚动到（弹框或下拉列表）末尾（后再继续滚动时），整个页面都会开始滚动。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/zPh0erYjkib1S4or5PlS9mBibR4uwkGagffibNW1A69DE9caPYibwW3UcjXNLz1KWPMNBxRvgiakklYsRfmKwicN0lXw/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p><p>（连锁滚动的表现）</p><p>当滚动元素到达底部时，你可以通过（改变）页面的 overflow 属性或在滚动元素的滚动事件处理函数中取消默认行为来解决这问题。</p><p>如果你选择使用 JavaScript （来处理），请记住要处理的不是“scroll（事件）”，而是每当用户使用鼠标滚轮或触摸板时触发的“wheel（事件）”：</p><blockquote><p>functionhandleOverscroll(event){</p><p>constdelta = -event.deltaY;</p><p>if(delta&lt; 0 &amp;&amp; elem.scrollHeight - elem.scrollTop){</p><p>elem.scrollTop = elem.scrollHeight;</p><p>event.preventDefault();</p><p>returnfalse;</p><p>}</p><p>if(delta &gt; elem.scrollTop){</p><p>elem.scrollTop = 0;</p><p>event.preventDefault();</p><p>returnfalse;</p><p>}</p><p>returntrue;</p><p>}</p></blockquote><p>不幸的是，这个解决方案不太可靠。同时可能对（页面）性能产生负面影响。</p><p>过度滚动对移动端的影响尤为严重。Loren Brichter 在 iOS 的 Tweetie 应用上创造了一个“下拉刷新”的新手势，这在 UX 社区中引起了轰动：包括 Twitter 与 Facebook 在内的各大应用纷纷采用了（相同的手势）。</p><p>当这个特性出现在安卓端的 Chrome 浏览器中时，问题出现了：它会刷新整个页面而不是加载更多的内容，成为开发者在他们的应用中实现“下拉刷新”时的麻烦。</p><p>CSS 通过 overscroll-behavior 这个新属性解决问题。它通过控制元素滚动到尽头时的行为来解决下拉刷新与连锁滚动所带来的问题，（它的属性值中）也包含针对不同平台特殊值：安卓的 glow 与 苹果系统中的 rubber band。</p><p>现在，上面 GIF 中的问题，在 Chrome、Opera 或 Firefox 中可以通过以下一行代码来解决：</p><blockquote><p>.element{</p><p>overscroll-behavior: contain;</p><p>}</p></blockquote><p>公平地说，IE 与 Edge 实现了（它独有的） -ms-scroll-chaining 属性来控制连锁滚动，但它并不能处理所有的情况。幸运的是，根据这消息，微软的浏览器已经准备实现 overscroll-behavior 这一属性了。</p><p><strong>触屏之后</strong></p><p>触屏设备上的滚动（体验）是一个很大的话题，深入讨论需要另开一篇文章。然而，由于很多开发者忽略了这方面的内容，这里需要提及一下。</p><p>（滚动手势无处不在，令人沉迷，以至于想出了如此疯狂的主意去解决“滚动上瘾”的问题。）</p><p>周围的人在智能手机屏幕上上下移动他们的手指的频率是多少呢？经常这样对吧，当你阅读本文时，你很可能就在这么做。</p><p>当你的手指在屏幕上移动时，你期待的是：页面内容平滑且流畅地移动。</p><p>苹果公司开创了“惯性”滚动并拥有它的专利 。它讯速地成为了用户交互的标准并且我们对此已习以为常。</p><p>但你也许已经注意到了，尽管移动端系统会为你实现页面上的惯性滚动，但当页面内某个元素发生滚动时，即使用户同样期待惯性滚动，但它并不会出现，这令人沮丧。</p><p>这里有一个 CSS 的解决方案，但看起来更像是个 hack：</p><blockquote><p>.element{</p><p>-webkit-overflow-scrolling: touch;</p><p>}</p></blockquote><p>为什么这是个 hack 呢？首先，它只能在支持（webkit）前缀的浏览器上才能工作。其次，它只适用于触屏设备。最后，如果浏览器不支持的话，你就这样置之不理吗？但无论如何，这总归是一个解决方案，你可以试着使用它。</p><p>在触屏设备上，另一个需要考虑的问题是开发者如何处理 touchstart 与 touchmove 事件触发时可能存在的性能问题，它对用户滚动体验的影响非常大。这里详细描述了整个问题。简单来说，现代的浏览器虽然知道如何使得滚动变得平滑，但为确认（滚动）事件处理函数中是否执行了 Event.preventDefault() 以取消默认行为，有时仍可能需要花费500毫秒来等待事件处理函数执行完毕。</p><p>即使是一个空的事件监听器，从不取消任何行为，鉴于浏览器仍会期待 preventDefault 的调用，也会对性能造成负面影响。</p><p>为了准确地告诉浏览器不必担心（事件处理函数中）取消了默认行为，在 WHATWG 的 DOM 标准中存在着一个不太显眼的特性（能解决这问题）。（它就是）Passive event listeners，浏览器对它的支持还是不错的。事件监听函数新接受一个可选的对象作为参数，告诉浏览器当事件触发时，事件处理函数永远不会取消默认行为。（当然，添加此参数后，）在事件处理函数中调用 preventDefault 将不再产生效果。</p><blockquote><p>element.addEventListener(‘touchstart’,e =&gt; {</p><p>/<em> doSomething </em>/</p><p>},{passive: true});</p></blockquote><p>针对不支持该参数的浏览器，这里也有一个 polyfill 。这视频清晰地展示了此改进带来的影响。</p><p><strong>旧技术运行良好，为何还要改动？</strong></p><p>在现代互联网中，过渡地依赖 JavaScript 在各浏览器上实现相同的交互效果不再是合理的，“跨浏览器兼容性”已经成为过去式，更多的 CSS 属性与 DOM API 方法正逐步被各大浏览器所支持。</p><p>在我们看来，当你的项目中，有特别酷炫的滚动效果时，渐进增强是最好的做法。</p><p>你应该提供（给用户）所有（你能提供的）基础用户体验，并逐步在更先进的浏览器上提供更好的体验。</p><p>必要时使用 polyfill，它们不会产生（不必要的）依赖，一旦（某个 polyfill 所支持的属性）得到广泛地支持，你就可以轻松地将它删掉。</p><p>六个月之前，在本文尚未成文之时，之前我们描述的属性只被少量的浏览器所支持。而到了本文发表之时，这些属性已被广泛地支持。</p><p>也许到了现在，当你上下翻阅本文之时，（之前不支持某些属性的）浏览器已经支持了该属性，这使得你编程更容易，并使你的应用打包出来体积更小。</p><p>感谢阅读至此！查阅浏览器的更新日志，积极参与讨论，有助于 web 标准驶向正确的方向。祝大家一帆风顺，顺利滑（滚）向未来！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;blockquote&gt;&lt;p&gt;英文： Evil Martians 译文：众成翻译/sea_ljf&lt;br&gt;&lt;a href=&quot;http://www.zcfy.cc/a
      
    
    </summary>
    
      <category term="分享" scheme="http://cansolve.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="css" scheme="http://cansolve.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>用Hexo + github搭建自己的博客</title>
    <link href="http://cansolve.cn/2018/04/02/daily1/"/>
    <id>http://cansolve.cn/2018/04/02/daily1/</id>
    <published>2018-04-02T11:25:46.000Z</published>
    <updated>2018-12-24T04:22:38.674Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>这是我第一次写这种类型的博客，也不叫什么博客，纯粹个人一些踩坑过程罢了，原先弄的前后端分离的开发流程想想太复杂，一个博客页面没啥必要，主要还是记录自己的一些心得，内容比较重要。话不多说，开搞！！！</p><h2 id="基于node和git"><a href="#基于node和git" class="headerlink" title="基于node和git"></a>基于node和git</h2><p>安装<a href="http://nodejs.cn/" target="_blank" rel="noopener">node.js</a>和<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git</a><br>这个就不多说了，贴个地址</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a><strong>快速开始</strong></h2><p>1、找个文件夹下打开终端,输入</p><pre><code>hexo i blogName //blog是项目名cd blogName //切换到站点根目录hexo g //generetor的缩写hexo s //server的缩写</code></pre><p>2 打开浏览器输入localhost:4000查看：<br><img src="http://img.cansolve.cn/20161115143629057.jpg" alt="local" title="localhost:4000"></p><p>看到这个样子就说明成功了，这个就是hexo默认的博客主题。现在你已经可以在这个主题下写博客了。<br>你还可以选择博客的主题<a href="https://hexo.io/themes/" target="_blank" rel="noopener">theme</a></p><h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a><strong>选择主题</strong></h2><p>我选的是Claudia</p><p>1 . 在站点根目录输入</p><pre><code>git clone https://github.com/Haojen/hexo-theme-Claudia.git</code></pre><p>2 . 完成后，打开根目录下的 _config.yml 文件， 找到 theme 字段，把landscape改为 Claudia<br><img src="http://img.cansolve.cn/2018112110001.png" alt="theme" title="theme"></p><p>3 . 在终端输入</p><pre><code>hexo clean  //清除缓存hexo g  //重新生成代码hexo s  //部署到本地//然后打开浏览器访问 localhost:4000 查看效果</code></pre><p><img src="http://img.cansolve.cn/201812110002.png" alt="theme" title="theme"><br>这时候主题已经换了，主题里面的修改项自行查阅一下，很多都有注释</p><h2 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a><strong>上传到github</strong></h2><p>没有github账号的，自行注册一个【很少人没有吧】</p><p><img src="http://img.cansolve.cn/201812110003.png" alt="theme" title="theme"><br>完了继续下一步选择一个主题</p><p><img src="http://img.cansolve.cn/201812110004.jpg" alt="theme" title="theme"><br>结束访问 xxxxx.github.io 会看到上面一样的页面</p><p>修改文件<br><img src="http://img.cansolve.cn/201812110005.png" alt="theme" title="theme"></p><pre><code>注意！！！冒号的后面一定一定一定要有一个空格！！</code></pre><p>开始部署</p><pre><code>npm install hexo-deployer-git --save//先装个插件hexo d  //  部署的命令</code></pre><p>网上有的教程说需要账号密码，我这边没遇到，所以就不方便截图了</p><h2 id="发布第一篇博客"><a href="#发布第一篇博客" class="headerlink" title="发布第一篇博客"></a><strong>发布第一篇博客</strong></h2><p>根目录下输入 ：</p><pre><code>hexo new &quot;postName&quot;//hexo n 也可以 //你自己的博客名称，名为postName.md的文件会建在目//录/blog/source/_posts下。</code></pre><p>文章编辑完成后，终端在根目录文件夹下，执行如下命令来发布:</p><pre><code>hexo g //生成静态页面，类似于打个包hexo d //发布</code></pre><p>这样就可以发布咯</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jan 11 2019 16:17:44 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/
      
    
    </summary>
    
      <category term="个人" scheme="http://cansolve.cn/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="建站" scheme="http://cansolve.cn/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
</feed>
