{"meta":{"title":"blog","subtitle":null,"description":"my blog","author":"tongxiang","url":"http://cansolve.github.io"},"pages":[{"title":"关于","date":"2018-12-13T08:15:25.000Z","updated":"2018-12-13T08:15:25.000Z","comments":false,"path":"about/index.html","permalink":"http://cansolve.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"全部分类","date":"2018-12-13T08:13:11.000Z","updated":"2018-12-13T08:13:11.000Z","comments":false,"path":"categories/index.html","permalink":"http://cansolve.github.io/categories/index.html","excerpt":"","text":""},{"title":"全部标签","date":"2018-12-13T08:13:04.000Z","updated":"2018-12-13T08:13:04.000Z","comments":false,"path":"tags/index.html","permalink":"http://cansolve.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"viewport-fit解决iPhone X、XS、XS Max、XR刘海屏问题","slug":"daily2","date":"2018-10-10T03:28:29.000Z","updated":"2018-12-14T07:26:24.000Z","comments":true,"path":"2018/10/10/daily2/","link":"","permalink":"http://cansolve.github.io/2018/10/10/daily2/","excerpt":"","text":"一次活动页面发现的iPhone X、XS、XS Max、XR刘海屏问题起因：游戏内嵌内嵌H5页面，提供的webview容器是全屏的，所以H5页面要处理以上设备的刘海问题【烦】。尺寸了解我这里就不写了，尺寸问题我就不写了，顶楼电梯iPhone X 配备一个覆盖整个手机的全面屏,顶部的“刘海”突出来使得网站被限制在一个“安全区域”,在两侧边缘会出现白条儿。移除这个白条儿也不难,给 body 设置一个 background-color 就可以搞定。但是我们内嵌的游戏页面背景色有时候不好设置背景色为纯色，另一种方法就是添加 viewport-fit=cover meta 标签,将整个网站扩展到整个屏幕1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, viewport-fit=cover&quot;&gt;iPhone XS等手机还未发布之前，我们也是跟着学做已经做一些兼容来搞定iPhoneX。这里只是横屏代码，竖屏同理；1var isIPhoneX = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 375 &amp;&amp; window.screen.width === 812;这里我们判断如果是iPhone X，把顶部增加高度30px的容器垫高，避开刘海头区域，各种方式都可以padding-left、absolute、margin-left。。。你能想到的方法都可以，这样标题正好避开刘海头。因为自己当时还没有用iPhone X，只知道iPhone X有刘海头，不知道其他细节问题。又到一年一度的9月份，苹果发布了3X机系列，有同事在Mac下的iPhone模拟器访问，发现这个页面iPhone XS Max下有问题。看了一下上面文章发现尺寸不一样，当初只判断了iPhone X加垫高，其他几个机型都未判断，所以就很自然的写了新机型，加上判断：123456// iPhone X、iPhone XSvar isIPhoneX = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 375 &amp;&amp; window.screen.width === 812;// iPhone XS Maxvar isIPhoneXSMax = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 3 &amp;&amp; window.screen.height === 414 &amp;&amp; window.screen.width === 896;// iPhone XRvar isIPhoneXR = /iphone/gi.test(window.navigator.userAgent) &amp;&amp; window.devicePixelRatio &amp;&amp; window.devicePixelRatio === 2 &amp;&amp; window.screen.height === 414 &amp;&amp; window.screen.width === 896;原来代码是if(isIPhoneX)垫高，现在改成if(isIPhoneX || isIPhoneXSMax || isIPhoneXR)垫高。这里有个坑，官方提供的安全区域代码constant(safe-area-inset-top) env(safe-area-inset-top)，使用后都在刘海头下面，如图（黑灰色区域状态栏）：当初没有用安全区域代码，一方面是因为页面有悬浮容器，会悬浮到安全区域外部，兼容页面正文麻烦，另一方面就是正文内容靠下，离刘海头有一段距离，感觉太丑干脆不用。总结：依旧不用安全区域代码，如果要做刘海头，if(isIPhoneX || isIPhoneXSMax || isIPhoneXR) 垫高44px。备注：iPhone X、iPhone XS、iPhone XS Max刘海头高度30px，iPhone XR刘海头高度33px。本文提到的30px、33px、44px，均为initial-scale=1下，px是在通用属性下，用rem写页面的请自行转换。设计稿像素应该都需要乘以2倍或3倍。","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.github.io/categories/个人/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://cansolve.github.io/tags/移动端/"}]},{"title":"JavaScript中的this","slug":"daily5","date":"2018-09-22T08:11:23.000Z","updated":"2018-12-18T10:29:21.092Z","comments":true,"path":"2018/09/22/daily5/","link":"","permalink":"http://cansolve.github.io/2018/09/22/daily5/","excerpt":"","text":"原文链接：flaviocopes.com翻译：我可是兔子this在不同的地方被调用有不同的值。不知道这些细节可能会导致很多头疼的问题, 所以你不妨花5分钟的时间来了解一下这些坑。this在严格模式下除了在声明的对象内被调用,this在严格模式下永远是undefined。注意我提到的是严格模式。如果不是在严格模式下 (在js的头部，你没有明确的添加&#39;use strict&#39;关键字 ), 那么你就处在非严格模式的状态下,this在这个环境下， 除了我下面提到的特殊案例外 ，this指代的是全局对象的值。在浏览器的上下文环境中，这个值就是window。在函数方法中的this方法就是以函数形式附属于一个对象。函数可以有不同的声明形式。下面就是其中的一种：1234567891011const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;, drive() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!) &#125;&#125;car.drive()//Driving a Ford Fiesta car!在这个例子中，使用了常规的函数声明的形式,this自动绑定为car这个对象。注意: 上面的函数声明是drive: function() {…这样声明的缩写12345678const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;, drive: function() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!) &#125;&#125;和上面的例子一样的指代:1234567891011const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;&#125;car.drive = function() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)&#125;car.drive()//Driving a Ford Fiesta car!在同样的语境下，使用箭头函数来声明函数，this的指代是不一样的，它属于词法（静态）绑定:1234567891011const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;, drive: () =&gt; &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!) &#125;&#125;car.drive()//Driving a undefined undefined car!使用箭头函数你不能在箭头函数中像其他正常的函数声明形式那样给函数绑定一个值来改变this的值。导致这个的主要原因是箭头函数的工作原理。this在箭头函数中是词法绑定的, 也就是说它的值仅取决于它在哪个对象下被定义。明确地传递一个对象来改变this的值JavaScript提供了一些方法来映射this所指代的对象，从而得到你想要的值。在函数声明的阶段，使用bind():1234567891011const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;&#125;const drive = function() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!)&#125;.bind(car)drive()//Driving a Ford Fiesta car!你可以绑定一个已定义的对象来改变this的值:12345678910111213141516const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;, drive() &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car!) &#125;&#125;const anotherCar = &#123; maker: &apos;Audi&apos;, model: &apos;A4&apos;&#125;car.drive.bind(anotherCar)()//Driving a Audi A4 car!使用call()或者apply(), 在函数调用阶段:1234567891011121314const car = &#123; maker: &apos;Ford&apos;, model: &apos;Fiesta&apos;&#125;const drive = function(kmh) &#123; console.log(Driving a $&#123;this.maker&#125; $&#123;this.model&#125; car at $&#123;kmh&#125; km/h!)&#125;drive.call(car, 100)//Driving a Ford Fiesta car at 100 km/h!drive.apply(car, [100])//Driving a Ford Fiesta car at 100 km/h!第一个传递给call()或者apply()的参数是新的this所指代的值。 call() 和 apply()两个函数的差异在于第二个参数，apply() 接受的是一个数组来作为它的参数，而call() 函数接受的是一串参数列表。DOM事件处理函数的特殊案例在浏览器事件处理函数的时候,this指代的是HTML对象，像下面的这样：123document.querySelector(&apos;#button&apos;).addEventListener(&apos;click&apos;, function(e) &#123; console.log(this) //HTMLElement&#125;但你可以使用bind() 函数来改变this值：123456document.querySelector(&apos;#button&apos;).addEventListener( &apos;click&apos;, function(e) &#123; console.log(this) //Window if global, or your context &#125;.bind(this))","categories":[{"name":"分享","slug":"分享","permalink":"http://cansolve.github.io/categories/分享/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://cansolve.github.io/tags/移动端/"}]},{"title":"移动端滚动事件overflow-y:scroll使用心得","slug":"daily4","date":"2018-09-18T07:45:43.000Z","updated":"2018-12-18T08:06:30.332Z","comments":true,"path":"2018/09/18/daily4/","link":"","permalink":"http://cansolve.github.io/2018/09/18/daily4/","excerpt":"","text":"作者：夏大师https://www.cnblogs.com/xiahj/p/8036419.html1. -webkit-overflow-scrolling:touch是什么？MDN上是这样定义的：-webkit-overflow-scrolling属性控制元素在移动设备上是否使用滚动回弹效果.auto: 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。touch: 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。在移动端上，在你用overflow-y:scorll属性的时候，你会发现滚动的效果很木，很慢，这时候可以使用-webkit-overflow-scrolling:touch这个属性，让滚动条产生滚动回弹的效果，就像ios原生的滚动条一样流畅。2. 解决safari布局抖动的例子想实现一个布局为header、main、bottom的布局，其中头部和底部通过fixed固定，中间部分通过滚动条滑动。如果目的是实现只要中间的内容超过屏幕高度时，中间内容会自动滚动的效果的话，main部分加上上下的padding，然后不需要自己添加任何滚动条属性，当超出高度时，body会自动产生滚动条。这样我们的目的其实是实现了的。但是在safari上，当超出高度，页面往下滑时，浏览器底部的工具栏会随着页面一起晃动（向下滚动时会拉起底部工具栏），造成了很不好的体验。所以我们想在中间的main部分加一个独立的滚动条。2.1 方案一在main上使用fixed定位，加上overflow-y属性。123456.main &#123; position: fixed; top: 50px; bottom: 50px; overflow-y: scroll;&#125;不过不推荐这个fixed方案，因为页面偶尔卡住不动，下面说到了这个问题。2.2 方案二中间的main不设定位，高度100%，再padding头部和尾部，其中头部和底部的定位设为absolute会比设为fixed体验更好（况且fix布局在移动端本来就有各种各样的问题，还是尽量避开:) ）。大致代码如下，仍是overflow-y和-webkit-overflow-scrolling，重点在于中间部分依照文本流布局。123456789html, body &#123; height: 100%;&#125;main &#123; padding: 50px 0; height: 100%; overflow-y: scroll; -webkit-overflow-scrolling: touch;&#125;3. 探究-webkit-overflow-scrolling:touch偶尔卡住或不能滑动的bug-webkit-overflow-scrolling:touch这个属性真的是各种坑，我研究这个属性已经大半年了，还没有发现能够在safari上完美使用无bug的例子。最常见的例子就是，在safari上，使用了-webkit-overflow-scrolling:touch之后，页面偶尔会卡住不动。在safari上，点击其他区域，再在滚动区域滑动，滚动条无法滚动的bug。通过动态添加内容撑开容器，结果根本不能滑动的bug。在网上也看到了一些人在问这个问题，不过不多，国外倒是讨论的更多一点，描述如下。偶尔卡住的问题，解决方案网上众说纷纭，遇到了很多相同的说法，比如如果卡住不动的话，就加一个z-index，就能解决该问题的说法。在试了很多次之后，这种说法没有一次解决过这个问题。这个说法能够传播出来，可能是使用者当时在使用的时候遇到了-webkit-overflow-scrolling:touch点透或者层级的问题。所以该方案不具有适用性。所以这个东西真的让我很苦恼了很久，以致于那段时间所有的滚动条不是通过body自己滚动，就是使用iScroll这样的库，繁琐地让我几乎想要放弃移动web，拥抱hybrid，不过在stackoverflow潜水了很久之后，总结了以下几种解决方案：3.1 保证使用了该属性的元素上没有设置定位如果出现偶尔卡住不动的情况，那么在使用该属性的元素上不设置定位或者手动设置定位为static1position: static这样会解决部分因为定位(relative、fixed、absolute)导致的页面偶尔不能滚动的bug。但是滑动到顶部继续手指往下滑，或者到底部继续往上滑，还是会触发卡住的问题（其实是整个页面上下回弹），说他算bug，其实就是ios8以上的特性，如果滚动区域大一点，用户不会觉得这是bug，如果小了，用户会不知道发生了什么而卡住了。视频在这，有梯子的同学可以看一看https://www.youtube.com/watch?v=MkAVYbO_joo。3.2 如果添加动态内容页面不能滚动，让子元素height+1如果在-webkit-overflow-scrolling:touch属性的元素上，想通过动态添加内容来撑开容器，触发滚动，是有bug 的，页面是会卡住不动的。国内没有人讨论这个问题，国外倒是很多，例如下面的描述：收集了很多资料，用了之后，下面的方法真正的解决了我的问题，真是直呼神奇，方案如下图：图一：图二：方法就是在webkit-overflow-scrolling:touch属性的下一层子元素上，将height加1%或1px。从而主动触发scrollbar。123main-inner &#123; min-height: calc(100% + 1px)&#125;你也可以直接加伪元素上：123main:after &#123; min-height: calc(100% + 1px)&#125;这个方案不得不说真的好用。。当然还有其他方案，不过要写js或者jq了，麻烦。3.3 为什么会有卡住不动的这个bug这个bug产生于ios8以上（不十分肯定，但在ios5~7上需要手动使用translateZ(0)打开硬件加速）Safari对于overflow-scrolling用了原生控件来实现。对于有-webkit-overflow-scrolling的网页，会创建一个UIScrollView，提供子layer给渲染模块使用。我想说作为一个苦逼的前端只能解决到这了。4. -webkit-overflow-scrolling:touch的其他坑除此之外，这个属性还有很多bug，包括且不限于以下几种：滚动中 scrollTop 属性不会变化手势可穿过其他元素触发元素滚动滚动时暂停其他 transition","categories":[{"name":"分享","slug":"分享","permalink":"http://cansolve.github.io/categories/分享/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://cansolve.github.io/tags/移动端/"}]},{"title":"基于react + bootstrap 的 react-admin","slug":"daily3","date":"2018-09-14T07:52:19.000Z","updated":"2018-12-18T09:16:49.973Z","comments":true,"path":"2018/09/14/daily3/","link":"","permalink":"http://cansolve.github.io/2018/09/14/daily3/","excerpt":"","text":"前言此 react-admin 项目是基于 bootstrap-ace 框架之上，用 react 全家桶 + bootstrap 的进行再次开发的，项目已经开源，项目地址在 github 上。框架效果预览 http://www.pydyun.com/other/ace/index.htmlgithub地址 github1. 后台管理主要项目结构123456789101112131415161718192021222324demo //项目名 -- dist //预编译，自动构建之后会生成的文件，默认初始化是没有当前这个文件 -- asserts //静态资源目录，css,font,image -- public //html模板文件 -- webpack //webpack配置文件 -- webpack.base.config.js //公用 -- webpack.dev.config.js //开发环境 -- webpack.prod.config.js //生产环境 -- src //js编写文件 -- index.js // 初始化js -- module // 基础UI模块目录 -- tools // js方法工具库目录 -- action // action 目录 -- component // 对应的模块 目录 -- dispatch // dispatch 目录 -- reducers // reducers 目录 -- index.js // 前端渲染 -- router.js // 前端路由 -- store.js // store 文件 -- .babelr //babel的校验文件 -- .eslintrc //js编写校验配置文件 -- .gitignore //git过滤文件 -- package.json //node 安装包文件 -- README.md //readme 文件2. 本地必须要有node和git环境webpack 4bootstrap + acereact 16react-router 4redux 3babelpromiseasync + await3. 项目开始先在对应的git先创建git仓库，比如：XX管理后台 demo 项目，然后 git clone 到本来的开发环境，进入当前项目目录，代码如入：12git clone ssh://git@github.com:cansolve/react-manage.gitcd demo或者12cd demogit remote add origin ssh://git@github.com:cansolve/react-manage.git这时，通过git来添加前端开发初始化的工程目录，代码如下：12git remote add base ssh://git@github.com:cansolve/react-manage.gitgit pull base master --allow-unrelated-histories然后可以推送到开发项目上面去，代码如下：123git add .git commit -m &apos;前端项目初始化&apos;git push origin demo到此，你的 demo 项目前端搭建和初始化已完毕，接下来你就可以开始 前端开发 了4. 本地项目开始先安装编译第三方的依赖包1npm install123//如果开发之前本地没有对应的server服务器，也可以用node搭个server服务器，默认是8080端口:127.0.0.1:8080,如果有的话，直接跳过这一步npm install -g http-serverhttp-server -c-14.1 开发环境生产环境中开发监听对应的文件修改1npm run start4.2 生产环境压缩生产对应的线上文件，生产 html css image font js 文件1npm run build4.3 前端的升级和更新后续当前项目的前端库升级，bug修复，版本更新，直接可以通过命令来实现1git pull base master如有改动跟本地开发的导致冲突，请手动处理冲突文件，然后push到对应项目中去。5. 项目组建介绍5.1 表格组建说明：这里表格已经写成组建形式，只需要传入对应的title及data 后台获取数据 即可渲染成表格，对应的可以选择排序、勾选、包括给详情加a标签功能;5.2 分页组建说明：分页组建，点击传入对应页码，支持输入跳转;5.3 日历组建说明：日历时间选择组建，点击展示日期列表，选择传给后台为时间戳格式;5.4 下拉选择组建说明：点击出现下拉框，支持搜索功能5.4 下拉选择【多选】组建说明：点击出现下拉框，多选功能5.4 树组建说明：传入对应的数据即可渲染成树5.4 双向选择组建说明：两边数据可以互通选择，支持一键全部选择，两边数据都支持搜索功能；具体使用api在组建里面已经写的比较详细，类似下图，再有不明白的可以联系我，一起进步；5. 最后因为这是本人自己依据creat-react-app搭建的，跟公司项目目录还是有一定区别的，包括本人写代码的一些不好的地方还请多指正。大神请绕道，放小弟一条生路，谢谢啦！！本人公众号 码上关注 不定期分享一些前端知识，一起相互交流学习。","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.github.io/categories/个人/"}],"tags":[{"name":"react","slug":"react","permalink":"http://cansolve.github.io/tags/react/"}]},{"title":"滑向未来（现代 JS 与 CSS 滚动实现指南)","slug":"daily6","date":"2018-06-03T04:11:23.000Z","updated":"2018-12-18T11:13:26.305Z","comments":true,"path":"2018/06/03/daily6/","link":"","permalink":"http://cansolve.github.io/2018/06/03/daily6/","excerpt":"","text":"英文： Evil Martians 译文：众成翻译/sea_ljfwww.zcfy.cc/article/scroll-to-the-future一些（网站）滚动的效果是如此令人着迷但你却不知该如何实现，本文将为你揭开它们的神秘面纱。我们将基于最新的技术与规范为你介绍最新的 JavaScript 与 CSS 特性，（当你付诸实践时，）将使你的页面滚动更平滑、美观且性能更好。大多数的网页的内容都无法在一屏内全部展现，因而（页面）滚动对于用户而言是必不可少的。对于前端工程师与 UX 设计师而言，跨浏览器提供良好的滚动体验，同时符合设计（要求），无疑是一个挑战。尽管 web 标准的发展速度远超从前，但代码的实现往往是落后的。下文将为你介绍一些常见的关于滚动的案例，检查一下你所用的解决方案是否被更优雅的方案所代替。消逝的滚动条在过去的三十年里，滚动条的外观不断改变以符合设计的趋势，设计师们为（滚动条的）颜色、阴影、上下箭头的形状与边框的圆角实验了多种风格。以下是 Windows 上的变化历程：（Windows 上的滚动条）在2011年，苹果设计师从 ios 上获得灵感，为如何定义“美观的”滚动条确定了方向。所有滚动条均从 Mac 电脑中消失，不再占据任何页面空间，只有在用户触发滚动时（滚动条）才会重新出现（有些用户会设置不隐藏滚动条）。（Mac 上的滚动条）滚动条安静地消逝并未引起苹果粉丝的不满，已经习惯了 iPhone 与 iPad 上滚动方式的用户很快地习惯了这一设计。大多数开发人员与设计师都认为这是一个“好消息”，因为计算滚动条的宽度可真是件苦差事。然而，我们生活在一个拥有众多操作系统与浏览器的世界中，它们（对于滚动）的实现各不相同。如果你和我们一样是一名 Web 开发者，你可不能把“滚动条问题”置之不理。以下将为你介绍一些小技巧，使你的用户在滚动时有更好的体验。隐藏但可滚动先来看看一个关于模态框的经典例子。当它被打开的时候，主页面应该停止滚动。在 CSS 中有如下的快捷实现方式：body{overflow: hidden;}但上述代码会带来一点不良的副作用：（注意红色剪头）在这个示例中，为了演示目的，我们在 Mac 系统中设置了强制显示滚动条，因而用户体验与 Windows 用户相似。我们该如何解决这个问题呢？如果我们知道滚动条的宽度，每次当模态框出现时，可在主页面的右边设置一点边距。由于不同的操作系统与浏览器对滚动条的宽度不一，因而获取它的宽度并不容易。在Mac 系统中，无论任何浏览器（滚动条）都是统一15px，然而 Windows 系统可会令开发者发狂：（“百花齐放”的宽度）注意，以上仅是 Windows 系统下基于当前最新版浏览器（测试所得）的结果。以前的（浏览器）版本（宽度）可能有所不同，也没人知道未来（滚动条的宽度）会如何变化。不同于猜测（滚动条的宽度），你可以通过 JavaScript 计算它的宽度（译者注：实测以下代码仅能测出原始的宽度，通过 CSS 改变了滚动条宽度后，以下代码也无法测出实际宽度）：constouter = document.createElement(‘div’);constinner = document.createElement(‘div’);outer.style.overflow = ‘scroll’;document.body.appendChild(outer);outer.appendChild(inner);constscrollbarWidth = outer.offsetWidth - inner.offsetWidth;document.body.removeChild(outer);尽管仅仅七行代码（就能测出滚动条的宽度），但有数行代码是操作 DOM 的。（为性能起见，）如非必要，尽量避免进行 DOM 操作。解决这个问题的另一个方法是在模态框出现时仍保留滚动条，以下是基于这思路的纯 CSS 实现：html{overflow-y: scroll;}尽管“模态框抖动”问题解决了，但整体的外观却被一个无法使用的滚动条影响了，这无疑是设计中的硬伤。在我们看来，更好的解决方案是完全地隐藏滚动条。纯粹用 CSS 也是可以实现的。该方法（达到的效果）和 macOS 的表现并不是完全一致，（当用户）滚动时滚动条仍然是不可见的。滚动条总是处于不可见状态，然而页面是可被滚动的。对于Chrome，Safari 和 Opera 而言，可以使用以下的 CSS：.container::-webkit-scrollbar{display: none;}IE 或 Edge 可用以下代码:.container{-ms-overflow-style: none;}至于 Firefox，很不幸，没有任何办法隐藏滚动条。正如你所见，并没有任何银弹。任何解决方案都有它的优点与缺点，应根据你项目的需要选择最合适的。外观争议需要承认的是，滚动条的样子在部分操作系统上并不好看。一些设计师喜欢完全掌控他们（所设计）应用的样式，任何一丝细节也不放过。在 GitHub 上有上百个库借助 JavaScript 取代系统滚动条的默认实现，以达到自定义的效果。但如果你想根据现有的浏览器定制一个滚动条呢？（很遗憾，）并没有通用的 API，每个浏览器都有其独特的代码实现。尽管5.5版本以后的 IE 浏览器允许你修改滚动条的样式，但它只允许你修改滚动条的颜色。以下是如何重新绘制（滚动条）拖动部分与箭头的代码：body{scrollbar-face-color: blue;}但只改变颜色对提高用户体验而言帮助不大。据此，WebKit 的开发者在2009年提出了（修改滚动条）样式的方案。以下是使用 -webkit 前缀在支持相关样式的浏览器中模拟 macOS 滚动条样式的代码：::-webkit-scrollbar{width: 8px;}::-webkit-scrollbar-thumb{background-color: #c1c1c1;border-radius: 4px;}Chrome、Safari、Opera 甚至于 UC 浏览器或者三星自带的桌面浏览器都支持（上述 CSS）。Edge 也有计划实现它们。但三年过去了，该计划仍在中等优先级中（而尚未被实现）。当我们讨论滚动条的定制时，Mozilla 基金会基本上是无视了设计师的需求。（有开发者在）17年前就已经提出了一个希望修改滚动条样式的请求。而就在几个月前，Jeff Griffiths（Firefox 浏览器总监）终于为这个问题作出了回答：“除非团队中有人对此有兴趣，否则我对此毫不关心。”公平地说，从 W3C 的角度看来，尽管 WebKit 的实现得到广泛的支持，但它仍然不是标准。现有的为滚动条修改样式的草案，是基于 IE 的：仅能修改它的颜色。伴随着请求如同 WebKit 一样支持滚动条样式修改 issue 的提交，争议仍在继续。如果你想影响 CSS 工作小组，是时候参与讨论了。也许这不是优先级最高的问题，但（如同 WebKit 一样修改滚动条样式）得到标准化后，能使很多前端工程师与设计师轻松很多。流畅的操作体验对于滚动而言，最常见的任务是登录页的导航（跳转）。通常，它是通过锚点链接来完成的。只需要知道元素的 id 即可：&lt;ahref=”#section”&gt;点击该链接会 跳 到（该锚点对应的）区块上，（然而） UX 设计师一般会坚持认为该过程应是平滑地运动的。GitHub 上有大量造好的轮子（帮你解决这个问题），然而它们或多或少都用到 JavaScript。（其实）只用一行代码也能实现同样的效果，最近DOM API 中的 Element.scrollIntoView() 可以通过传入配置对象来实现平滑滚动：elem.scrollIntoView({behavior: ‘smooth’});然而该属性兼容性较差且仍是通过脚本（来控制样式）。如有可能，应尽量少用额外的脚本。幸运的是，有一个全新的 CSS 属性（仍在工作草案中），可以用简单的一行代码改变整个页面滚动的行为。html{scroll-behavior: smooth;}结果如下:（从一个区块跳到另一个）（平滑地滚动）你可以在 codepen 上试验这个属性。在撰写本文时，scroll-behavior 仅在 Chrome、 Firefox 与 Opera 上被支持，但我们希望它能被广泛支持，因为使用 CSS （比使用 JavaScript）在解决页面滚动问题时优雅得多，并更符合“渐进增强”的模式。粘性 CSS另一个常见的需求是根据滚动方向动态地定住元素，即有名的“粘性（即 CSS 中的position: sticky）”效应。（一个粘性元素）在以前的日子里，要实现一个“粘性”元素需要编写复杂的滚动处理函数去计算元素的大小。（然而）该函数较难处理元素在“黏住”与“不黏住”之间微小的延迟，（通常会）导致（元素）抖动的出现。通过 JavaScript 来实行（“粘性”元素）也有性能上的问题，特别是在（需要）调用 [Element.getBoundingClientRect() ]时(https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)。不久之前，CSS 实现了 position: sticky 属性。只需通过指定（某方向上的）偏移量即可实现我们想要的效果。.element{position: sticky;top: 50px;}（编写上述代码后，）剩下的就交由浏览器实现即可。你可以在 codepen 上试验一下。撰写本文之时，position: sticky 在各式浏览器（包括移动端浏览器）上支持良好，所以如果你还在使用 JavaScript 去解决这个问题的话，是时候换成纯 CSS 的实现了。全面使用函数节流从浏览器的角度看来，滚动是一个事件，因此在 JavaScript 中是使用一个标准化的事件监听器 addEventListener 去处理它： ，window.addEventListener(‘scroll’,() =&gt; {constscrollTop = window.scrollY;/ doSomething with scrollTop /});用户往往高频率地滚动（页面），但如果滚动事件触发太频繁的话，会导致性能上的问题，可以通过使用函数节流这一技巧去优化它。window.addEventListener(‘scroll’,throttle(() =&gt; {constscrollTop = window.scrollY;/ doSomething with scrollTop /}));你需要定义一个节流函数包装原来的事件监听函数，（节流函数是）减少被包装函数的执行次数，只允许它在固定的时间间隔之内执行一次：functionthrottle(action,wait = 1000){let time = Date.now();returnfunction(){if((time + wait - Date.now()) &lt; 0){action();time = Date.now();}}}为了使（节流后的）滚动更平滑，你可以通过使用 window.requestAnimationFrame() 来实现函数节流：functionthrottle(action){let isRunning = false;returnfunction(){if(isRunning)return;isRunning = true;window.requestAnimationFrame(() =&gt; {action();isRunning = false;});}}当然，你可以通过现有的开源轮子来实现，就像 Lodash 一样。你可以访问 codepen 来看看上述解决方案与 Lodash 中的 _.throttle 之间的区别。使用哪个（开源库）并不重要，重要的是在需要的时候，记得优化你（页面中的）滚动处理函数。在视窗中显示当你需要实现图片懒加载或者无限滚动时，需要确定元素是否出现在视窗中。这可以在事件监听器中处理，最常见的解决方案是使用 lement.getBoundingClientRect() ：window.addEventListener(‘scroll’,() =&gt; {constrect = elem.getBoundingClientRect();constinViewport = rect.bottom &gt; 0 &amp;&amp; rect.right &gt; 0 &amp;&amp;rect.left &lt; window.innerWidth &amp;&amp;rect.top &lt; window.innerHeight;});上述代码的问题在于每次调用 getBoundingClientRect 时都会触发回流，严重地影响了性能。在事件处理函数中调用（ getBoundingClientRect ）尤为糟糕，就算使用了函数节流（的技巧）也可能对性能没多大帮助。 （回流是指浏览器为局部或整体地重绘某个元素，需要重新计算该元素在文档中的位置与形状。）在2016年后，可以通过使用 Intersection Observer 这一 API 来解决问题。它允许你追踪目标元素与其祖先元素或视窗的交叉状态。此外，尽管只有一部分元素出现在视窗中，哪怕只有一像素，也可以选择触发回调函数：constobserver = newIntersectionObserver(callback,options);observer.observe(element);此 API 被广泛地支持，但仍有一些浏览器需要 polyfill。尽管如此，它仍是目前最好的解决方案。滚动边界问题如果你的弹框或下拉列表是可滚动的，那你务必要了解连锁滚动相关的问题：当用户滚动到（弹框或下拉列表）末尾（后再继续滚动时），整个页面都会开始滚动。（连锁滚动的表现）当滚动元素到达底部时，你可以通过（改变）页面的 overflow 属性或在滚动元素的滚动事件处理函数中取消默认行为来解决这问题。如果你选择使用 JavaScript （来处理），请记住要处理的不是“scroll（事件）”，而是每当用户使用鼠标滚轮或触摸板时触发的“wheel（事件）”：functionhandleOverscroll(event){constdelta = -event.deltaY;if(delta&lt; 0 &amp;&amp; elem.scrollHeight - elem.scrollTop){elem.scrollTop = elem.scrollHeight;event.preventDefault();returnfalse;}if(delta &gt; elem.scrollTop){elem.scrollTop = 0;event.preventDefault();returnfalse;}returntrue;}不幸的是，这个解决方案不太可靠。同时可能对（页面）性能产生负面影响。过度滚动对移动端的影响尤为严重。Loren Brichter 在 iOS 的 Tweetie 应用上创造了一个“下拉刷新”的新手势，这在 UX 社区中引起了轰动：包括 Twitter 与 Facebook 在内的各大应用纷纷采用了（相同的手势）。当这个特性出现在安卓端的 Chrome 浏览器中时，问题出现了：它会刷新整个页面而不是加载更多的内容，成为开发者在他们的应用中实现“下拉刷新”时的麻烦。CSS 通过 overscroll-behavior 这个新属性解决问题。它通过控制元素滚动到尽头时的行为来解决下拉刷新与连锁滚动所带来的问题，（它的属性值中）也包含针对不同平台特殊值：安卓的 glow 与 苹果系统中的 rubber band。现在，上面 GIF 中的问题，在 Chrome、Opera 或 Firefox 中可以通过以下一行代码来解决：.element{overscroll-behavior: contain;}公平地说，IE 与 Edge 实现了（它独有的） -ms-scroll-chaining 属性来控制连锁滚动，但它并不能处理所有的情况。幸运的是，根据这消息，微软的浏览器已经准备实现 overscroll-behavior 这一属性了。触屏之后触屏设备上的滚动（体验）是一个很大的话题，深入讨论需要另开一篇文章。然而，由于很多开发者忽略了这方面的内容，这里需要提及一下。（滚动手势无处不在，令人沉迷，以至于想出了如此疯狂的主意去解决“滚动上瘾”的问题。）周围的人在智能手机屏幕上上下移动他们的手指的频率是多少呢？经常这样对吧，当你阅读本文时，你很可能就在这么做。当你的手指在屏幕上移动时，你期待的是：页面内容平滑且流畅地移动。苹果公司开创了“惯性”滚动并拥有它的专利 。它讯速地成为了用户交互的标准并且我们对此已习以为常。但你也许已经注意到了，尽管移动端系统会为你实现页面上的惯性滚动，但当页面内某个元素发生滚动时，即使用户同样期待惯性滚动，但它并不会出现，这令人沮丧。这里有一个 CSS 的解决方案，但看起来更像是个 hack：.element{-webkit-overflow-scrolling: touch;}为什么这是个 hack 呢？首先，它只能在支持（webkit）前缀的浏览器上才能工作。其次，它只适用于触屏设备。最后，如果浏览器不支持的话，你就这样置之不理吗？但无论如何，这总归是一个解决方案，你可以试着使用它。在触屏设备上，另一个需要考虑的问题是开发者如何处理 touchstart 与 touchmove 事件触发时可能存在的性能问题，它对用户滚动体验的影响非常大。这里详细描述了整个问题。简单来说，现代的浏览器虽然知道如何使得滚动变得平滑，但为确认（滚动）事件处理函数中是否执行了 Event.preventDefault() 以取消默认行为，有时仍可能需要花费500毫秒来等待事件处理函数执行完毕。即使是一个空的事件监听器，从不取消任何行为，鉴于浏览器仍会期待 preventDefault 的调用，也会对性能造成负面影响。为了准确地告诉浏览器不必担心（事件处理函数中）取消了默认行为，在 WHATWG 的 DOM 标准中存在着一个不太显眼的特性（能解决这问题）。（它就是）Passive event listeners，浏览器对它的支持还是不错的。事件监听函数新接受一个可选的对象作为参数，告诉浏览器当事件触发时，事件处理函数永远不会取消默认行为。（当然，添加此参数后，）在事件处理函数中调用 preventDefault 将不再产生效果。element.addEventListener(‘touchstart’,e =&gt; {/ doSomething /},{passive: true});针对不支持该参数的浏览器，这里也有一个 polyfill 。这视频清晰地展示了此改进带来的影响。旧技术运行良好，为何还要改动？在现代互联网中，过渡地依赖 JavaScript 在各浏览器上实现相同的交互效果不再是合理的，“跨浏览器兼容性”已经成为过去式，更多的 CSS 属性与 DOM API 方法正逐步被各大浏览器所支持。在我们看来，当你的项目中，有特别酷炫的滚动效果时，渐进增强是最好的做法。你应该提供（给用户）所有（你能提供的）基础用户体验，并逐步在更先进的浏览器上提供更好的体验。必要时使用 polyfill，它们不会产生（不必要的）依赖，一旦（某个 polyfill 所支持的属性）得到广泛地支持，你就可以轻松地将它删掉。六个月之前，在本文尚未成文之时，之前我们描述的属性只被少量的浏览器所支持。而到了本文发表之时，这些属性已被广泛地支持。也许到了现在，当你上下翻阅本文之时，（之前不支持某些属性的）浏览器已经支持了该属性，这使得你编程更容易，并使你的应用打包出来体积更小。感谢阅读至此！查阅浏览器的更新日志，积极参与讨论，有助于 web 标准驶向正确的方向。祝大家一帆风顺，顺利滑（滚）向未来！","categories":[{"name":"分享","slug":"分享","permalink":"http://cansolve.github.io/categories/分享/"}],"tags":[{"name":"css","slug":"css","permalink":"http://cansolve.github.io/tags/css/"}]},{"title":"用Hexo + github搭建自己的博客","slug":"daily1","date":"2018-04-02T11:25:46.000Z","updated":"2018-12-14T07:27:02.000Z","comments":true,"path":"2018/04/02/daily1/","link":"","permalink":"http://cansolve.github.io/2018/04/02/daily1/","excerpt":"","text":"前言这是我第一次写这种类型的博客，也不叫什么博客，纯粹个人一些踩坑过程罢了，原先弄的前后端分离的开发流程想想太复杂，一个博客页面没啥必要，主要还是记录自己的一些心得，内容比较重要。话不多说，开搞！！！基于node和git安装node.js和git这个就不多说了，贴个地址快速开始1、找个文件夹下打开终端,输入hexo i blogName //blog是项目名 cd blogName //切换到站点根目录 hexo g //generetor的缩写 hexo s //server的缩写 2 打开浏览器输入localhost:4000查看：看到这个样子就说明成功了，这个就是hexo默认的博客主题。现在你已经可以在这个主题下写博客了。你还可以选择博客的主题theme选择主题我选的是Claudia1 . 在站点根目录输入git clone https://github.com/Haojen/hexo-theme-Claudia.git 2 . 完成后，打开根目录下的 _config.yml 文件， 找到 theme 字段，把landscape改为 Claudia3 . 在终端输入hexo clean //清除缓存 hexo g //重新生成代码 hexo s //部署到本地 //然后打开浏览器访问 localhost:4000 查看效果 这时候主题已经换了，主题里面的修改项自行查阅一下，很多都有注释上传到github没有github账号的，自行注册一个【很少人没有吧】完了继续下一步选择一个主题结束访问 xxxxx.github.io 会看到上面一样的页面修改文件注意！！！冒号的后面一定一定一定要有一个空格！！ 开始部署npm install hexo-deployer-git --save //先装个插件 hexo d // 部署的命令 网上有的教程说需要账号密码，我这边没遇到，所以就不方便截图了发布第一篇博客根目录下输入 ：hexo new &quot;postName&quot; //hexo n 也可以 //你自己的博客名称，名为postName.md的文件会建在目 //录/blog/source/_posts下。 文章编辑完成后，终端在根目录文件夹下，执行如下命令来发布:hexo g //生成静态页面，类似于打个包 hexo d //发布 这样就可以发布咯","categories":[{"name":"个人","slug":"个人","permalink":"http://cansolve.github.io/categories/个人/"}],"tags":[{"name":"建站","slug":"建站","permalink":"http://cansolve.github.io/tags/建站/"}]}]}